{"category": "Програмування", "title": "Програмування", "abstract": "Програмування — процес проєктування, написання, тестування, зневадження і підтримки комп'ютерних програм. Програмування поєднує в собі елементи інженерії (існує відповідна спеціальна галузь інженерії — програмна інженерія, англ. software engineering), фундаментальних наук (перш за все комп'ютерних наук і математики) і мистецтва.\nУ вужчому значенні програмування розглядається як \"кодування\" — реалізація у вигляді програми одного чи кількох взаємопов'язаних алгоритмів (у сучасних умовах це здійснюється з застосуванням мов програмування). У ширшому розумінні процес програмування охоплює і створення, тобто розроблення, алгоритмів, і аналіз потреб майбутніх користувачів програмного забезпечення. Результатом програмування зазвичай є програма або програмний продукт.\nТехнологія програмування постійно розвивається, що призводить до появи нових мов програмування, інструментів розроблення і сфер застосування. Також підвищується потужність готових компонентів, доступних для використання програмістами. Тому важливою ознакою програмування є регулярне опанування нових технологій.\nУ широкому значенні програмування означає зазначення послідовності майбутніх дій з урахуванням різних ситуацій або складання алгоритмів та навчання людей або пристроїв діяти за алгоритмами.", "content": "Програмування — процес проєктування, написання, тестування, зневадження і підтримки комп'ютерних програм. Програмування поєднує в собі елементи інженерії (існує відповідна спеціальна галузь інженерії — програмна інженерія, ), фундаментальних наук (перш за все комп'ютерних наук і математики) і мистецтва. У вужчому значенні програмування розглядається як \"кодування\" — реалізація у вигляді програми одного чи кількох взаємопов'язаних алгоритмів (у сучасних умовах це здійснюється з застосуванням мов програмування). У ширшому розумінні процес програмування охоплює і створення, тобто розроблення, алгоритмів, і аналіз потреб майбутніх користувачів програмного забезпечення. Результатом програмування зазвичай є програма або програмний продукт. Технологія програмування постійно розвивається, що призводить до появи нових мов програмування, інструментів розроблення і сфер застосування. Також підвищується потужність готових компонентів, доступних для використання програмістами. Тому важливою ознакою програмування є регулярне опанування нових технологій. У широкому значенні програмування означає зазначення послідовності майбутніх дій з урахуванням різних ситуацій або складання алгоритмів та навчання людей або пристроїв діяти за алгоритмами. Історія Сучасне програмування Критерії якості Яким би не був підхід до створення програмного забезпечення, кінцева програма має задовольняти деяким вимогам. Найчастіше зустрічаються: Ефективність/Продуктивність: кількість ресурсів системи, що споживає програма (час процесора, розмір пам'яті, зовнішня пам'ять, ширина каналу мережі, і навіть взаємодії з користувачем). Чим менше ресурсів споживається, тим краще; Надійність: ймовірність того, що результат роботи програми правильний. Це залежить від коректності алгоритмів та правильності кодування; Стійкість: як програма розв'язує проблеми в нестандартних ситуаціях, як-от неправильні дані, недоступність необхідних ресурсів, таких як пам'ять чи локальна мережа, та неправильні дії користувача; Зручність: ергономічність програми. Легкість, з якою особа може використовувати програму для своїх цілей; Платформонезалежність: діапазон апаратного забезпечення та операційних систем на яких можна компілювати чи інтерпретувати код програми, виконуючи її. Це залежить від відмінностей в програмних ресурсах наданих різними платформами, включаючи ресурси, наявність компіляторів та бібліотек для мови програмування; Масштабованість: Простота подальшого супроводження програми, тобто внесення в неї додаткових вдосконалень, що збільшують функціональність чи виправляють помилки. Цей критерій не стосується користувача безпосередньо, але впливає на час, протягом якого програма буде використовуватись. Естетичність: Вигляд програми на екрані з погляду підбору кольорів, форм, розмірів графічних елементів і контролів, гармонійності їх взаємного розташування, якість малюнків, вибір шрифтів тексту, а також доречність звукових сигналів і мелодій, рухів вібродвигуна. Етичність: Ступінь спрямованості на задоволення справжніх потреб людей, реалізацію кращих і законних бажань користувачів і розробників. Рівні програмування Успішне програмування передбачає виконання необхідних дій на таких рівнях: Економічний (бізнес-логіка): Формування вимог до програмного продукту з урахуванням привабливості для користувачів, прибутковості для розробника і наявних можливостей розробника. Побудова загального уявлення про функціональність, спрямованість і призначення програмного продукту; Структурний (архітектура): Створення переліку і взаємозв'язків потрібних модулів, графічних і звукових елементів, алгоритмів, баз даних, файлів, вибір мови програмування. Результатом цього кроку є повне, детальне й однозначне уявлення про функціонування майбутнього програмного продукту, включно з усіма графічними елементами, подіями і їх обробниками, станами й режимами роботи програми, сценаріями використання (\"use cases\") і протоколами обміну, а також послідовність дій програміста, яка призводить до реалізації задуманого продукту; Детальний/Фізичний (кодування): Реалізація окремих функцій з використанням конструкцій, операторів і бібліотек мови програмування, формування образів екранів в графічних дизайнерах, друкування тексту програми на клавіатурі. Для кожного програмного проєкту наведену послідовність дій можна виконувати декілька разів, що призводить до «ітеративного покращення» програмного продукту. Суперкомпіляція Суперкомпіляція — метод аналізу й перетворення програм на основі наступних дій: Робиться спроба «виконати» програму не для конкретних вхідних даних, а «символічно» у «загальному» вигляді, тобто для довільних вхідних даних. Для цього будується «дерево процесів». Якщо початкова програма містить цикли та/або рекурсію, то дерево процесів є нескінченним. У цьому випадку робиться спроба згорнути нескінченне дерево у скінченний «граф конфігурацій». Для цього конфігурації порівнюються між собою. Побудований скінченний граф конфігурацій перетворюється в «залишкову» програму. Спеціалізація програм. Нехай — програма, — обмеження на умови експлуатації . Тоді на вхід спеціалізатора подається , а задача спеціалізатора — породити залишкову програму яка повинна задовільняти наступним умовам за умов ; отримується з шляхом вилучення непотрібних фрагментів в результаті накладання умов . Мова програмування Це система позначень яку використовує програміст для опису програми. Теорія програмування Пов'язана з вивченням програмування в загальному контексті інформатики як наукової дисципліни. Див. також Нейролінгвістичне програмування Мова програмування Логіка в інформатиці Композиційне програмування Мова моделювання Людино-машинна взаємодія Інтерфейс користувача Спортивне (олімпіадне) програмування Google Code Jam TopCoder Facebook Hacker Cup Міжнародна олімпіада з інформатики Примітки Посилання Програмування українською Форум з програмування Література Зубенко В. В. Програмування: навчальний посібник (гриф МОН України) / В. В. Зубенко, Л. Л. Омельчук. — К. : ВПЦ «Київський університет», 2011. — 623 c. Логічне і функціональне програмування: навч. посіб. / В. М. Заяць, М. М. Заяць ; Нац. ун-т «Львів. політехніка». — Львів ; Кам'янець-Подільський: Гордукова І. Є., 2016. — 398 с. : рис. Нікітченко М. С. Теоретичні основи програмування: навчальний посібник / М.С Нікітченко — Ніжин: Видавництво НДУ імені Миколи Гоголя, 2010. — 121 с. Основи програмування: навч. посіб. / Л. І. Козак, І. В. Костюк, С. Л. Стасевич. — Львів: Новий Світ — 2000, 2019. — 326 с. Програмування веб-застосувань (фронт-енд та бек-енд): навч. посіб. / Р. А. Мельник ; Нац. ун-т «Львів. політехніка». — Львів: Вид-во Львів. політехніки, 2018. — 247 с. : рис., табл. Категорія:Цифрові обчислення Категорія:Комп'ютерні технології"}
{"category": "Програмування", "title": "Жінки в програмуванні", "abstract": "Жінки в обчислювальній техніці сформували еволюцію інформаційних технологій. Вони були одними з перших програмістів на початку 20 століття і зробили значний внесок у цю галузь. Зі зміною технологій та практик роль жінок як програмісток змінювалася, а записана історія галузі зменшила їхні досягнення.\nПочинаючи з 18 століття, жінки здійснили наукові обчислення, включаючи передбачення Ніколь-Рейн Лепот про комету Галлея та обчислення Марії Мітчелл руху Венери. Перший алгоритм, призначений для виконання комп'ютером, було розроблено Адою Лавлейс, піонерко галузі. Українка Катерина Ющенко першою у світі створила мову програмування для комп'ютера. Ґрейс Гоппер стала першою людиною, яка розробила компілятор для мови програмування. Протягом ХІХ та початку ХХ століття, а також до Другої світової програмування здійснювали переважно жінки; найвагомішими прикладами є жіночій персонал Гарвардської обсерваторії відомим під назвою Гарвардські обчислювачки, декодувальниці в Блечлі-Парк та інженерія в НАСА.\nПісля 1960-х «м'яку роботу», в якій панували жінки, перебрало на себе сучасне програмне забезпечення, і значення жінок в ІТ зменшилось. Сучасне суспільство прагне осмислити гендерну нерівність та брак жінок у обчислювальній техніці з кінця ХХ століття і далі, вживаються заходи з викорінення гендерної нерівності в галузі (див. Жінки у галузях STEM та Освіта жінок у STEM). Багато жінок продовжували робити вагомий внесок в ІТ всупереч розвитку нерівності. У ХХІ столітті жінки займали керівні ролі в кількох технологічних компаніях, такі як Мег Вітмен, президентка і головна виконавча директорка Hewlett Packard Enterprise, і Марісса Маєр, президентка і генеральна директорка Yahoo!, ключова речниця Google.", "content": "Жінки в обчислювальній техніці сформували еволюцію інформаційних технологій. Вони були одними з перших програмістів на початку 20 століття і зробили значний внесок у цю галузь. Зі зміною технологій та практик роль жінок як програмісток змінювалася, а записана історія галузі зменшила їхні досягнення. Починаючи з 18 століття, жінки здійснили наукові обчислення, включаючи передбачення Ніколь-Рейн Лепот про комету Галлея та обчислення Марії Мітчелл руху Венери. Перший алгоритм, призначений для виконання комп'ютером, було розроблено Адою Лавлейс, піонерко галузі. Українка Катерина Ющенко першою у світі створила мову програмування для комп'ютера. Ґрейс Гоппер стала першою людиною, яка розробила компілятор для мови програмування. Протягом ХІХ та початку ХХ століття, а також до Другої світової програмування здійснювали переважно жінки; найвагомішими прикладами є жіночій персонал Гарвардської обсерваторії відомим під назвою Гарвардські обчислювачки, декодувальниці в Блечлі-Парк та інженерія в НАСА. Після 1960-х «м'яку роботу», в якій панували жінки, перебрало на себе сучасне програмне забезпечення, і значення жінок в ІТ зменшилось. Сучасне суспільство прагне осмислити гендерну нерівність та брак жінок у обчислювальній техніці з кінця ХХ століття і далі, вживаються заходи з викорінення гендерної нерівності в галузі (див. Жінки у галузях STEM та Освіта жінок у STEM). Багато жінок продовжували робити вагомий внесок в ІТ всупереч розвитку нерівності. У ХХІ столітті жінки займали керівні ролі в кількох технологічних компаніях, такі як Мег Вітмен, президентка і головна виконавча директорка Hewlett Packard Enterprise, і Марісса Маєр, президентка і генеральна директорка Yahoo!, ключова речниця Google. Історія ліворуч|міні| Гарвардські обчислювачки астронома Едварда Чарльза Пікерінга XVIII століття Ніколь-Рейн Етабль де Лабрієр під новим іменем — Лепот — увійшла в історію світової науки як перша у Франції жінка-астрономка, одна з колективу обчислювачів, які працювали з Алексі Клодом Креро та Жозефом-Жеромом Лефрансуа де Лаландом, щоб розрахувати орбіту та передбачити дату повернення Комети Галлея. Вони почали працювати над розрахунками в 1757 році, працюючи протягом дня, іноді без перерви на їжу. Вони розділили великі обчислення на «незалежні шматки, зібрали результати з кожної частини в кінцевий продукт», а потім перевірили на помилки. Їх методом активно користувались майбутні покоління обчислювачів. Лепот продовжувала працювати над обчисленням до кінця свого життя, працюючи в Connaissance de Temps і публікуючи передбачення сонячних затемнень. XIX століття Використовуючи дводюймовий телескоп 1 жовтня 1847 року 29-річна Марія Мітчел відкрила комету, яку назвали «Кометою міс Мітчелл». Вона була нагороджена золотою медаллю короля Данії Фредеріка VI й стала першою жінкою, обраною в Американську академію мистецтв і наук у 1848 році.альт=Woman working on a Bombe computing device.|ліворуч|міні| Жінки працюють на обчислювальному пристрої Bombe міні| Енні Джамп Кеннон працює в Гарварді Пізніше обрана до Американської асоціації просування науки та Американського філософського товариства, Мітчелл, швидше за все, була однією з перших жінок, професійно зайнятих урядом США. Вона працювала в офісі Морського альманаху у Вашингтоні, де розрахувала позицію Венери. Кароліна Гершель, сестра британського астронома і композитора німецького походження Вільяма Гершеля, під його керівництвом вивчила основи математики та асистувала і наукових обчисленнях. Гершель стала першою жінкою, чию наукову статтю опублікувало Лондонське королівське товариство, завершила до 1828 підготовку до друку каталогів відкритих братом туманностей і зоряних скупчень (понад 2500 об'єктів). Самостійно здійснювала астрономічні спостереження. Впродовж 1786—1797 років відкрила 8 комет і 14 туманностей. Гершель уклала покажчик зі списком помилок для зоряного каталогу Джона Флемстида та випустила новий додатковий каталог, до якого внесла 561 зорю, пропущену Флемстідом. Англійська математикиня Ада Лавлейс вважається першою програмісткою. Вона зробила опис ранньої версії обчислювального пристрою загального призначення Чарлза Беббіджа — аналітичної машини. Склала першу у світі програму (для цієї машини). Після Громадянської війни у США все більше людей наймали обчислювачами. Багато вдів загиблих воїнів шукали способи заробітку. Інші жінки отримали цю роботу, коли уряд відкрив для жінок посади через брак чоловіків. Група жінок під керівництвом Едварда Чарлза Пікерінга, яка увійшла в історію як Гарвардські обчислювачки, аналізувала астрономічні дані в обсерваторії Гарвардського коледжу. Гарвард був першим університетом, який найняв жінок на цей вид роботи. За допомогою фотопластин обчислювачки вивчали рух, температуру зірок і відстань між ними. Класифікацією, розробленою однією з учасниць групи Енні Джамп Кеннон, користуються донині. Її колежанка Генрієтта Лівітт розробила спосіб вимірювання космічних відстаней з опорою на циклічні пертурбації змінних зірок. Вважається, що Пікерінг найняв жінок, оскільки при тому ж об'ємі і якості жіноча праця оцінюється дешевше, при тому, що жінки краще пристосовані до кропіткої роботи. Працювали «Гарвардські обчислювачки» 6 днів на тиждень за 25 центів на годину.міні|Група операторок працює на телефонному щиті AT&TСеред жінок, які складали цю групу, були Вільяміна Флемінг, Енні Джамп Кеннон, Генрієтта Свон Лівітт, Флоренція Кушман та Антонія Каетана Морі.альт=PFC Patricia Barbeau operates a tape-drive on the IBM 729 at Camp Smith.|ліворуч|міні| PFC Patricia Barbeau працює на стрічці накопичувача на IBM 729 в Camp Smith XX століття 1910-ті роки Під час Першої світової Карл Пірсон та його лабораторія з біометрики допомагали здійснювати балістичні розрахунки для Міністерства боєприпасів Великої Британії. Беатріс Мейбл Кейв-Браун-Кейв допомогла обчислити траєкторії бомбових снарядів. У 1916 році Кейв-Браун-Кейв покинула роботу Пірсона і почала працювати на повний робочий день у Міністерстві. У США для розрахунків балістики в 1918 році були найняті обчилювачки, які працювали в будівлі торгового центру у Вашингтоні. Одна з них, Елізабет Вебб Вілсон, працювала головною обчислювачкою. Після війни жінки, які обчислювали балістику для уряду США, мали проблеми з працевлаштуванням в галузі обчислювальної техніки, і Вілсон врешті викладала математику в середній школі. 1920-ті роки На початку 1920-х років державний коледж штату Айова під керівництвом професора Джорджа Снедекора працював над удосконаленням наукових та технічних засобів навчання, експериментуючи з новими машинами-перфокартами та калькуляторами. Снедекор також працював з обчислювачами, серед яких більшість жінок, зокрема Мері Клем. Клем ввела термін «нульова перевірка» як метод пошуку помилок в некомп'ютеризованих обчисленнях. Обчислювальна лабораторія, якою керувала Клем, стала однією з найпотужніших обчислювальних центрів того часу. Едіт Кларк (1883—1959) стала першою жінкою, яка отримала ступінь інженера-електрика в 1919 році, і першою жінкою, яка професійно працювала інженером-електроніком у США, її найняли на посаду штатного інженера в General Electric в 1923 році.міні| Енні Іслі в NASA |альт=|ліворуч 1930-ті роки У 1935 році Національний консультативний комітет з повітроплавання вперше найняв 5 білих жінок в якості обчислювачок.альт=Marlyn Wescoff, standing, and Ruth Lichterman reprogram the ENIAC in 1946.|міні| Мерлін Вескофф (стоїть) та Рут Ліхтерман (присіла) перепрограмовують ENIAC за допомогою дротів і перемичок (1946 рік) 1940-ві роки Рутинні та громіздкі обчислення вважалися жіночою роботою впродовж 40-х років ХХ століття. Це демонструє, наприклад, термін «kilogirl», введений членом Комісії прикладної математики на початку десятиліття. Один кілограм енергії дорівнював приблизно тисячі годин роботи за комп'ютером. Під час Другої світової війни жінки виконували більшість балістичних розрахунків, оскільки чоловіки вважали цю роль нижчою за рівень власної компетентності.When Computers Were Women thumb|Зліва направо: обчислювачки Дороті Воган, Лессі Гантер, Вівіан Адер (позаду Маргарет Райденгоур і Шарлотта Крейдон) Становище темношкірих жінок було ще важчим, їм доводилося працювати стільки ж (або в багатьох випадках більше), скільки їхнім білим колегам та ще й умовах сегрегації. База ВПС Ленглі була укомплектована двома расово відокремленими групами жінок, одна на східній стороні, а інша на західній стороні. Група афроамериканських обчислювачок отримала назву West Area Computers. На відміну від білих жінок, NACA вимагала від афроамериканок повторного проходження курсу коледжу, і багато з них ніколи не отримували підвищення. Керівниками West Area Computers були білі жінки, і тільки 1949 року їх очолила Дороті Воган, яка стала першою афроамериканською адміністратореою і менеджеркою NACA. У роки Другої світової в маєтку Блечлі-Парк розміщувалася Урядова школа кодування і дешифрування в якій працювали понад 10 тисяч осіб, дві третини з них жінки. Алан Тюрінг і Гордон Велчман винайшли обчислювальну електромеханічну машину Bombe, яка використовувалося для аналізу кодів й управлялася операторками-жінками. У розпал Другої Світової, щоб допомогти артилеристам обчислювати траєкторії польоту снарядів, було розроблено перший електронний цифровий обчислювач загального призначення, який можна було перепрограмувати для рішення широкого спектра завдань ENIAC. Хоча його збірка почалася за рік до Дня висадки армії союзників в Нормандії, 6 червня 1944 року, комп'ютер вперше запрацював в листопаді 1945 року. Комп'ютерами тоді називали людей, які займалися обчисленнями, тобто «комп'ютингом». Саме тому ENIAC стали також називати комп'ютером. Шість жінок-обчислювачок долучились до проєкту в якості програмісток для ENIAC, яких називали «ENIAC Girls». Це були Кетлін Макналті Моучлі Антонеллі, Джин Дженнінгс Бартік, Бетті Снайдер Голбертон, Мерлін Вескофф Мельцер, Рут Лихтерман Тейтельбаум і Френсіс Білас Спенс. Спочатку їх робота була засекречена.міні| Кетрін Джонсон працювала в НАСА в 1966 році міні| Маргарет Гамільтон і обчислений нею код програмного забезпечення для Apollo 11 (1969) |альт=|ліворучENIAC Girls розуміли внутрішні схеми комутації і визначали першопричину проблеми, яка могла полягати в окремо взятій вакуумній трубці. У певних моментах знання і навички цих жінок змогли зробити значний вплив на дизайн ENIAC й інших комп'ютерів. Програмістка ENIAC Бетті Снайдер Голбертон згадувала особливо важливий епізод, коли їй вдалося переконати Джона фон Нейманом додати кнопку «stop instruction». Спочатку він поставився до цієї ідеї скептично, але в підсумку визнав необхідність такої функції. Пізніше, Джин Дженнінгс Бартік увійшла до складу групи, яка проапгрейдила ENIAC до рівня «Stored-program computer». Програма зберігалася в електронній пам'яті комп'ютера, а не «в кабелях і перемичках». По завершенню війни вона допомагала розробляти BINAC (перший комерційний цифровий комп'ютер) і UNIVAC I (акронім від ) Геді Ламарр разом з авангардистським композитором Джорджем Антейлом запатентувала технологію розширеного спектру зі стрибкоподібними частотами (FHSS), яка проклала шлях для бездротових телекомунікацій. Вони запропонували використовувати на передавачі випадковий код, який буде змінювати частоту каналу передачі, та синхронізувати такі ж частотні переходи і на приймачі. Така зміна каналів зв'язку убезпечую передачу інформації. До того часу псевдовипадкові коди використовувалися для кодування інформації, переданої незмінними відкритими каналами зв'язку. Секретний ключ став використовуватися для швидкої зміни частот каналів передачі інформації. У серпні 1942 Ламар і Антейл отримали патент під номером 2292387 «Секретна система зв'язку (Secret Communication System)». Патент описує секретні системи зв'язку, що включають передачу фальшивих сигналів на різних частотах. Цей патент став основою для зв'язку з розширеним спектром, що використовується всюди, від мобільних телефонів до Wi-Fi 802.11 і GPS.«Hollywood star whose invention paved the way for Wi-Fi», New Scientist, 8 December 2011. thumb|Копія патенту США на «Секретну комунікаційну систему» 1950-ті роки У 1952 році Ґрейс Гоппер розробила перший в історії компілятор — A-0, а в 1957 році створила перший компілятор для обробки даних за допомогою англійських команд B-0 (FLOW-MATIC), що використовується в основному для обчислень фонду оплати праці. У 1959 році Мері Аллен Вілкс, працюючи в MIT, мала можливість працювати з комп'ютерами, такими як IBM 709 та TX-2 (1959—1963). У той час вона розробляла різні операційні системи для LINC в англійській лабораторії Приладовий комп'ютер, з назвою LAP (операційна система), англійською програмою асамблеї LINC (перший мінікомп'ютер), до моменту еволюції до LAP6.thumb|Мері Аллен Вілкс за комп'ютером LINC у вітальні її будинку (1965 рік)|альт=|ліворуч 1960-ті роки альт=Using an NCR 796—201 cathode-ray terminal, circa 1972|міні| Використання катодного рентгенівського терміналу NCR 796—201, близько 1972 рокуУ 1960 році Маргарет Гамільтон почала працювати над написанням програмного забезпечення системи прогнозування погоди комп'ютерів LGP-30 і PDP-1, які були частиною проєкту MAC під керівництвом видатного математика і метеоролога Едварда Лоренца, який завідував відділом метеорології МТІ. З 1961 по 1963 роки Гамільтон працювала в команді програмістів проєкту SAGE в лабораторії Лінкольна (МТІ), розробляючи програмне забезпечення для першого AN/FSQ-7 комп'ютера в проєкті Whirlwind, головним завданням якого було пророкування і відстеження погодних умов за допомогою симуляцій. Наступним став військовий проєкт SAGE для відстежень переміщення ворожих літаків, щоб передбачити можливу атаку СРСР. Робота в проєкті SAGE дозволила Гамільтон пізніше приєдналася до колективу лабораторії імені Чарльза Старка Дрейпера в МТІ, що працював в космічній програмі Аполлон. Маргарет Гамільтон вдалося очолити групу розробників, які створювали програмне забезпечення для Аполлона й орбітальної станції Skylab. Найбільш значущим внеском цієї групи є програмне забезпечення для бортового комп'ютера. Лабораторія Лінкольна також стала робочім місцем Мері Аллен Вілкс, найбільш відомої як перша людина, у якої вдома з'явився комп'ютер. З 1959 по 1960 рік Вілкс займалася розробкою програмного забезпечення для ранніх комп'ютерів IBM 704 й IBM 709. 1961 року приєдналася до команди розробників першого мікрокомп'ютера і прабатька домашніх персональних комп'ютерів LINC (Laboratory Instrument Computer) під керівництвом Веслі Кларка. Вілкс писала різні ОС для LINC, першою з яких була LAP (Line Assembly Program). За допомогою LAP користувач міг самостійно обирати писати йому програми мовою асемблер чи машинним кодом. LAP розроблявся і вдосконалювався аж до версії LAP6, для якої Мері Вілкс написала керівництво користувача.альт=Shelley Lake working on computer graphics at Digital Productions, 1983.|міні| Шеллі Лейк працює над комп'ютерною графікою в Digital Productions, 1983 ліворуч|міні| Хайме Леві, популяризаторка e-Zine у 1990-х Наприкінці 1950-х у Массачусетському Технологічному Інституті для дослідження проблем штучного інтелекту було розроблено мову програмування загального призначення з підтримкою парадигм функціонального та процедурного програмування Лісп (Lisp). Піонерка у галузі штучного інтелекту, інформатики та навчальних обчислень Синтія Соломон досліджувала можливості адаптації цієї мови для дітей. В 1967 році Сеймур Пейперт, Уоллі Фюрцейгем та Синтія Соломон презентували мову програмування високого рівня Лого (LOGO), розроблену в освітніх цілях для навчання дітей дошкільного і молодшого шкільного віку основним концепціям програмування. Мова Лого є адаптацією мови Лісп, і подекуди її називають «Лісп без дужок». 1970-ті У листопаді 1971 року Ерна Шнайдер Гувер революціонізувала системи комунікацій і запатентувала свій винахід, названий «Система моніторингу зі зворотним зв'язком для обробки даних за допомогою встановленої програми» (Feedback Control Monitor for Program Stored Data Processing System); її патент за номером 3,623,007, став одним з перших, що зареєстрував право власності на програмне забезпечення. Винахід, заявку на який Гувер подала в 1967 році, а сам патент отримала через чотири роки, допомагає комп'ютеру автоматично регулювати швидкість прийому виклику, а це допомагає уникнути перевантаження ліній.See Patent #3623007 November 23, 1971 Завдяки винаходу Гувер стала першою жінкою, що зайняла посаду керівника технічного відділу в Лабораторіях Белла. У 1987 році вона очолила відділ операційної підтримки. І сьогодні, у двадцять першому столітті, принципи її винаходу використовуються в роботі телекомунікаційного обладнання, зокрема в роботі колл-центрів по всьому світу. В Лабораторіях Белла, де Ерна Гувер пропрацювала більше 32 років, її називають новаторкою, яка відкрила жінкам дорогу в сферу комп'ютерних технологій.альт=Marissa Mayer|міні| Марісса Маєр, колишня віцепрезидентка продуктів пошуку Google, колишня президентка та генеральна директорка Yahoo! Карен Спарк Джонс розробляла технології пошуку і видачі інформації (information retrieval, IR), які дозволили користувачам працювати з комп'ютерами, використовуючи звичайні слова замість рівнянь і кодів. Цей прорив мав критичне значення для подальшого розвитку пошукових машин. 1980-ті 1981 року американська програмістка Дона Бейлі разом з розробили аркадну відеогру Centipede компанії Atari, Inc.. У 1982 році Керол Шоу приєднується до Activision, де вона запрограмувала свою найкращу гру, під назвою River Raid, яку в деяких європейських країнах (наприклад, Німеччині) оцінили як жорстоку і заборонену гру для неповнолітніх, що робить цю гру для гральної консолі першою забороненою через насильство. Роберта Вільямс була піонеркою графічних пригодницьких ігор для персональних комп'ютерів, особливо саги King's Quest.альт=Shafi Goldwasser|міні| Шафі Голдвассер отримала премію Тюрінга 2012 року за спільну роботу в галузі криптографії |ліворуч У 1984 році Сьюзен Каре створила піктограми та багато елементів інтерфейсу для оригінального Apple Macintosh у 1980-х, працювала креативним директором NeXT. 1990-ті У 1993 році Шафі Голдвассер стала лауреаткою премії Геделя за статтю «Складність знань інтерактивних систем доказування». Цього року Барбара Лісков разом з Жаннет Вінг розробляє Принцип заміщення Ліскова. У 1996 році Сяоюань Ту стала першою жінкою, що отримала нагороду докторської дисертації АСМ. У 1997 році Аніта Борг заснувала Інститут жінок та технологій (зараз Інститут жінок та технологій Аніти Борг). Дві основні цілі заснування організації полягали в збільшенні представництва жінок у технічній галузі та забезпеченні можливості створення більшої кількості технологій жінками. XXI століття 2000-ті 2010-і Гендерна нерівність в ІТ Одна з найбільших проблем, з якою стикаються жінки в сучасних ІТ, полягає в тому, що вони часто опиняються в середовищі в значній мірі сексистському, тому жінки не залишаються в області програмування і технологій. У 2013 році в звіті Національного громадського радіо йшлося, що лише 20 % програмістів в США — жінки. У 2017 році Джеймс Дамор був звільнений з Google після того, як заявив, що існує біологічна причина невеликої кількості жінок-комп'ютерниць. Володарки премії Тьюрінга 2006 — Френсіс «Фран» Елізабет Аллен 2008 — Барбара Лісков 2012 — Шафі Голдвассер Володарки премії Карен Спарк Джонс 2009 — Мірелла Лапата 2012 — Діана Келлі 2015 — Еміне Йілмаз 2016 — Хайме Тіван Див. також Жінки у галузях STEM Сексизм в освіті Посилання Категорія:Історія інформатики Категорія:Жінки і наука Категорія:Жінки в суспільстві ♀"}
{"category": "Програмування", "title": "Абстрагування (програмування)", "abstract": "В програмуванні, абстрагува́ння — це виділення лише важливих характеристик які потрібні для виконання завдання і відкидання інших.\nДля різних цілей в одного і того ж об'єкта будуть важливі різні параметри.\nНаприклад, яблуко. Для користувача, який має його з'їсти важливо сорт, соковитість, достиглість. Для користувача який має його кинути — вага і форма.\nЯкщо абстрагують дії то це абстрагування керування\nЯкщо абстрагують структур даних — це абстрагування даних.\nНаприклад, абстрагування керування в структурному програмуванні полягає у використанні підпрограм та визначених керівних конструкцій. Абстрагування даних дозволяє обробляти одиниці даних у змістовний спосіб. Наприклад, абстрагування є основною мотивацією створення типів даних.\nАбстрагування є однією з парадигм Об'єктно-орієнтованого програмування.", "content": "В програмуванні, абстрагува́ння — це виділення лише важливих характеристик які потрібні для виконання завдання і відкидання інших. Для різних цілей в одного і того ж об'єкта будуть важливі різні параметри. Наприклад, яблуко. Для користувача, який має його з'їсти важливо сорт, соковитість, достиглість. Для користувача який має його кинути — вага і форма. Якщо абстрагують дії то це абстрагування керування Якщо абстрагують структур даних — це абстрагування даних. Наприклад, абстрагування керування в структурному програмуванні полягає у використанні підпрограм та визначених керівних конструкцій. Абстрагування даних дозволяє обробляти одиниці даних у змістовний спосіб. Наприклад, абстрагування є основною мотивацією створення типів даних. Абстрагування є однією з парадигм Об'єктно-орієнтованого програмування. Див. також Алгоритм Абстрактний тип даних Примітки Література Alan Dennis, David Paul Tegarden, Barbara Haley Wixom. Systems Analysis and Design: An Object-Oriented Approach with UML– Wiley, 2015. — 544 p. Буч Г. Объектно-ориентированный анализ и проектирование с примерами приложений, 3-е изд. — М.: ООО «Вильямс», 2008. - 720 с. Категорія:Програмування Категорія:Об'єктно-орієнтоване програмування"}
{"category": "Програмування", "title": "АВЛ-дерево", "abstract": "АВЛ-дерево — збалансоване по висоті двійкове дерево пошуку: для кожної його вершини висота її двох піддерев відрізняється не більше ніж на 1.\nАВЛ — абревіатура, утворена першими літерами творців (радянських учених) Адельсон-Вельського Георгія Максимовича і Ландіса Євгена Михайловича.", "content": "АВЛ-дерево — збалансоване по висоті двійкове дерево пошуку: для кожної його вершини висота її двох піддерев відрізняється не більше ніж на 1. АВЛ — абревіатура, утворена першими літерами творців (радянських учених) Адельсон-Вельського Георгія Максимовича і Ландіса Євгена Михайловича. Загальні властивості У АВЛ-дереві висоти є не менше вузлів, де — число Фібоначчі. Оскільки , де — золотий перетин, то маємо оцінку на висоту АВЛ-дерева , де — число вузлів. Слід пам'ятати, що — мажоранта, і її можна використовувати лише для оцінки (Наприклад, якщо в дереві тільки два вузли, значить в дереві два рівні, хоча ). Для точної оцінки глибини дерева слід використовувати призначену для користувача підпрограму. function TreeDepth(Tree : TAVLTree) : byte; begin if Tree <> nil then result := 1 + Max(TreeDepth(Tree^.left),TreeDepth(Tree^.right)) else result := 0; end; Тип дерева можна описати так TKey = LongInt; TInfo = LongInt; TBalance = -2..2; // діапазон в районі від -1 до 1, але включимо для простоти порушення -2 і 2 PAVLNode = ^ TAVLNode; TAVLNode = record case integer of 0:(left, right : PAVLNode; key : TKey; info : TInfo; { Поле, що визначає збалансованість вершини } balance : TBalance;); 1:(childs:array[boolean] of PAVLNode); // уявлення гілок дерева у вигляді масиву для спрощення переходів end; TAVLTree = PAVLNode; AVL-умови можна перевірити так function TestAVLTree(V:PAVLNode):integer; //повертає висоту дерева var a,b:integer; begin Result:=0; if V=nil then exit; a:=TestAVLTree(V.Left); b:=TestAVLTree(V.Right); if ((a-b)<>V.Balance)or(abs(a-b)>=2) then begin raise Exception.CreateFmt('%d - %d balancefactor %d',[a,b,V.Balance]); end; Result:=1+max(a,b); end; Операції з АВЛ-деревами Балансування Щодо АВЛ-дерева балансуванням вершини називається операція, яка у разі різниці висот лівого і правого піддерев = 2, змінює зв'язку предок-нащадок в піддереві даної вершини так, що різниця стає <= 1, інакше нічого не змінює. Зазначений результат виходить обертаннями піддерева даної вершини. Використовуються 4 типи обертань: 1.Мале ліве обертання Дане обертання використовується тоді, коли (висота b-піддерева - висота L) = 2 і висота С <= висота R. 2.Велике ліве обертання Дане обертання використовується тоді, коли (висота b-піддерева - висота L) = 2 і висота C-піддерева > висота R. //Функція для усунення правого порушення за допомогою вищеописаних поворотів, //повертає True якщо висота дерева зменшилася, False - якщо залишилася тією ж function AVL_FixWithRotateLeft(var N:PAVLNode):boolean; var R,RL,RLR,RLL:PAVLNode; begin R:=N.Right; RL:=R.Left; Result:=true; case R.Balance of -1 :begin N.Balance:= 0; // h(RL)=H-3 h(L)=H-3 => h(N) =H-2 R.Balance:= 0; // h(RR)=H-2 => h(R)= H-1 N.Right:=RL; R.Left:=N; N:=R; end; 0 :begin N.Balance:= -1; // h(RL)=H-2 h(L)=H-3 => h(N) =H-1 R.Balance:= 1; // h(RR)=H-2 => h(L)= H N.Right:=RL; R.Left:=N; N:=R; Result:=false; end; 1:begin RLR:=RL.Right; RLL:=RL.Left; R.Left:=RLR; R.Balance:=min(-RL.Balance,0); //1 =>-1, 0 =>0, -1 =>0 N.Right:=RLL; N.Balance:=max(-RL.Balance,0); //1 => 0, 0 =>0, -1 => 1 RL.Right:=R; RL.Left:=N; RL.Balance:=0; N:=RL; end; end; end; 3.Мале праве обертання Дане обертання використовується тоді, коли (висота b-піддерева — висота R) = 2 і висота С <= висота L. 4.Велике праве обертання Дане обертання використовується тоді, коли (висота b-піддерева — висота R) = 2 і висота C -піддерева> висота L. // Функція для усунення лівого порушення за допомогою вищеописаних поворотів, // повертає True якщо висота дерева зменшилася, False - якщо залишилася тією ж function AVL_FixWithRotateRight(var N:PAVLNode):boolean; var L,LR,LRL,LRR:PAVLNode; begin L:=N.Left; LR:=L.Right; Result:=true; case L.Balance of 1:begin N.Balance:= 0; // h(LR)=H-3 h(R)=H-3 => h(N) =H-2 L.Balance:= 0; // h(LL)=H-2 => h(L)= H-1 N.Left:=LR; L.Right:=N; N:=L; end; 0 :begin N.Balance:=1; // h(LR)=H-2 h(R)=H-3 => h(N) =H-1 L.Balance:= -1; // h(LL)=H-2 => h(L)= H N.Left:=LR; L.Right:=N; N:=L; Result:=false; end; -1 :begin LRL:=LR.Left; LRR:=LR.Right; L.Right:=LRL; L.Balance:=max(-LR.Balance,0); //1 =>0, 0 =>0, -1 =>1 N.Left:=LRR; N.Balance:=min(-LR.Balance,0); //1 => -1, 0 =>0, -1 => 0 LR.Left:=L; LR.Right:=N; LR.Balance:=0; N:=LR; end; end; end; У кожному випадку досить просто довести те, що операція приводить до потрібного результату і що повна висота зменшується не більше ніж на 1 і не може збільшитися. Також можна помітити, що велике обертання це комбінація правого і лівого малого обертання. Через умови балансування висота дерева О (log (N)), де N-кількість вершин, тому додавання елемента вимагає O (log (N)) операцій. Алгоритм додавання вершини Показник збалансованості в подальшому будемо інтерпретувати як різниця між висотою лівого і правого піддерева, а алгоритм буде заснований на типі TAVLTree, описаному вище. Безпосередньо при вставці (листу) присвоюється нульовий баланс. Процес включення вершини складається з трьох частин: Прохода по шляху пошуку, поки не переконаємося, що ключа в дереві немає. Включення нової вершини у дерево і визначення результуючих показників балансування. «Відступи» назад по шляху пошуку і перевірки в кожній вершині показника збалансованості. Якщо необхідно — балансування. Будемо повертати як результат функції, зменшилася висота дерева чи ні. Припустимо, що процес з лівої гілки повертається до батька (рекурсія йде назад), тоді можливі три випадки: { hl — висота лівого піддерева, hr — висота правого піддерева } Включення вершини в ліве піддерево призведе до hl < hr: вирівняється hl = hr. Нічого робити не потрібно. hl = hr: тепер ліве піддерево буде більше на одиницю, але балансування поки не потрібно. hl > hr: тепер hl — hr = 2, — вимагається балансування. У третій ситуації потрібно визначити балансування лівого піддерева. Якщо ліве піддерево цієї вершини (Tree^.Left^.Left) вище правого (Tree^.Left^.Right), то потрібно велике праве обертання, інакше вистачить малого правого. Аналогічні (симетричні) міркування можна привести і для включення в праве піддерево. Допоміжна функція порівнює два ключі function KeyCompare(const V1,V2:TKey):integer; begin if V2>V1 then begin Result:=-1; end else if V2=V1 then begin Result:=0; end else Result:=1; end; Рекурсивна процедура вставки: function AVL_InsertNode(Var Tree : TAVLTree; const aKey : TKey; const ainfo : TInfo): Boolean; Var c:integer; begin if Tree = nil then begin New(Tree); Result := true; with Tree^ do begin key := akey; info := ainfo; left := nil; right := nil; balance := 0; end; end else begin c:= KeyCompare(aKey,Tree^.key); if c=0 then begin Tree^.info:=ainfo; Result := false; end else begin Result:=AVL_InsertNode(Tree^.childs[c>0],akey,ainfo); if Result then begin if c>0 then Tree^.balance:= Tree^.balance-1 else Tree^.balance:= Tree^.balance+1; case Tree^.balance of 2: Result:=not AVL_FixWithRotateRight(Tree); -2: Result:=not AVL_FixWithRotateLeft(Tree); 0: Result:=false; end end; end; end; end; Алгоритм видалення вершини Для простоти опишемо рекурсивний алгоритм видалення. Якщо вершина — листок, то видалимо її і викличемо балансування всіх її предків в порядку від батька до кореня. Інакше знайдемо саму близьку за значенням вершину в піддереві найбільшої висоти (правому або лівому) і перемістимо її на місце видаляється вершини, при цьому викликавши процедуру її видалення. Спрощений варіант видалення можна описати таким чином // Функція дуже далека від оптимальної, // Порівняння відбувається навіть після знаходження видаляється ключа // Передаються відразу всі параметри, деякі з які можна не використовувати, // Розбивши на 3 процедури з більш спрощеною функціональністю: // 1.рух тільки вліво // function AVL_DropNodeLeft(Var Tree : TAVLTree; DropedNode:TAVLTree): Boolean; // 2.рух тільки вправо // function AVL_DropNodeRight(Var Tree : TAVLTree; DropedNode:TAVLTree): Boolean; // 3.пошук // function AVL_DropNode(Var Tree : TAVLTree; const aKey : TKey): Boolean; function AVL_DropNode(Var Tree : TAVLTree; const aKey : TKey;DropedNode:TAVLTree=nil): Boolean; var c:integer; begin if Tree = nil then begin Result := false; exit; end; c:= KeyCompare(aKey,Tree^.key); if c=0 then begin DropedNode:=Tree; c:=-DropedNode.balance;//підемо в більш високу або ліву гілку дерева якщо їх висоти рівні end; if (Tree^.childs[c>0]=nil)and(DropedNode<>nil) then begin DropedNode^.Key:=Tree^.Key; DropedNode^.info:=Tree^.info; DropedNode:=Tree; //поставимо замість поточного лист з протилежного напрямку Tree:=Tree^.childs[c<=0]; Dispose(DropedNode); Result:=true; exit; end; Result:=AVL_DropNode(Tree^.childs[c>0],aKey,DropedNode); if Result then begin if c>0 then Tree^.balance:= Tree^.balance+1 else Tree^.balance:= Tree^.balance-1; case Tree^.balance of -2: Result:=AVL_FixWithRotateLeft(Tree); -1,1: Result:=false; 2: Result:=AVL_FixWithRotateRight(Tree); end; end; end; Доведемо, що даний алгоритм зберігає балансування. Для цього доведемо по індукції по висоті дерева, що після видалення деякої вершини з дерева і наступної балансування висота дерева зменшується не більше, ніж на 1. База індукції: Для листа очевидно вірно. Крок індукції: Або умова балансування в корені (після видалення корінь може зміниться) не порушилося, тоді висота даного дерева не змінилася, або зменшилася суворо менше з піддерев => висота до балансування не змінилася => після зменшиться не більше ніж на 1. Очевидно, в результаті вказаних дій процедура видалення викликається не більше 3 разів, так як у вершини, що видаляється по 2-му викликом, немає одного з піддерев. Але пошук найближчого щоразу вимагає O (N) операцій, звідси видно очевидна оптимізація: пошук найближчої вершини проводиться по краю піддерева. Звідси кількість дій O (log (N)). Нерекурсивна вставка в АВЛ-дерево зверху-вниз Нерекурсивний алгоритм складніший ніж рекурсивна реалізація. Знаходиться місце вставки і вершина висота якої не зміниться при вставці (це вершина у якої висота лівого піддерева не дорівнює висоті правого, будемо називати її PrimeNode) Виконується спуск від PrimeNode до місця вставки зі зміною балансів Виконується ребалансування PrimeNode при наявності переповнення type PAVLTree=^TAVLTree; //додатковий тип для вказівки на місце де зберігається покажчик на листок // функція повертає True якщо було додавання нового листка, False - відбулася заміна значення ключа function AVL_InsertNode2(var Root:TAVLTree;const aKey:TKey;const Value:TInfo):boolean; var PrimeNode,p,q:PAVLTree; c:integer; begin q:=@Root; PrimeNode:=q; //1-ша частина алгоритму if q^<>nil then begin repeat c:=KeyCompare(aKey,q^.Key); if c=0 then begin q^.info:=Value; Result:=false; exit; end; if (q^.Balance<>0) then begin PrimeNode:=q; end; q:=@q^.Childs[c>0]; until q^=nil; end; New(q^); with q^^ do begin key := akey; info := Value; left := nil; right := nil; balance := 0; end; if PrimeNode<>q then begin //2-га частина алгоритму p:=PrimeNode; repeat c:=KeyCompare(aKey,p^.Key); if c>0 then begin p^.Balance:=p^.Balance-1; p:=@p^.Right; end else begin p^.Balance:=p^.Balance+1; p:=@p^.Left; end; until p=q; //3-тя частина алгоритму case PrimeNode^.Balance of 2: AVL_FixWithRotateRight(PrimeNode^); -2: AVL_FixWithRotateLeft(PrimeNode^); end; end; Result:=true; end; Нерекурсивне видалення з АВЛ-дерева зверху-вниз Для реалізації видалення будемо виходити з того ж принципу що і при вставці, будемо шукати вершину, видалення з якої не призведе до зміни її висоти, існують усього два таких варіанти Найпростіший, коли висота лівого піддерева дорівнює висоті правого піддерева (виключаючи випадок коли у листка немає піддерев) Коли висота дерева у напрямку руху менше протилежної («брат» напряму) і баланс «брата» дорівнює 0 (розбір цього варіанту досить складний — так що поки без доведення) function AVL_DropNode2(var Root:PAVLNode;const Key:TKey):boolean; var PrimeNode,p,q,b:PAVLTree; c:integer; last:boolean; DropedNode:PAVLNode; begin p:=nil; q:=@Root; PrimeNode:=q; last:=false; DropedNode:=nil; while q^<>nil do begin if (p<>nil) then begin if (q^^.Balance=0)and(q^^.Left<>nil) then begin PrimeNode:=q; end else if (last and(p^^.Balance=1))or((not last) and(p^^.Balance=-1)) then begin b:=@p^^.Childs[not last]; if b^.Balance=0 then begin PrimeNode:=p; end; end; end; c:=KeyCompare(Key,q^^.Key); last:=c>0; p:=q; q:=@q^^.Childs[last]; if c=0 then begin DropedNode:=p^; end; end; if DropedNode=nil then begin Result:=false; exit; end; Result:=true; while PrimeNode<>p do begin c:=KeyCompare(Key,PrimeNode^.Key); if c>0 then begin PrimeNode^.Balance:=PrimeNode^.Balance+1; if PrimeNode^.Balance=2 then begin AVL_FixWithRotateRight(PrimeNode^); PrimeNode:=@PrimeNode^.Right; // пропускаємо з обробки, там наша поточну вершина тепер end; PrimeNode:=@PrimeNode^.Right; end else begin PrimeNode^.Balance:=PrimeNode^.Balance-1; if PrimeNode^.Balance=-2 then begin AVL_FixWithRotateLeft(PrimeNode^); PrimeNode:=@PrimeNode^.Left; // пропускаємо з обробки, там наша поточну вершина тепер end; PrimeNode:=@PrimeNode^.Left; end; end; DropedNode^.Key:=p^^.Key; DropedNode^.info:=p^^.info; DropedNode:=p^; //поставимо замість поточного лист з протилежного напрямку p^:=p^^.childs[(p^^.Left=nil)]; Dispose(DropedNode); end; Сам алгоритм без всіх оптимізацій для спрощення його розуміння. На відміну від рекурсивного алгоритму при знаходженні удаляемой вершини вона буде замінена значенням з лівої подветві, даний алгоритм можна оптимізувати так само як і для рекурсивної версії за рахунок того що після знаходження удаляемой вершини напрямок руху нам відомо Шукаємо видаляється елемент і попутно знаходимо нашу чудову вершину Виконуємо зміна балансів, в разі необхідності робимо ребалансировки Видаляємо наш елемент (в дійсності не видаляємо, а заміняємо його ключ і значення, врахування перестановок вершин буде трохи складніше) Розстановка балансів при видаленні Як вже говорилося, якщо видаляється вершина — листок, то вона видаляється, і зворотний обхід дерева походить від батька віддаленого листка. Якщо не лист — їй знаходиться «заміна», і зворотний обхід дерева походить від батька «заміни». Безпосередньо після видалення елемента — «заміна» отримує баланс видаляється вузла. При зворотному обході: якщо при переході до батька прийшли зліва — баланс збільшується на 1, якщо ж прийшли праворуч — зменшується на 1. Це робиться до тих пір, поки при зміні балансу він не стане рівним −1 або 1 (зверніть увагу на відмінність з вставкою елемента!): В даному випадку така зміна балансу буде гласить про незмінною дельта-висоті піддерев. Повороти відбуваються за тими ж правилами, що і при вставці. Розстановка балансів при одинарному повороті Позначимо: «Current» — вузол, баланс якого дорівнює −2 або 2: тобто той, який потрібно повернути (на схемі — елемент a) «Pivot» — вісь обертання. +2: Лівий син Current'а, −2: правий син Current'а (на схемі — елемент b) Якщо поворот здійснюється при вставці елементу, то баланс Pivot'а дорівнює або 1, або −1. У такому випадку після повороту баланси обох встановлюються рівними 0. При видаленні все інакше: баланс Pivot'а може стати рівним 0 (в цьому легко переконатися). Наведемо зведену таблицю залежності фінальних балансів від напрямку повороту і вихідного балансу вузла Pivot: Напрям повороту Old Pivot.Balance New Current.Balance New Pivot.Balance Лівий або Правий −1 или +1 0 0 Правий 0 −1 +1 Лівий 0 +1 −1 Розстановка балансів при подвійному повороті Pivot і Current — ті ж самі, але додається третій учасник повороту. Позначимо його за «Bottom»: це (при подвійному правому повороті) лівий син Pivot'а, а при подвійному лівому — правий син Pivot'а. При даному повороті — Bottom в результаті завжди набуває баланс 0, але від його вихідного балансу залежить розстановка балансів для Pivot і Current. Наведемо зведену таблицю залежності фінальних балансів від напрямку повороту і вихідного балансу вузла Bottom: Напрям Old Bottom.Balance New Current.Balance New Pivot.Balance Лівий або Правий 0 0 0 Правий +1 0 −1 Правий −1 +1 0 Лівий +1 −1 0 Лівий −1 0 +1 Оцінка ефективності Г. М. Адельсон-Вельський і Е. М. Ландіс довели теорему, згідно з якою висота АВЛ-дерева з N внутрішніми вершинами укладена між log2 (N +1) і 1.4404 * log2 (N +2) −0.328, тобто висота АВЛ -дерева ніколи не перевищить висоту ідеально збалансованого дерева більш, ніж на 45%. Для великих N має місце оцінка 1.04 * log2 (N). Таким чином, виконання основних операцій 1 — 3 вимагає порядку log 2 (N) порівнянь. Експериментально з'ясовано, що одна балансування припадає на кожні два включення і на кожні п'ять видалень. Література Г. М. Адельсон-Вельский, Е. М. Ландис. Один алгоритм организации информации // Доклады АН СССР. 1962. Т. 146, № 2. C. 263–266. GNU libavl 2012 Ben Pfaff. Див. також Червоно-чорне дерево Категорія:Алгоритми на графах Категорія:Дерева пошуку Категорія:Програмування Категорія:Статті з прикладами коду мовою Pascal"}
{"category": "Програмування", "title": "Автоматизація процесу програмування", "abstract": "Автоматизація процесу програмування — це засіб автоматизації при створенні імітаційних програмних моделей, що дають змогу не тільки вилучити проміжну ланку між аналітиком і людиною, що приймає рішення, а й під час створення моделі використовувати терміни предметної галузі, в якій працює аналітик.", "content": "Автоматизація процесу програмування — це засіб автоматизації при створенні імітаційних програмних моделей, що дають змогу не тільки вилучити проміжну ланку між аналітиком і людиною, що приймає рішення, а й під час створення моделі використовувати терміни предметної галузі, в якій працює аналітик. Комп'ютерна інженерія Створення імітаційних моделей – складне завдання. Недарма у своїй праці Шенон ставить програмістів, які створюють програмні реалізації імітаційних моделей, вище, ніж системних програмістів. Так було названо нову наукову дисципліну, об'єктом дослідження якої є великі комп'ютерні системи і проблеми, що виникають під час їх створення. У наш час продовжують розвиватись різні методи розробки складного програмного забезпечення. У рамках комп'ютерної інженерії робиться спроба визначити абстрактну систему понять цього процесу. Кожний новий підхід передбачає свою систему, яка схожа на інші, але має деякі нюанси. У цьому розділі розглядаються відомі об'єктно-орієнтовані методи автоматизації створення програмних систем і розкриваються поняття, які використовуються під час розроблення засобів автоматизації проектування імітаційних моделей. Застосовувана в моделюванні мова SDL (Specification and Description Language) – це мова специфікацій та опису. Під специфікацією розуміють точне формальне визначення системи або її частини, під описом – неформальну специфікацію, яка ілюструє той або інший аспект системи. Описи використовують на початкових етапах розробки системи або для документування системи. На етапах детального проектування використовують специфікації, за якими передбачається виконання автоматичного генерування програмного коду. Той факт, що для різних етапів розробки системи пропонується одна мова, є суттєвою перевагою SDL, оскільки в такому випадку зникає проблема семантичних розривів. Мова SDL Мову SDL призначено для розробки подійно-орієнтованих розподілених систем. Ця мова почала розвиватись за сприяння міжнародного комітету ITU ще в 1976 році і є однією з найдавніших розробок в комп'ютерній інженерії. Існує два варіанти цієї мови – текстовий (SDL/PR) та графічний (SDL/GR), синтаксис яких здебільшого збігається. Викладення основ цієї мови можна знайти в літературі. Крім того, є російський варіант стислого викладення мов SDL і MSC (Message Sequence Chart). Більше десяти компаній в Європі (Telelogic, Verigol та ін.) розробляють CASE-засоби (Computer-Aided Software Engineering – автоматизоване проектування і створення програм) на основі SDL. Ці продукти використовуються багатьма великими європейськими компаніями – виробниками телекомунікаційних систем. Крім мови SDL комітетом ITU запропоновано цілу низку стандартів на засоби розробки телекомунікаційних систем. Серед них мови високого рівня CHILL, MSC (графічна мова сценаріїв). У Європі щороку проходить велика кількість конференцій, на яких обговорюються різні аспекти цих стандартів. Мова SDL як засіб аналізу систем широко використовується в європейських телекомунікаційних стандартах. її основними складовими є структурна модель і розширений скінченний автомат. Вони орієнтовані на здійснення специфікації подійно-орієнтованих систем, хоча мають ширше використання. Блочний аналіз є основою структурної декомпозиції системи за допомогою мови SDL. Він передбачає зображення системи у вигляді вкладених одна в одну частин (блоків), які не містять виконуваного коду, а містять лише описи. Блоки можуть відповідати великим модулям системи або підзавданням проекту. Виконуваний код у вигляді розширеного скінченного автомату міститься лише в листках дерева цієї декомпозиції, тобто процесах, які, подібно до блоків, можна поставити у відповідність об'єктам. Тому мову SDL було успішно розширено до об'єктно-орієнтованої мови. Існують графічні нотації, що призначені для використання на початкових етапах розробки системи, а також процес розробки програмного забезпечення на основі мови SDL. Але на сьогоднішній день ці нотації замінено мовою UML, яка потіснила також SDL. Визнано, що SDL є мовою програмування, подібною до Java, C++ та ін. Отже, виникає проблема співіснування UML-описів і SDL-специфікацій. Метод OOSE Об'єктно-орієнтований програмний інжиніринг – OOSE (Object-Oriented Software Engineering) має основне завдання – наблизити комп'ютерну інженерію до типового промислового процесу, яким є, наприклад, будівництво. Основний принцип підходу – об'єктна орієнтованість, як аналізу, проектування, програмування, так і опису процесу розробки програмного забезпечення загалом. Підхід призначено, у першу чергу, для розроблення великих систем. На основі OOSE створено метод Objectory, реалізований у продукті компанії Objectory AB. У 1995 році, після злиття цієї компанії з корпорацією Rational Software Corp., цей метод використовувався під час створення раціонального об'єднаного підходу – RUP (Rational Unified Approach). В OOSE пропонується компактний опис структури комп'ютерної інженерії, основою якої є поняття архітектури. Це поняття включає основні концепції і технології, визначені як об'єктно-орієнтовані, певний набір напівформальних моделей з графічними нотаціями, які надаються для опису розроблюваної системи. Метод OOSE – лінійна послідовність кроків, тобто процедура для створення ідеальної системи «з нуля». За допомогою цього методу можна визначити, як застосовувати архітектуру для розроблення системи. Процес розробки є розширенням методу. На відміну від методу він, по-перше, орієнтований на ітеративне розроблення програмного забезпечення (сам метод лінійний) і по-друге – адаптований до практичного застосування (метод – це ідеальна послідовність кроків).І нарешті, інструментальні засоби – це реалізація архітектури, методу та процесу в конкретному програмному продукті – CASE-засобі, за допомогою якого відбувається розроблення системи. Аналіз і проектування в OOSE засновані на методі випадків використання (use case approach), за допомогою яких, через побудовані для них сценарії, виділяються об'єкти. Пропонується кілька об'єктних моделей для різних стадій розробки системи і, як у SDL, блочний аналіз. Метод Буча Праця Буча є класичною монографією, де висвітлюється об'єктно-орієнтований підхід до аналізу та проектування програмного забезпечення. За допомогою методу описуються об'єктна модель і візуальні засоби, а також сам процес розробки програмного забезпечення з визначенням цілей, видів діяльності та передбачуваних результатів. Крім того, розглядаються організаційні питання створення програмного забезпечення та вплив на них застосування об'єктно-орієнтованого підходу. Метод засновано на єдиній моделі класів. її пропонується використовувати на різних етапах розробки отримання єдиної специфікації системи, яка змінюється від однієї фази розробки до іншої. Як основні поняття у праці використовуються методологія і метод. «Методологія – це набір методів, які застосовуються протягом всього життєвого циклу створення програмного забезпечення, поєднаних єдиною філософською концепцією». Такою концепцією в Буча є об'єктно-орієнтований погляд на світ. «Метод – це чітко визначений процес створення набору моделей за допомогою специфікованих нотацій; ці моделі описують різні аспекти програмного забезпечення». Буч називає свій підхід методом і ділить його на три частини – нотації, процес, прагматика. Основа методу – можливість розглядати розроблювану систему з різних поглядів. Результат такого розгляду називається моделлю системи. Буч вирізняє такі типи моделей: логічну, фізичну, статичну та динамічну. Під моделлю розуміється як спосіб бачення, так і його результати. У першому випадку використовується також термін view, у перекладі з англійської – вид. Нотація – це графічна мова для опису моделей. Ця частина методу є формальною. Процес – це опис цілей, видів діяльності та результатів для різних фаз об'єктно-орієнтованого аналізу та проектування. Процес не формалізується як набір процедур, а поділяється на частини, для яких описуються інтерфейсні характеристики. Буч підкреслює, що його опис процесу не є набором готових рецептів. Прагматика в контексті методу Буча – це та специфіка об'єктно-орієнтованого підходу, яка виявляється в організаційних питаннях створення програмного забезпечення: керування проектом, персоналом, ризиками, версіями системи, конкретні програмні засоби підтримки розробки програмного забезпечення та ін. Важливість цих питань зумовлена тим, що проектування та аналіз не є строгою та формально визначеною наукою, для розв'язання значної частини проблем не вдається знайти відповідних формалізацій, і залишається лише обговорити їх на неформальному рівні. Таким чином, ця частина методу є найбільш неформальною. У класичних працях, присвячених проблемі створення великих програмних систем на основі об'єктно-орієнтованого підходу, автори намагалися охопити всі боки життєвого циклу розробки програмного забезпечення, не залишаючи без уваги жодного організаційного питання. Але найбільше практичне втілення мали ті частини цих праць, в яких йдеться про візуальне моделювання як один з основних засобів аналізу та проектування великих програмних систем. Було створено велику кількість спеціалізованих програмних продуктів під загальною назвою CASE- засоби, які реалізують графічні нотації різних об'єктно-орієнтованих методологій. Нарешті, хаосу в цій галузі позбулися завдяки прийняттю стандарту щодо об'єктно-орієнтованих засобів візуальної специфікації – мови UML (Unified Modeling Language). Якщо слідувати структурі методу Буча, то можна сказати, що стандартизовано лише нотацію, а процес і прагматика в UML не увійшли, тобто було стандартизовано мову, а не способи її застосування. Мова UML Мова UML розвивається з 1994 року і є результатом злиття трьох найбільш відомих об'єктно-орієнтованих підходів: методу Буча, ОМТ і OOSE. У 1997 році мову UML було прийнято комітетом OMG як стандарт. Вона практично замінила собою всі інші об'єктно-орієнтовані підходи. Мова UML є грандіозною спробою розробити на основі об'єктно-орієнтованого підходу універсальну мову графічного моделювання для аналізу і проектування складних комп'ютерних систем. Вона об'єднує велику кількість різних графічних нотацій з метою впорядкування хаотичного набору графічних засобів, які використовуються під час створення програмного забезпечення. Стандартизація тут суттєво підвищує рівень розуміння між різними фахівцями, які розроблюють складну систему. Крім того, стандарт полегшує процес перенесення специфікацій, виконаних у різних CASE-пакетах. В основному документі щодо мови UML описано версію UML 1.1 1997 року. Ця праця ґрунтується на настанові з UML. Нижче коротко розглядаються поняття UML, на яких засновано засоби структурної декомпозиції проекту та розроблюваної системи. Пакет – це простір імен проекту, який складається з множини сутностей, виражених за допомогою понять і діаграм UML. Пакети можуть включати в себе інші пакети.Модель – це тип пакету, який є певним закінченим образом системи, що описує її з певного погляду. Наприклад, для розроблюваної системи можна побудувати модель випадків використання, яка буде визначати функціональні вимоги до неї. Погляд – це певний спосіб бачення системи, з огляду на який будується певна модель системи. Погляд включає в себе набір графічних нотацій та їх семантику. Виділяються такі погляди на систему: статичний, випадків використання, взаємодії, скінченно-автоматний, активностей, фізичний, керований. Підсистема - це вид пакету, який описує певну частину системи, виділену в єдине ціле за реалізаційними або функціональними міркуваннями. Структура підсистеми ділиться на дві частини - декларативну та реалізаційну. Перша визначає зовнішню поведінку підсистеми і може включати в себе випадки використання, інтерфейси та ін. Реалізаційна частина описує, яким чином реалізується декларативна частина. Підсистема аналогічна блоку SDL, але загалом система понять UML є більш загальною, ніж у SDL. Методологія ROOM Методологія ROOM (Real-Time Object-Oriented Modeling) – це об'єктно-орієнтована розробка систем реального часу. її розвиток пов'язаний з канадською компанією Object Time Limited, яка на основі цієї методології випустила програмний продукт ObjectTime. Методологію було розроблено в 1992 році. У 1994 році вийшла монографія, яка містить повний опис ROOM. Модель поведінки ROOM розглянуто в інших працях. Крім того, продовжує видаватись велика кількість статей, в яких описано різні аспекти використання цієї технології та подальший розвиток. Заслуговують на увагу праці, в яких описано, як ROOM «вкладається» в UML за допомогою механізму розширень UML. Матеріал, викладений у цих працях є базисом для створення мостів між програмними продуктами, які реалізують ROOM і UML. У методології ROOM передбачено два рівні подання розроблюваної системи: рівень схем; рівень деталізації. Виділення цих рівнів спрямоване на автоматичну кодогенерацію. Таким чином, ця методологія суттєво відрізняється від UML, де пропонуються лише погляди на систему (view), застосування яких не зовсім зрозуміле. Для рівня схем методологія ROOM пропонує набір графічних нотацій. Рівень деталізації передбачає використання мови реалізації, оскільки очевидно, що всю систему, якщо вона достатньо складна, неможливо задати специфікацією у вигляді картинок, за якими можна автоматично згенерувати працюючу програму. Рівень схем складається з графічних нотацій, що дозволяють зобразити структуру системи (класів і об'єктів) та опис моделі її поведінки. Мова UML є лише мовою моделювання і способи застосування винесені з її специфікації. Корпорацією IBM Rational Corp. створено надбудову над UML під назвою RUP (Rational Unified Process), яка дає змогу систематизувати процес створення програмного забезпечення на основі UML, пропонуючи використовувати певний набір програмних продуктів (головним чином, компанії Rational Corp.). Метод RUP Цикл розроблення системи завершується після виконання останньої фази, у результаті чого з'являється нова версія системи. Після цього розроблення продовжується вже на новому рівні внаслідок висування нових вимог до системи і завершується випуском чергової версії системи. Метод RUP передбачає інтерактивність усередині однієї фази. Як звичайно, результатом ітерації є прототип системи. Наводяться такі варіанти кількості ітерацій за фазами: [0,1,1,1], [1,2,2,1], [1,3,3,2]. Таким чином, формулюється загальне правило про кількість ітерацій усередині одного циклу: 6 ± 3. Поняття фази є вдалою абстракцією для виділення етапів розробки системи. Це поняття узгоджує ітеративний процес розробки програмного забезпечення та лінійний порядок звітності. Розроблення системи виконується в чотири фази за допомогою робочих процесів (workflow), які є послідовністю дій, пов'язаних загальною специфікою. Робочі процеси розподіляються за різними фазами і можуть протікати паралельно. Метод RUP передбачає виконання таких робочих процесів. Одним із основних понять методу RUP є фаза. Фаза - це етап розробки системи. З нею, як звичайно, пов'язана проміжна або кінцева звітність до проекту. За методом RUP вирізняється така множина фаз. Фази метода RUP 1. Початок – фаза визначення меж проекту, оцінювання реальності його виконання (терміни, плани, кошти, люди, ризики). 2. Деталізація – фаза створення архітектурного прототипу системи, визначення вимоги до проекту, його вартості і терміну виконання, складання детального плану роботи. 3. Конструювання – фаза реалізації проекту. 4. Передавання – фаза передавання системи замовнику. Робочі процеси Метода RUP 1. Бізнес-моделювання (Business Modeling). 2. Висування вимог (Requirements). 3. Аналіз і проектування (Analysis and Design). 4. Реалізація (Implementation). 5. Тестування (Testing). 6. Впровадження системи (Deployment). Крім того вирізняють такі допоміжні процеси. керування проектом (Project Management); створення конфігурації змін та керування ними (Configuration and Change Management); створення конфігурації середовища (Environment). З наведеного вище огляду засобів CASE-технологій зрозуміло, що всі вони тією або іншою мірою можуть запроваджуватись під час розроблення складних імітаційних систем. Проте існує проблема, яку складно вирішувати за допомогою цих технологій – керування процесом моделювання в модельному часі. Спробою поєднати CASE-технології та імітаційне моделювання є розробка стандарту HLA (High Level Architecture). З метою спрощення процесу створення імітаційних моделей останнім часом розробляються діалогові або інтерактивні системи моделювання, які за допомогою інтерфейсу транслюють вираз природною мовою у програмні реалізації імітаційних моделей. Перші спроби побудови таких систем робились з використанням мови Simula, але засоби автоматичного програмування не були створені через складність реальних модельованих систем. Найбільшого успіху досягнуто під час розробки спеціалізованих систем моделювання для вузьких галузей. Програмні генератори імітаційних моделей Не зважаючи на те, що засоби генерування моделей орієнтовані на конкретні предметні галузі, бажано, щоб вони не враховували будь-які специфічні особливості певної галузі. Цього можна досягти завдяки уніфікації опису імітаційних моделей, який повинен базуватись на єдиній математичній основі для всіх форм зображення модельованого об'єкта: змістовного і формалізованого описів, програмної реалізації. Однак тоді спостерігається неоднорідність опису, зумовлена проблемою погодження опису елементів модельованого об'єкта у вигляді деяких математичних співвідношень з чіткими математичними залежностями та певним способами задання зв'язків між цими елементами. Технологія створення засобів автоматичного генерування імітаційних моделей передбачає: вибір ефективної і коректної конструктивної множини елементів моделі; розробка засобів специфікації, вибору та налагодження елементів моделі; наявність засобів конструювання моделі із обраних елементів. Коректний вибір конструктивної початкової множини елементів визначає клас моделей, які можуть бути реалізовані за допомогою даних засобів. Щоб максимально розширити клас моделей, потрібно обирати множину елементів, якомога ближчу до мовних засобів імітаційного моделювання. Більш того, мова, яка обирається для моделювання, має бути декларативною, що спростить розроблення інтерфейсу між системою програмування та створюваними генератором імітаційними моделями завдяки уніфікації побудови та використання мовних засобів, закладених у самій мові. Серед мов, які задовольняють таким вимогам, слід виділити мову імітаційного моделювання GPSS. За допомогою блоків цієї мови можна будувати дискретно-подійні моделі загального виду. Більше того, ця мова перевірена на практиці протягом понад 40 років на комп'ютерах майже всіх типів. Таким чином, створення генератора імітаційних моделей, в якому як проміжний код використовується код мовою GPSS, дає змогу в разі необхідності змінювати або розширяти генеровану програмну реалізацію імітаційної моделі. Що ж стосується формальної структури генератора імітаційних моделей, то відомо, що найширший клас структур імітаційних моделей покривають стохастичні мережі CM О, які використовуються під час моделювання інформаційних, технологічних, транспортних, ділових процесів, систем обслуговування загального вигляду. Вибір класу структур моделей визначає обмеження на використання об'єктів або систем конкретної предметної галузі, тобто їх необхідно зображувати як дискретні об'єкти класу стохастичних мереж СМО. Для створення методики автоматизованого синтезу програмних реалізацій імітаційних моделей певного класу потрібно побудувати формалізовану модель системи чи процесу у вигляді теоретико-множинного опису. Широкий клас структур концептуальних і імітаційних моделей можна зобразити як орієнтовані графи у вигляді: , де V – кінцева множина вершин; Р – кінцева множина дуг; U – функція, яка ставить у відповідність кожному ребру із множини Р упорядковану пару вершин із множини V. Для програмного генератора, що розробляється, вершинам графа відповідає кінцева множина можливих атомарних підмоделей A1 об'єктів класів К. Характеристика класу К визначається сукупністю атрибутів b, які задають на полі класу Згідно з наведеними вище методами проектування імітаційних моделей та формалізованою процедурою проектування програмного генератора, а також з огляду на вимоги, виконання яких передбачає технологія проектування імітаційних моделей досліджуваних об'єктів, визначається організаційна структура інтерактивної системи імітаційного моделювання ISS 2000. Вона складається із сукупності взаємопов'язаних програмних модулів, які виконують різні процедури: керування, прийняття рішень і перетворення інформації й даних, що містять відомості функціонального та інформаційного характеру. На концептуальному рівні модель системи задається графом, вершини якого являють собою множину об'єктів моделі, таких як генератори вимог, одно- або багатоканальні пристрої обслуговування, термінатори тощо. На логічному рівні визначаються властивості цих об'єктів і зв'язки між ними. Програмний рівень подання моделі містить готовий код програми моделювання на мові GPSS, який створюється після компіляції проекту моделі. Такий програмний генератор повністю автоматизує процес створення імітаційної моделі та проведення експериментів з нею, але не означає, що користувач не може змінити або дописати код програми. Користувач може вносити зміни до коду програми моделювання. Див. також Нейролінгвістичне програмування Мова програмування Композиційне програмування Людино-машинна взаємодія Посилання Програмування українською Форум з програмування Література Зубенко В. В. Програмування: навчальний посібник (гриф МОН України) / В. В. Зубенко, Л. Л. Омельчук. — К. : ВПЦ «Київський університет», 2011. — 623 c. Нікітченко М. С. Теоретичні основи програмування: навчальний посібник / М.С Нікітченко — Ніжин: Видавництво НДУ імені Миколи Гоголя, 2010. — 121с. Огірко І.В., Огірко О.І. Інформаційні технології і системи в умовах інклюзії. «Відкритий міжнародний університет розвитку людини «Україна». IV МІЖНАРОДНОЇ НАУКОВО-ПРАКТИЧНОЇ КОНФЕРЕНЦІЇ «ІНКЛЮЗИВНА ОСВІТА: ДОСВІД І ПЕРСПЕКТИВИ». м. Вінниця, 23 листопада 2017 року.c.24-30. Огірко І.В., Огірко О.І. ІНФОРМАЦІЙНІ ТЕХНОЛОГІЇ ХМАРНИХ ОБЧИСЛЕНЬ. Матеріали конференції. «Інформаційні технології в освітньому процесі 2017». Чернігівський Державний педагогічний університет імені Т.Г. Шевченка: https://kafedraikt.blogspot.com/p/2016.html . https://drive.google.com/file/d/1pT4tFqIkCMTHKq8q2fZSUYHUxV3CUeT0/view . 11-17 грудня 2017 року.c.61-72. Категорія:Комп'ютерні технології Категорія:Програмування"}
{"category": "Програмування", "title": "Агрегатна функція", "abstract": "В інформатиці, агрегатна функція (дослівно - функція складеного значення) — функція, яка повертає одинарне значення з колекції вхідних значень такої як множина (set), мультимножина (multiset) або список (list).\nСеред найпоширеніших агрегатних функцій:\n\nAverage()\nCount()\nMaximum()\nMedian()\nMinimum()\nMode()\nSum()\nАгрегатні функції широко вживані в багатьох мовах програмування, наприклад, Ruby, в електронних таблицях, в реляційній алгебрі.", "content": "В інформатиці, агрегатна функція (дослівно - функція складеного значення) — функція, яка повертає одинарне значення з колекції вхідних значень такої як множина (set), мультимножина (multiset) або список (list). Серед найпоширеніших агрегатних функцій: Average() Count() Maximum() Median() Minimum() Mode() Sum() Агрегатні функції широко вживані в багатьох мовах програмування, наприклад, Ruby, в електронних таблицях, в реляційній алгебрі. Агрегатні функції в SQL В SQL агрегатні функції повертають одинарне значення, обчислене зі значень в стовпці. Деякі корисні агрегатні функції: AVG() — Повертає середнє значення COUNT() — Повертає кількість рядків FIRST() — Повертає перше значення LAST() — Повертає останнє значення MAX() — Повертає найбільше значення MIN() — Повертає найменше значення SUM() — Повертає суму Див. також GROUP BY Примітки Категорія:Програмування Категорія:SQL"}
{"category": "Програмування", "title": "Алгебра алгоритмів", "abstract": "Алгебра алгоритмів — вивчає властивості алгоритмів, виникла в 80-х роках 20 століття. При цьому формальні моделі були запропоновані для первісного поняття алгоритму. Алгебра алгоритмів АА = {A, W}, як і будь-яка алгебра, — це основа А і сигнатура W операцій з елементами цієї основи. За допомогою операції сигнатури можна додати довільний елемент q Î AA. Це називається системою утворювальної алгебри.", "content": "Алгебра алгоритмів — вивчає властивості алгоритмів, виникла в 80-х роках 20 століття. При цьому формальні моделі були запропоновані для первісного поняття алгоритму. Алгебра алгоритмів АА = {A, W}, як і будь-яка алгебра, — це основа А і сигнатура W операцій з елементами цієї основи. За допомогою операції сигнатури можна додати довільний елемент q Î AA. Це називається системою утворювальної алгебри. Історія розвитку Першою формальною моделлю алгоритмічної машини була машина Тюрінга (Алан Тюрінг, Еміль Пост, 1936). Із пізніших моделей відзначимо нормальні алгоритми (А. Марков, І952) .Дослідження і побудова алгебри алгоритмів або алгоритмічної алгебри почалося з проектування логічних структур ЕОМ під керівництвом академіка В. М. Глушкова. Як результат була створена теорія систем алгоритмічних алгебр (САА), що потім Г. О. Цейтліним була покладена в основу узагальненої теорії структурованих схем алгоритмів і програм, названою ним алгоритмікою. Для формалізації самого поняття алгебри алгоритму були запропоновані точні математичні описи .Алгебра алгоритмів виникла як розділ математичної логіки. Перші застосування алгебри алгоритмів -в математичній логіці. Алгебра алгоритмів є теоретичним фундаментом програмування, вона має застосування, де зустрічаються алгоритмічні проблеми (математики, теорія інформації, теорія керування, конструктивний аналіз, обчислювальна математика, теорія ймовірності, лінгвістика, економіка та ін.).Наразі розроблено кілька алгоритмічних алгебр, найвідомішими з яких є алгебра Дейкстри, алгебра схем Янова та алгоритміка програм, досліджена у працях В. М. Глушкова і Г. О. Цейтліна, а також теорія секвенційних алгоритмів, комп'ютерна реалізація алгебри алгоритмів. Основні поняття алгебри алгоритмів Основними поняттями алгебри алгоритмів є:– операції над множинами, булеві операції, предикати, функції й оператори;– бінарні і n-арні відношення, еквівалентність, частково і цілком упорядковані множини;– графи-схеми й операції над графовими структурами;– операції сигнатури САА, аксіоми і правила визначення властивостей програм на основі стратегії згортання, розгортання і їх комбінацій;– методи синтаксичного аналізу структурних програм і символьна обробка. Операції алгебри задовольняють наступні аксіоматичні закони: асоціативності, комутативності, ідемпотентності, закони виключення третього і суперечності. Теорія секвенційних алгоритмів і проектування комп'ютерних систем. Редактор формул алгоритмів і аналіз синтаксису і семантики алгебри алгоритмів-секвенцій. Засоби еквівалентних перетворень алгоритмів. Методи підвищення ефективності математичного моделювання алгоритмів інформаційно-технологічних систем. Принципи побудови комп'ютерної бібліотеки абстрактних алгоритмів. Застосування алгебри алгоритмів Синтез, оптимізація і дослідження математичних моделей алгоритмів керування електроприводом друкарської машини і проектування комп'ютерних систем. Практичним результатом досліджень алгебри алгоритмів є побудова оригінальних інструментальних систем проектування програм на основі сучасних засобів підтримки ООП (Rational Rose). Література Марков А. А., Нагорный Н. М., Теория алгоритмов, М., 1984; Мальцев А. И., Алгоритмы и рекурсивные функции, М., 1965; Успенский В. А., Машина Поста, М., 1979; «Енциклопедія кібернетики», відповідальний ред. В. Глушков, 2 тт., 1973, рос. вид. 1974; Овсяк Володимир Казимирович. Методи підвищення ефективності математичного моделювання алгоритмів інформаційно-технологічних систем: Дис… д-ра техн. наук: 05.13.02 / Українська академія друкарства. —Львів, 1996. — 229л. Овсяк В. Засоби еквівалентних перетворень алгоритмів / Овсяк В. // Доповіді національної академії наук України. — 1996. — № 9. — C.83-89. Овсяк В. Принцип побудови підсистеми редагування формул абстрактних алгоритмів / В. Овсяк, А. Василюк // Комп'ютерні технології друкарства: Збірник наукових праць.- Львів: УАД, 2004. — № 12. — С. 137—145. Owsiak W., Owsiak A., Owsiak J. Teoria algorytmów abstrakcyjnych i modelowanie matematyczne systemów informacyjnych / Owsiak W., Owsiak A., Owsiak J. — Opole: Politechnika Opolska, 2005. — 275 s. Овсяк В. Принципи побудови комп'ютерної бібліотеки абстрактних алгоритмів Коба / В. Овсяк, А. Василюк, О. Яремчишин // Комп'ютерні технології друкарства: Збірник наукових праць.- Львів: УАД, 2006. — № 15. — С.85 — 95. Ovsyak V. Automation of the Process of Search of the Algorithms’ Formulae in the Library «КоБА» / V. Ovsyak, A. Vasyluk, O. Yaremchyshyn // Proc. of the IX-th intern. Conference «The experience of designing and application of CAD systems in microelectronics (CADSM'2007)». -Lviv-Polyana: Lviv Polytechnic National University, 2007. — P. 418—420. Овсяк В., Возна М. Синтез, оптимізація і дослідження математичних моделей алгоритмів керування електроприводом друкарської машини // Вісник Державного університету «Львівська політехніка». — № 364. -Прикладна математика. — Львів, 1999. — С. 105 — 110. Бритковський В. М., Овсяк В. К., Огірко О. І. Редактор формул алгоритмів і аналіз синтаксису і семантики алгебри алгоритмів-секвенцій. /Матеріали 7 всеукраїнської наукової конференції «Сучасні проблеми прикладної математики та інформатики» Львів: НУ ім. І. Франка,2000. -С. 17-18 Овсяк В. К., Бритковський В. М., Овсяк О. В., Овсяк Ю. В. Теорія секвенційних алгоритмів і проектування комп'ютерних систем: Навчальний посібник. —Львів: УАД, 2001. —141 с. Огірко О. Синтаксис оптимізації моделі та моделювання синтаксису механізму розпізнавання символіки алгебри алгоритмів секвенції. // Комп'ютерні технології друкарства, № 5, 2000. -С. 296—303. Огірко О. Комп'ютерна реалізація алгебри алгоритмів. // Комп'ютерні технології друкарства, № 5, 2000. -С. 200—205. Огірко О. Автоматизовані способи розпізнавання для алгебри алгоритмів.// Автоматика — 2000. — Т.6. — Львів: Державний НДІ інформаційної інфраструктури, 2000. Огірко О. Модель системи генерації програм СКАНЕР. // Комп'ютерні технології друкарства, № 6, 2001. -С. 42-48. Огірко О. Модель комп'ютерної системи генерації програм з формул алгоритмів. // Комп'ютерні технології друкарства, № 6, 2001. -С. 93-97. Огірко О. І. Принцип побудови системи генерації програм з операцій теорії секвенційних алгоритмів//. КВАЛІЛОГІЯ КНИГИ, № 6, 2003. -С. 189—193. Огірко О.І Реалізація математичної моделі підсистеми генерації програм з операцій теорії секвенційних алгоритмів// Комп'ютерні технології друкарства, № 8, 2004. Алгебри алгоритмів Див. також Список алгоритмів Теорія складності обчислень Категорія:Теорія алгоритмів Категорія:Програмування Категорія:Алгебра логіки"}
{"category": "Програмування", "title": "Алгоритм Еллера генерації лабіринтів", "abstract": "Алгоритм Еллера — це математичний генератор, що дозволяє створювати лабіринти, у яких між кожними двома точками існує єдиний шлях, тобто лабіринти не містять циклів.\nУ порівнянні з іншими генераторами, цей алгоритм є одним із найшвидших та потребує незначну кількість пам'яті — пропорційну довжині рядка лабіринту.\nПотрібно зберігати в пам'яті лише останній створений рядок — це дозволяє генерувати лабіринти з необмеженою кількістю рядків.", "content": "Алгоритм Еллера — це математичний генератор, що дозволяє створювати лабіринти, у яких між кожними двома точками існує єдиний шлях, тобто лабіринти не містять циклів. У порівнянні з іншими генераторами, цей алгоритм є одним із найшвидших та потребує незначну кількість пам'яті — пропорційну довжині рядка лабіринту. Потрібно зберігати в пам'яті лише останній створений рядок — це дозволяє генерувати лабіринти з необмеженою кількістю рядків. Як відбувається генерація Алгоритм являє собою цикл додавання нових рядків. Рядок містить одну і ту саму кількість клітинок, яка довільно задається на початку. Клітинки належать до множин, що слугують для контролю можливості проходу між клітинками. На момент генерації поточного рядка клітини однієї множини з'єднані між собою, водночас клітини з різних множин знаходяться в ізольованих між собою частинах лабіринту. У кожної клітинки може бути або не бути права та нижня стінка. Загалом, стінки генеруються випадковим чином, але при дотриманні певних правил, які гарантують відсутність циклів у лабіринті. Формальний опис алгоритму Створити перший рядок. Жодна клітинка не належить жодній множині Присвоїти кожній з клітинок, що не мають множини, свою унікальну множину Створити праві стінки, рухаючись зліва направо: Випадково вирішити, чи додавати стінку: Якщо поточна клітинка та клітинка справа належать одній множині, додати стінку (для запобігання зацикленням) Якщо вирішено не додавати стінку, об'єднати множини поточної та наступної клітинки Створити стінки знизу, рухаючись зліва направо: Випадково вирішити, чи додавати стінку знизу. При додаванні переконатися, що кожна множина має хоча б одну клітинку без нижньої стінки — це гарантуватиме відсутність ізольованих областей Вирішити, чи додавати рядки після поточного Якщо вирішено додати рядок, то: Вивести поточний рядок Видалити всі праві стінки Видалити клітинки з нижніми стінками з їх множин Видалити всі нижні стінки Продовжити з кроку 2 Якщо вирішено закінчити лабіринт, то: Додати нижню стінку до кожної клітинки Рухаючись зліва направо: Якщо поточна клітинка та клітинка справа належать до різних множин, то: Видалити праву стінку Об'єднати множини цих клітинок Приклад генерації Проілюструємо процес створення лабіринту покроково. Для початку визначимося з довжиною рядка — нехай вона дорівнюватиме 6. (Оскільки лабіринт має бути оточений стінками з усіх боків, перший рядок зробимо з верхніми, останній — з нижніми, усі перші клітинки — з лівими, а останні в кожному рядку — з правими стінками). 1. Створимо перший рядок. __ ___ __ ___ __ ___ | | 2. Присвоїмо всім клітинкам унікальну множину __ ___ __ ___ __ ___ | 1 2 3 4 5 6 | 3. Рухаючись зліва направо, випадковим чином вирішимо, чи додавати стінки між клітинками(Оскільки на даному кроці всі клітинки належать до різних множин, наш вибір ніщо не обмежує) __ ___ __ ___ __ ___ |(1 | 2) 3 4 5 6 | - додаємо праву стінку після першої клітинки __ ___ __ ___ __ ___ | 1 |(2 3) 4 5 6 | - не додаємо стінку після другої __ ___ __ ___ __ ___ | 1 | 2 2 4 5 6 | - об'єднуємо множини, до яких належать 2 та 3 клітинки __ ___ __ ___ __ ___ | 1 | 2 (2 4) 5 6 | __ ___ __ ___ __ ___ | 1 | 2 2 2 5 6 | __ ___ __ ___ __ ___ | 1 | 2 2 (2 | 5) 6 | __ ___ __ ___ __ ___ | 1 | 2 2 2 |(5 | 6)| __ ___ __ ___ __ ___ | 1 | 2 2 2 | 5 | 6 | 4. Додамо нижні стінки __ ___ __ ___ __ ___ |(1)| 2 2 2 | 5 | 6 | - не додаємо стінку, це - остання клітинка у множині з індексом 1, що не має нижньої стінки. __ ___ __ ___ __ ___ | 1 |_2_ 2 2 | 5 | 6 | __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | 5. Вітаю! Ми отримали перший завершений рядок нашого лабіринту. Додамо наступний. Для цього виведемо поточний іще раз: __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 |_2_ 2 _2_| 5 | 6 | 5. 1. 1. Видалимо всі праві стінки __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 _2_ 2 _2_ 5 6 | 5. 1. 2. Усі клітинки, що містять нижні стінки, видалимо з їх множин __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 _ _ 2 _ _ 5 6 | 5. 1. 3. Видалимо нижні стінки __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 2 5 6 | Повернемося до пункту 2. Присвоїмо клітинкам, що не належать до множин, унікальні множини __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 3 2 4 5 6 | 3. Створимо праві стінки __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 1 | 2 2 | 5 5 | 4. Створимо нижні стінки __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 _1_|_2_ 2 | 5 5 | 5. 1. 1. Продублюємо останній рядок __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 _1_|_2_ 2 | 5 5 | | 1 _1_|_2_ 2 | 5 5 | 5. 1. 2. Витремо праві стінки __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 _1_|_2_ 2 | 5 5 | | 1 _1_ _2_ 2 5 5 | 5. 1. 3. Видалимо клітинки з нижніми стінками __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 _1_|_2_ 2 | 5 5 | | 1 _ _ _ _ 2 5 5 | 5. 1. 4. Видалимо нижні стінки __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 _1_|_2_ 2 | 5 5 | | 1 2 5 5 | Повернемося до пункту 2. Присвоїмо порожні клітинки множинам __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 _1_|_2_ 2 | 5 5 | | 1 3 4 2 5 5 | 3. Створимо праві стінки __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 _1_|_2_ 2 | 5 5 | | 1 1 | 4 4 5 5 | __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 _1_|_2_ 2 | 5 5 | | 1 1 | 4 (4 5) 5 | Зверніть увагу: ми об'єднуємо множини клітинок, тобто остання клітинка також стане належати до множини 4 після даного кроку. __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 _1_|_2_ 2 | 5 5 | | 1 1 | 4 4 4 4 | Тут обов'язково поставити стінку після 5 клітинки — наступна з тієї самої множини __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 _1_|_2_ 2 | 5 5 | | 1 1 | 4 4 (4 | 4)| 4. Додамо нижні стінки __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 _1_|_2_ 2 | 5 5 | | 1 _1_| 4 _4_ _4_| 4 | 5. Більше не додаватимемо рядків 5. 2. 1. __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 _1_|_2_ 2 | 5 5 | |_1_ _1_|_4_ _4_ _4_|_4_| 5. 2. 2. Праву стінку після 2 клітинки потрібно видалити та об'єднати множини 2 та 3 клітинок(після завершення проходження по рядку усі клітинки мають належати одній множині). __ ___ __ ___ __ ___ | 1 |_2_ 2 _2_| 5 | 6 | | 1 _1_|_2_ 2 | 5 5 | |_1_ _1_ _1_ _1_ _1_|_1_| І от, наш лабіринт нарешті завершено. Вхід та вихід можна зробити з будь-якої зовнішньої стінки лабіринту. __ ___ __ ___ __ ___ |_ _ _ _| | | | _ _|_ _ | | |_ _ _ _ _ _ _ _ _ _|_ _ Приклад згенерованого лабіринту _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ | |_ _ _ _ | | | | | _| | | | |_ |_ _ | |_ | | | | | |_ |_ _ | | | | | | _ _ |_ | _| | | |_| |_|_ _|_ |_ | _ _ | _ _|_ | | | | | |_| | | |_| | | | | _ _ _| _|_ | | _|_ | _| | _ _ _ _| |_| |_|_ _|_| | |_| | | _| |_ _ |_ | | | | | | |_|_ | _| | | | | |_| | | | | | |_ _| |_|_| | | _ | | |_|_| |_|_ | | | | |_| |_| | | | |_| | | | |_ |_ _ _| | | |_ _|_ _ |_ _ _| |_ |_ | | |_ | |_ _| | | | | | _| | _| | |_|_ _ _| |_|_ | | | | | | |_ _|_| _| |_ _| | |_| | | | |_|_| |_| | | | |_| |_|_ |_ | _|_ | |_ _| | | _| | _ _| | _ _| |_|_ | | | | | |_| | | | | |_ _| | |_|_ | | | |_| _|_| |_|_| | | |_ _| _ _ | | | | |_ | |_| |_| |_ _ | | _ _| | | | | _ _| | _| |_ _|_ _| |_ _ | |_ _| | _ _|_ |_ | |_|_ | |_| _|_|_|_| |_ |_ | | | |_ _| | | | |_ _ | _| |_| _|_ |_ _ _ _| | | _|_| _|_ |_|_ _| | _ _| | _| | _| | _| |_| |_ |_ _ _| _| | _| |_ _ _| _ _| | | | | |_ | | | _ _| | | |_|_ _| _|_ |_ _ _| | | | |_|_| |_ _ | | | |_ _ _ | | | | |_| | | _| | _| | | | | | | |_ | |_ |_ | _ _| | | _| | | _| | | | | | | |_| |_| | | | |_ _| |_| | |_ _ _ _| | | | | _| | _ _| | | |_|_ |_ _| | |_ |_ _ _ _| |_|_| |_ _| | | | |_ _| _| | _|_ | | | | | | | |_ |_ | | | | | _|_ _| | |_ | | _| | |_ | |_| | |_ | | |_|_| | | | |_ _ | | _| _ |_|_| | | | _|_ | |_ _| |_| | | | | | | | | | |_|_|_ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _|_ _ _ _ _|_ _|_|_|_ _ _ _ Посилання http://www.neocomputer.org/projects/eller.html Категорія:Програмування"}
{"category": "Програмування", "title": "Алгоритміка", "abstract": "Алгоритміка (англ. agorithm design) — дисципліна, що вивчає алгоритми, та їх застосування до розв'язування задач. У практичному плані алгоритміка є навчанням студента спортивного програмування.\nВідрізняється від теорії алгоритмів тим що не займається пошуком доведення існування алгоритму, а займається пошуком оптимального (в основному за часом виконання), алгоритму, що розв'язує дану задачу. Якщо такий алгоритм невідомий, то намагається розв'язати задачу хоча б частково.", "content": "Алгоритміка () — дисципліна, що вивчає алгоритми, та їх застосування до розв'язування задач. У практичному плані алгоритміка є навчанням студента спортивного програмування. Відрізняється від теорії алгоритмів тим що не займається пошуком доведення існування алгоритму, а займається пошуком оптимального (в основному за часом виконання), алгоритму, що розв'язує дану задачу. Якщо такий алгоритм невідомий, то намагається розв'язати задачу хоча б частково. Відомі алгоритми Алгоритми сортування Алгоритми на графах Алгоритми теорії чисел. (Алгоритм Евкліда та подібні) Алгоритми аналітичної геометрії (наприклад алгоритм Брезенхейма). Категорія:Алгоритми Категорія:Програмування Категорія:Теоретична інформатика"}
{"category": "Програмування", "title": "Альфа-тестування", "abstract": "Альфа-тестування (англ. Alpha testing) — імітація реальної роботи з системою штатними розробниками, або реальна робота з системою потенційними користувачами/замовником. Найчастіше альфа-тестування проводиться на ранній стадії розробки продукту, але в деяких випадках може проводитися для готового продукту як внутрішнє приймальне тестування. Іноді альфа-тестування виконується відладчиком або за допомогою середовища, яке допомагає швидко виявляти знайдені помилки. Виявлені помилки можуть бути передані тестувальникам для додаткового дослідження в середовищі, подібному до того, в якому буде використовуватися ПЗ. Для альфа-тестування в основному застосовується спеціальний тип тестування Ad hoc.", "content": "Альфа-тестування () — імітація реальної роботи з системою штатними розробниками, або реальна робота з системою потенційними користувачами/замовником. Найчастіше альфа-тестування проводиться на ранній стадії розробки продукту, але в деяких випадках може проводитися для готового продукту як внутрішнє приймальне тестування. Іноді альфа-тестування виконується відладчиком або за допомогою середовища, яке допомагає швидко виявляти знайдені помилки. Виявлені помилки можуть бути передані тестувальникам для додаткового дослідження в середовищі, подібному до того, в якому буде використовуватися ПЗ. Для альфа-тестування в основному застосовується спеціальний тип тестування Ad hoc. Ad Hoc Тестування Ad Hoc схоже на розвідувальне, але тут вважається, що ви вже працювали з тестованою програмою до цього і знаєте як вона влаштована. Виконуючи цей тест, ви за короткий термін повинні попрацювати з програмою, охопивши основні аспекти її роботи і задокументувати дивну її поведінку. Ключові моменти Можливість залучання методів тестування «чорної» та «білої» скриньки. Не слід залучати сторонніх користувачів в процесі альфа-тестування. Основа альфа-тестування Альфа-тестування використовує прототипи для тестування програмного забезпечення в стадії бета-версії. Тим не менш, не слід очікувати на те, що програма буде володіти повною функціональністю, для яких вона призначена спеціально на даному етапі. Це тому, що альфа-тестування зазвичай проводиться для того, щоб програмне забезпечення, яке в даний час розробляється, надає всі необхідні основні функції і те що воно приймає усі вхідні дані, а також видає очікувані результати. Можна впроваджувати альфа-тестування, коли розробники програмного забезпечення в певних умовах проводять інші види тестування. Це дозволить їм бачити як буде поводитись програмне забезпечення яке працює в реальних, практичних умовах. Тим не менше, число споживачів, які перевіряють програмне забезпечення, має бути суворо обмежена, так як програмне забезпечення ще не готове до комерційного запуску на даному етапі. Очікування від альфа-тестування При запуску кінцевого продукту для тестування тестери неодмінно зустрінуться з рядом незначних проблем та помилок, і в кінцевому підсумку відчуттям розчарування. Це тому, що розробники програмного забезпечення мали б подбати про найбільш складні і серйозні проблеми, тільки-но вони зіткнулись з ними. Таким чином, програмне забезпечення в процесі його альфа-стадії буде мати мінімальну функціональність і можливість приймати вхідні дані та створити очікувані результати. Таким чином, користувачі, які будуть перевіряти програмне забезпечення, мають бути повідомлені про цей факт, щоб вони могли створити неупереджений і точний відгук про проблеми програмного забезпечення та інші питання дизайну. Розробники програмного забезпечення повинні взяти на себе всю відповідальність за повідомлення усіх користувачам з приводу обмежених можливостей програмного забезпечення. Крім того, пакет програмного забезпечення повинен також включати консультативний лист, в якому ідеться про обмежені можливості програмного забезпечення. Клієнти також повинні розуміти, що вони, швидше за все, досвід управління програмного забезпечення на альфа-стадії може певною мірою розчарувати їх. Реальна мета альфа-тестування споживачем це — забезпечення необхідного зворотного зв'язку, який дає кінцевим користувачам таку перспективу, щоб розробники програмного забезпечення могли вирішувати виникаючі питання. Зворотний зв'язку з клієнтами, і свідчення їх про проблеми з якими вони зіткнулися, а також те що вони очікують від програми після виходу її на ринок є дуже суттєвим. Переваги альфа-тестування Альфа-тестування забезпечує більш повне уявлення про надійність програмного забезпечення і надійність на його ранніх стадіях. Альфа-тестування дає змогу з'ясувати, чи має програмне забезпечення реальний потенціал для роботи на стадії альфа-версії, дозволяє швидко виявити помилки під-час тестування, оскільки інші дрібні частини структури не інтегровані. З цієї єдиної причини альфа-тестування має можливість забезпечити раннє виявлення проблем, що стосуються питань проектування і помилок, щоб запобігти можливим проблемам в майбутньому. Тестування слід проводити для того, щоб переконатися, чи отримуватиме користувач послуги високої якості у вигляді повної функціональності і стабільності. Особливості, які технічна команда шукає в програмну забезпеченні, — це ефективність, ремонтоспроможність, зручність використання, сумісність і надійність. Однак найбільш найбільшою вимогою є те, що програмне забезпечення яке надане користувачеві, повинно працювати належним чином відповідно до встановлених цілей. Проведення тестів альфа покаже, чи володіє програмне забезпечення всіма необхідними функціями, щоб пройти суворі стандарти якості EPRI і навіть ISO. Тим не менш, загальна якість, що стосуються програмного забезпечення ніколи не є абсолютною, воно просто повинно відповідати певному набору вимог, які йому представлені. Недоліки альфа-тестування Як і будь-які інші процеси тестування програмного забезпечення, навіть альфа-тестування має деякі обмеження в його використанні. Крім того, воно також пропонує деякі особливі переваги в порівнянні з іншими процедурами випробувань. Оскільки альфа-тестування використовує нерозвинені прототипи, цей тип тестування підходить тільки для ранніх стадій програмного забезпечення. Alpha Test дозволяє розробникам побачити справжні можливості свого програмного забезпечення, включаючи питання дизайну. Розробники програмного забезпечення можуть виправити поточний код та структурні проблеми прямо під час процесу альфа-тест. Однак слід пам'ятати про декілька важливих факторів альфа-тестування перед відправкою його для користувачів. Перше: потрібно брати до уваги можливості користувачів, які будуть тестувати продукт під час альфа стадії, що в кінцевому підсумку може призвести то незадовільних результатів, Це може виникнути через те, що програма є не повністю розширена. Навіть коли ви даєте інформацію про його стадії розвитку, користувач може відчути, що програмне забезпечення, яке було дане їм, не в змозі задовольнити їх потреби і вимоги. Друге: час від часу, деякі відгуки, отримані від споживачів, які займаються альфа-тестуванням, також можуть бути точними, оскільки користувачі могли зіткнулися з якоюсь проблемою або здобути поганий досвід при роботі з програмним забезпеченням. Як підсумок Програмне забезпечення має пройти через ряд важливих процедур тестування, перед тим як здійснювати комерційний запуск його на конкурентний ринок. Альфа-тестування, мабуть, один з найбільш корисних видів тестування, яке програмне забезпечення має пройти, для того щоб отримати повну функціональність і зручність у використанні. Цитати «Тестування програм може використовуватися для демонстрації наявності помилок, але воно ніколи не покаже їхньої відсутності.» — Едсгер Дейкстра, 1970 р. Див. також Автоматизоване тестування Тестування програмного забезпечення Юзабіліті-тестування Бета-тестування Регресійне тестування Розробка через тестування Benchmark programs NUnit Література Лайза Кріспін, Джанет Грегорі. Гнучке тестування: практичне керівництво для тестувальників ПЗ і гнучких команд = Agile Testing: A Practical Guide for Testers and Agile Teams. — М.: «Вільямс», 2010. — 464 с. — (Addison-Wesley Signature Series). — 1000 примірників. — ISBN 978-5-8459-1625-9 Калбертсон Роберт, Браун Кріс, Кобб Гері. Швидке тестування. — М.: «Вільямс», 2002. — 374 с. — ISBN 5-8459-0336-X Посилання The Test Management Guide What is Alpha Testing Alpha Testing Vs. Beta Testing Категорія:Програмування Категорія:Тестування програмного забезпечення Категорія:Програмна інженерія"}
{"category": "Програмування", "title": "Архітектура програмного забезпечення", "abstract": "Архітектура програмного забезпечення  (англ. software architecture) — спосіб структурування програмної або обчислювальної системи, абстракція елементів системи на певній фазі її роботи. Система може складатись з кількох рівнів абстракції і мати багато фаз роботи, кожна з яких може мати окрему архітектуру.\nДослідження архітектури програмного забезпечення намагається визначити як найкраще розбити систему на частини, як ці частини визначають та взаємодіють одна з одною, як між ними передається інформація, як ці частини розвиваються поодинці і як все вищеописане найкраще записати використовуючи формальну чи неформальну нотацію.\nАрхітектура повинна будуватись щоб найкраще відповідати вимогам до системи що створюється, згідно принципу \"форма відповідає функції\".\nЗгідно Perry та Wolf архітектурою є набір елементів що мають певну форму (властивості і обмеження що накладаються на елементи), і їх обґрунтування (англ. rationale). Обґрунтування фіксує мотиви вибору певного архітектурного стилю, елементів і обмежень. Рой Філдінг вважає що обґрунтування необхідне на етапі створення архітектури, і корисне надалі але не є невід'ємним її елементом. Тому що архітектура має набір властивостей що дозволяють їй задовольняти вимоги, і незнання цих вимог може призвести до змін що порушують архітектуру, але до архітектури входять властивості а не вимоги.  Наприклад можна не знати що в \"архітектуру\" стола закладену вимогу стійкості, і тому він повинен мати більше двох ніжок. Не знаючи про цю вимогу, ми можемо відпиляти забагато ніжок і стіл впаде. Але це тому що ми порушили архітектурне обмеження \"мати три чи більше ніжок\".\nТерміном \"Архітектура\" також називають документування архітектури програмного забезпечення. Документування архітектури ПЗ спрощує процес комунікації між зацікавленими особами, дозволяє зафіксувати прийняті на ранніх етапах проєктування рішення про високорівневий дизайн системи і дозволяє використовувати компоненти цього дизайну і шаблони проєктування повторно в інших проєктах.", "content": "Архітектура програмного забезпечення () — спосіб структурування програмної або обчислювальної системи, абстракція елементів системи на певній фазі її роботи. Система може складатись з кількох рівнів абстракції і мати багато фаз роботи, кожна з яких може мати окрему архітектуру. Дослідження архітектури програмного забезпечення намагається визначити як найкраще розбити систему на частини, як ці частини визначають та взаємодіють одна з одною, як між ними передається інформація, як ці частини розвиваються поодинці і як все вищеописане найкраще записати використовуючи формальну чи неформальну нотацію. Архітектура повинна будуватись щоб найкраще відповідати вимогам до системи що створюється, згідно принципу \"\". Згідно Perry та Wolf архітектурою є набір елементів що мають певну форму (властивості і обмеження що накладаються на елементи), і їх (). Обґрунтування фіксує мотиви вибору певного архітектурного стилю, елементів і обмежень. Рой Філдінг вважає що обґрунтування необхідне на етапі створення архітектури, і корисне надалі але не є невід'ємним її елементом. Тому що архітектура має набір властивостей що дозволяють їй задовольняти вимоги, і незнання цих вимог може призвести до змін що порушують архітектуру, але до архітектури входять властивості а не вимоги. Наприклад можна не знати що в \"архітектуру\" стола закладену вимогу стійкості, і тому він повинен мати більше двох ніжок. Не знаючи про цю вимогу, ми можемо відпиляти забагато ніжок і стіл впаде. Але це тому що ми порушили архітектурне обмеження \"мати три чи більше ніжок\". Терміном \"Архітектура\" також називають документування архітектури програмного забезпечення. Документування архітектури ПЗ спрощує процес комунікації між зацікавленими особами, дозволяє зафіксувати прийняті на ранніх етапах проєктування рішення про високорівневий дизайн системи і дозволяє використовувати компоненти цього дизайну і шаблони проєктування повторно в інших проєктах. Огляд Область комп'ютерних наук з моменту свого утворення зіткнулася з проблемами, пов'язаними зі складністю програмних систем. Раніше проблеми складності вирішувалися розробниками шляхом правильного вибору структур даних, розробки алгоритмів і розмежуванню повноважень. Хоча термін «архітектура програмного забезпечення» є відносно новим для індустрії розробки ПЗ, фундаментальні принципи цієї області невпорядковано застосовувалися піонерами розробки ПЗ починаючи з середини 1980-х. Перші спроби зрозуміти і пояснити програмну архітектуру системи були повні неточностей і страждали від нестачі організованості, часто це була просто діаграма з блоків, з'єднаних лініями. В 1990-ті роки спостерігається спроба визначити і систематизувати основні аспекти даної дисципліни. Початковий набір шаблонів проєктування, архітектурних стилів, найкращих практик та були розроблені протягом цього часу. Основною ідеєю дисципліни архітектури ПЗ є ідея зниження складності системи шляхом абстракції і розмежування повноважень. Досі немає згоди щодо чіткого визначення терміну «архітектура програмного забезпечення». Будучи, наразі, дисципліною без чітких правил про «правильний» шлях створення системи, проєктування архітектури ПЗ є поєднанням науки і мистецтва. Аспект мистецтва полягає в тому, що будь-яка комерційна система передбачає наявність застосування або місії. Ключові цілі, які має система, описуються з допомогою як нефункціональні вимоги до системи, також відомі як атрибути якості, які визначають, як буде поводитись система. Атрибути якості системи включають в себе відмовостійкість, збереження зворотної сумісності, розширюваність, надійність, супроводжуваність, доступність, безпека, зручність використання, а також інші якості. З точки зору користувача програмної архітектури, програмна архітектура дає напрям руху і вирішення завдань, пов'язаних зі спеціальністю кожного такого користувача, наприклад, зацікавленої особи, розробника ПЗ, Служба технічної підтримки, спеціаліста по супроводу, спеціаліста по розгортанню ПЗ, тестера, а також кінцевих користувачів. У цьому сенсі архітектура програмного забезпечення насправді об'єднує різні точки зору на систему. Можливість об'єднати кілька різних точок зору на систему є аргументом на захист необхідності і доцільності створення архітектури ще до етапу розробки ПЗ. Історія Початок архітектурі програмного забезпечення як концепції було покладено в науково-дослідницькій роботі Едсгера Дейкстри в 1968 році і на початку 1970-х. Ці вчені підкреслили, що структура системи ПЗ має важливе значення, і що побудова правильної структури - критично важливо. Популярність вивчення цієї області зросла з початку 1990-х років разом з науково-дослідницькою роботою по дослідженню архітектурних стилів (шаблонів), мов описания архітектури, документування архітектури і формальних методів. У розвитку архітектури програмного забезпечення як дисципліни відіграють важливу роль науково-дослідницькі установи. Мері Шоу і Девід Герлан з університету Карнегі-Меллон написали книгу під назвою «Архітектура програмного забезпечення: перспективи нової дисципліни в 1996 році», в якій висунули концепції архітектури програмного забезпечення, такі як компоненти, з'єднувачі (connectors), стилі і так далі. У Каліфорнійському університеті в Ірвайні, інститут по дослідженню ПЗ насамперед досліджує архітектурні стилі, мови опису архітектури і динамічні архітектури. Першим стандартом опису програмної архітектури є стандарт : ANSI / IEEE 1471—2000: Рекомендації по опису переважно програмних систем. Він був прийнятий в 2007 році, під назвою ISO ISO / IEC 42010:2007. Проєктування архітектури програмних систем Проєктування архітектури ПЗ — це процес розроблення, що виконується після етапу аналізу і формулювання вимог. Задача такого проєктування — перетворення вимог до системи у вимоги до ПЗ і побудова на їхній основі архітектури системи. Побудова архітектури системи здійснюється шляхом визначення цілей системи, її вхідних і вихідних даних, декомпозиції системи на підсистеми, компоненти або модулі та розроблення її загальної структури. Проєктування архітектури системи може проводитися різними методами (стандартизованим, об’єктно-орієнтованим, компонентним і ін.), кожний з яких пропонує свій шлях побудови архітектури, а саме, визначення концептуальної, об’єктної й інших моделей за допомогою відповідних конструктивних елементів (блок-схем, графів, структурних діаграм тощо). Об’єктний підхід Проєктування системи може здійснюватися на основі об'єкто-орієнтованого моделювання ПрО методом UML, який дозволяє враховувати аспекти, властиві діючим особам (акторам) системи, створювати сценарії виконання системи тощо. Об’єктний стиль проєктування — це декомпозиція майбутньої системи на окремі підсистеми (пакети), визначення функціональних і нефункціональних вимог і об’єктної моделі предметної області. Носіями інтересів, можливостей і дій в системі (або пакеті) є діючі особи — актори. Пакет може складатися з об’єктної моделі, варіантів використання, що визначають сценарії поведінки системи, склад об’єктів і методів їхньої взаємодії. Поведінка об’єктів відображується діаграмами, що задають послідовність взаємодії об’єктів (діаграми послідовностей, взаємодії), правилами переходу від стану до стану (діаграми станів), а також діаграмами кооперації, в яких діючі особи зображуються графічно. Об’єкти і відповідні їм діаграми варіантів використання задають загальну архітектурну схему системи, у рамках якої здійснюється реалізація структури і специфіки поведінки компонентів. Загальна концепція об’єктного проєктування — це побудова всіх сценаріїв, екранних діаграм для керування ними і їх випробування в різних варіантах використання. На вибір варіантів використання впливають нефункціональні вимоги (наприклад, забезпечення конфіденційності, швидкодії й ін.). На основі моделі опису вимог і понять проводиться уточнення складу і змісту функцій системи, методів їхньої реалізації у вигляді сценаріїв і діаграм потоків даних, у яких відображається взаємодія об’єктів як обмін повідомленнями між елементами системи для передачі даних і одержання відповіді після виконання операцій. Моделі вимог визначають призначення і місце вимог у таких системах. Цьому сприяють розроблені національні, корпоративні і відомчі стандарти. Вони фіксують правила формування нефункціональних вимог, у яких відображаються відомості про взаємодію і захист даних у системі. При цьому поведінка об’єктів представляється діаграмами UML, вони можуть уточнюватися при перегляді моделей вимог і складу об’єктів системи. Перегляд починається з вимог і пошуку місць локалізації для внесення необхідних змін у модель. Зміни можуть стосуватися функціональних і нефункціональних вимог у зв’язку з уточненням замовником обмежень на структуру системи, використовувані ресурси й умови середовища її функціонування. Загальносистемний підхід Один зі шляхів архітектурного проєктування — традиційний неформальний підхід до визначення архітектури системи, її компонентів, способів їхнього подання й об’єднання в систему, який можна назвати загальносистемним. Фактично архітектура, що створюється згідно з таким підходом, є чотирирівневою і містить у собі: системні компоненти. Вони здійснюють взаємодію з периферійними пристроями комп’ютерів (принтери, клавіатура, сканери, маніпулятори і т.п.), використовуються при побудові операційних систем. загальносистемні компоненти. Вони забезпечують взаємодію з універсальними сервісними системами середовища роботи прикладної системи, такими як операційні системи, СКБД, системи баз знань, системи керування мережами і т.п. специфічні компоненти певної прикладної області, що входять до складу компонентів програмної системи і призначені для розв’язання задач в межах означеної області (наприклад, бізнес-задачі). прикладні програмні системи, що призначені для виконання завдань з обробки інформації, які постають перед окремими групами споживачів інформації з різних предметних областей (офісні системи, системи бухгалтерського обліку й ін.) і можуть використовувати компоненти нижчих рівнів. Компоненти кожного з виділених рівнів використовуються, як правило, на своєму або вищому рівні. Кожен рівень відбиває відповідний набір знань, умінь і навичок фахівців, що створюють або використовують компоненти. Цей набір визначає відповідний розподіл фахівців програмної інженерії на аналітиків, системщиків, прикладників, програмістів й ін. При проєктуванні архітектури програмна система розглядається як композиція компонентів третього рівня з доступом до компонентів першого і другого рівнів. Тобто архітектурне проєктування — це розроблення компонентів третього рівня, визначення вхідних і вихідних даних рівнів ієрархії компонентів і їхніх зв’язків. Результат проєктування — архітектура й інфраструктура, що містять у собі набір об’єктів, з яких можна формувати деякий конкретний вид архітектурної схеми для конкретного середовища виконання системи, а також набір елементів керування і контролю. Проєктування архітектури системи завершується створенням опису, в якому відображені зафіксовані проєктні рішення, логічна і фізична структура системи, а також способи взаємодії об’єктів. Області архітектури програмного забезпечення Архітектурний стиль ( - це іменований набір сумісних архітектурних обмежень (). Іменуються стилі для зручності посилання на них. Так як додавання архітектурного обмеження до стилю утворює новий стиль, ми можемо уявити всі можливі стилі як дерево, яке починається з нульового стилю (який не містить жодних обмежень). Якщо обмеження в стилях не кофліктують, стилі можна об'єднувати аби утворити гібридний стиль. Невідповідність архітектурі () - ситуація коли реалізація системи порушує обмеження архітектури яку вибрали для системи. Хоча загалом невідповідностей майже неможливо уникнути, їх варто ідентифікувати щоб вони не стандартизувалися. Архітектура рекурсивна, і описується для кожного рівня абстракції. Крім того кожна фаза роботи системи має окрему архітектуру. Наприклад файл конфігурації є окремим елементом системи на етапі її запуску, але під час подальшої роботи дані що містились в ньому вже розподілені між іншими компонентами системи, і як окремий компонент він в цій фазі не присутній. Таким чином архітектура відрізняється від структури програмного забезпечення - остання стосується статичного коду, в той час як архітектура описується для системи що виконується. І хоча є переваги в тому аби архітектура системи відповідала структурі коду який її утворює, проте також є й перевага в тому аби різні компоненти архітектури використовували, наприклад, розподілювані бібліотеки. Елементи архітектури поділяються на елементи обробки () які виконують перетворення даних, елементи даних () які містять дані, і з'єднувальні елементи (), які з'єднують елементи обробки, не змінюючи даних які по них проходять. Хоча їх часто називають компонентами () та конекторами (). Компонент - це абстрактна одиниця коду програми та внутрішнього стану, яка дозволяє перетворення даних через свій інтерфейс. Архітектура не задає реалізацію компонента, а лише його інтерфейс і сервіси які він повинен надавати іншим компонентам. Конектор дозволяє комунікацію між компонентами передаючи елементи даних між їх інтерфейсами, без зміни даних. Конектор може складатись з компонентів, на зразок стеку протоколів, але це деталі реалізації що не входять до архітектури. Дані - це те що передається або приймається компонентами з допомогою конекторів. Прикладами є потоки байтів, сигнали, серіалізовані об'єкти і.т.п., окрім інформації що міститься всередині компонента. Так, з точки зору архітектури, файл - перетворення послідовності байт імені в послідовність байт вмісту, яке здійснює компонент файлової системи. Деякі компоненти можуть генерувати дані а не перетворювати їх, як у випадку пристроїв вводу. Опис архітектури Опис архітектури задіює принципи і практики моделювання та представлення архітектур, використовуючи такі механізми як: мови опису архітектури (), точки зору на архітектуру () та архітектурні каркаси (). Мови опису архітектури Більшість робіт на тему архітектури опублікованих наприкінці 1990-х стосувалися мов опису архітектури (, ADL). Мова опису архітектури - це мова що дозволяє явний опис архітектури, включаючи щонайменше компоненти, їх інтерфейси, конектори та конфігурацію архітектури. Приклади: Unicon Точки зору на архітектуру thumb|264px|. Описи архітектури часто організовуються в , які є аналогами до різних типів що створюються в архітектурі будівель. Популярними моделями точок зору на архітектуру є , каталог точок зору та перспектив, та IBM views & viewpoint model. Архітектурні каркаси Методології проєктування Ранні дослідження архітектури зосереджувались на методології проєктування систем. Наприклад об'єктно-орієнтований дизайн намагається структурувати проблеми так що вони розв'язуються архітектурою на основі об'єктів. Однією з перших методологій яка підкреслила проєктування саме на рівні архітектури була . Приклади архітектурних моделей і стилів Архітектура класної дошки Клієнт-серверна архітектура Архітектури, побудовані навколо бази даних (Database-centric architecture) Розподілені обчислення Подієва архітектура Front end та back end Неявні виклики (Implicit invocations) Монолітний застосунок (Monolithic application) Peer-to-peer Пайпи і фільтри () Plugin Representational State Transfer Rule evaluation Пошук-орієнтована архітектура Сервіс-орієнтована архітектура Shared nothing architecture Software componentry Space based architecture Структурована Багаторівнева Див. також Архітектура комп'ютера Архітектура підприємства Системна архітектура Примітки Література Лаврищева Катерина Михаліївна Підручник \"Програмна інженерія\" Эммерих В. Конструирование распределенных объектов. Методы и средства программирования интероперабельных объектов в архитектурах OMG/CORBA, Microsoft COM и Java RMI. – М.: Мир, 2002. –510 с. Боггс У., Боггс М. UML Rational Rose. Бестселлер #, Лори.– Москва, 2000.-580 с. http://www.dossier-andreas.net/software_architecture/ Категорія:Програмування Категорія:Розробка програмного забезпечення Категорія:Архітектура програмного забезпечення Категорія:Едсгер Дейкстра"}
{"category": "Програмування", "title": "Асинхронне програмування", "abstract": "Асинхронність — це процес обробки введення/виводу, що дозволяє продовжити обробку інших завдань, не чекаючи завершення попереднього завдання.\nКомп'ютерні програми часто мають справу з тривалими процесами. Наприклад, отримання даних з бази даних або виконання складних обчислень. Поки виконується одна операція, можна було б завершити ще кілька. А бездіяльність призводить до зниження продуктивності. Асинхронне програмування збільшує ефективність, тому що не дозволяє блокувати основний потік виконання.", "content": "Асинхронність — це процес обробки введення/виводу, що дозволяє продовжити обробку інших завдань, не чекаючи завершення попереднього завдання. Комп'ютерні програми часто мають справу з тривалими процесами. Наприклад, отримання даних з бази даних або виконання складних обчислень. Поки виконується одна операція, можна було б завершити ще кілька. А бездіяльність призводить до зниження продуктивності. Асинхронне програмування збільшує ефективність, тому що не дозволяє блокувати основний потік виконання. Асинхронне програмування У синхронному коді кожна операція чекає закінчення попередньої. Тому вся програма може «зависнути», якщо одна з команд виконується дуже довго. Асинхронний код прибирає операцію, яка блокує основний потік програми, так що основний потік не блокується, і програма може виконувати інші операції. Асинхронне програмування успішно вирішує безліч завдань. Одна з найважливіших — користувач може взаємодіяти з програмою, поки виконується інше завдання. Візьмемо для прикладу додаток, який підбирає серіали за зазначеними критеріями. Після того, як користувач обрав параметри, по яким буде відбуватися пошук, програма відправляє запит на сервер. А там здійснюється пошук вказаних фільмів. Обробка може тривати доволі тривалий час. Якщо додаток працює синхронно, то користувач не зможе взаємодіяти зі сторінкою, поки не прийде результат. В цьому випадку головний потік виконання поділяється на дві гілки. Одна з них продовжує займатися інтерфейсом, а інша виконує запит. 585x585px|міні|Приклад роботи асинхронного та синхронного коду|альт=|центр Коли мова заходить про асинхронність, слід розглянути також такі поняття: конкурентність, паралелізм і багатопотоковість. Всі вони пов'язані з одночасним виконанням завдань, проте це не одне і те ж. Конкурентність Поняття конкурентного виконання найзагальніше. Воно буквально означає, що безліч завдань вирішуються в один час. Можна сказати, що в програмі є кілька логічних потоків ‒ по одному на кожну задачу. Потоки можна опрацьовувати одночасно фізично, проте це не обов'язково. Завдання при цьому не пов'язані одне з одним. Отже, не має значення, яке завдання завершиться раніше, а яке пізніше. Паралелізм Паралельне виконання зазвичай використовується для поділу одного завдання на частини, щоб пришвидшити обчислення. Наприклад, потрібно зробити кольорове зображення чорно-білим. Обробка верхньої половини не відрізняється від обробки нижньої. Отже, можна розділити цю задачу на дві частини і роздати їх різним потокам, щоб пришвидшити виконання в два рази. Наявність двох фізичних потоків тут принципово важливо, так як на комп'ютері з одним процесорним ядром такий прийом провести неможливо. Багатопотоковість Тут потік є абстракцією, під якою може ховатися і окреме ядро процесора, і віртуальне ядро. Деякі мови навіть мають власні об'єкти потоків. Таким чином, ця концепція може мати різну реалізацію. центр|міні|555x555px|Принцип роботи конкуренції та паралелізму Шаблони асинхронності Можна виділити три найпопулярніші схеми асинхронних запитів. центр|міні|733x733пкс|Графічне зображення роботи трьох типів асинхронних запитів|альт= Послідовне виконання Використовується для пов'язаних завдань, які потрібно запускати один за одним. Наприклад, перший запит отримує назви фільмів, а другий ‒ інформацію про них. Паралельне виконання Застосовується для вирішення незалежних завдань, коли важливо, щоб виконалися всі запити. Наприклад, дані вебсторінки вантажаться з трьох серверів, а після цього починається рендеринг. Конкурентне виконання Використовується для вирішення незалежних завдань, коли важливо, щоб виконався хоча б один запит. Наприклад, відправлення ідентичних запитів на різні сервери. Категорія:Програмування"}
{"category": "Програмування", "title": "Баг", "abstract": "Баґ або баг (англ. bug — «жук, комашка») — помилка, вада або дефект в комп'ютерній програмі або системі, що викликає в ній неправильний або неочікуваний результат чи неочікувану поведінку. Термін зазвичай використовується стосовно помилок, котрі виявляються на стадії роботи програми, на відміну від помилок проєктування чи синтаксичних помилок. «Баґи» або «баги» локалізуються та виправляються у процесі тестування та доробки програми.", "content": "Баґ або багБудз, А. В., & Кульчицька, О. О. СПОСОБИ ПЕРЕКЛАДУ КОМП'ЮТЕРНОГО ІГРОВОГО СЛЕНГУ. Актуальні проблеми сучасної іноземної філології: Студентський науковий вісник.–Рівне: РДГУ, 2018.–250 с. Редакційна колегія: Михальчук НО, доктор психологічних наук, завідувач кафедри практики англійської мови, РДГУ, 133. «Bug — „баґ“ або „баг“, помилка .., що призводить до збою у роботі;» ( — «жук, комашка») — помилка, вада або дефект в комп'ютерній програмі або системі, що викликає в ній неправильний або неочікуваний результат чи неочікувану поведінку. Термін зазвичай використовується стосовно помилок, котрі виявляються на стадії роботи програми, на відміну від помилок проєктування чи синтаксичних помилок. «Баґи» або «баги» локалізуються та виправляються у процесі тестування та доробки програми. Етимологія thumbnail|250px|Запис в журналі про «перший справжній баґ» 1947 року. В англійській мові вживання терміна bug у значенні «хиба або технічні труднощі» було започатковано Томасом Едісоном ще у 1870-х. Реклама першої механічної пінбольної машини 1931 року повідомляла про відсутність «баґів» у цій грі. Протягом Другої світової війни словом «bugs» позначались проблеми з військовим спорядженням. За легендою, 9 вересня 1945 року вчені Гарвардського університету, що тестували обчислювальну машину Mark II Aiken Relay Calculator, знайшли метелика, що застряг між контактами електромеханічного реле й Ґрейс Гоппер вжила цей термін. Знайдена комаха була вклеєна до технічного щоденника, з супроводжувальним написом: «Перший справжній випадок віднайдення комахи» (). Гра слів щодо значень «комаха» і «хиба» зумовила популярність цієї історії. За іншими даними, це сталось 9 вересня 1947, а не 1945 року. Див. також Зависання Дебагінг Примітки Посилання Термінологічна лексика в системі професійного мовлення / Г. Л. Вознюк, С. З. Булик-Верхола, М. В. Гнатюк та ін. — Львів: Видавництво Національного університету «Львівська політехніка», 2010. — 92 с. Оптимізація процесу тестування програмного забезпечення з великою кількістю вхідних параметрів / Ю. В. Поремський, О. В. Васьковський, А. С. Сотнікова // Вимірювальна та обчислювальна техніка в технологічних процесах . — 2013. — № 4. — С. 87-91. Категорія:Програмування Категорія:Якість програмного забезпечення Категорія:Помилки програмування Категорія:Сленг програмістів"}
{"category": "Програмування", "title": "Багатозадачність", "abstract": "Багатозадачність (англ. multitasking) — властивість операційної системи або середовища програмування забезпечувати можливість паралельної (або псевдопаралельної) обробки декількох процесів. На комп'ютерах з одним одноядерним процесором одночасно може виконуватись лише одна задача, тому багатозадачність організовується через розподілення часу виконання задачі на процесорі. Справжня багатозадачність операційної системи можлива тільки в багатопроцесорних, або кількаядерних системах, або в розподілених обчислювальних системах.", "content": "Багатозадачність () — властивість операційної системи або середовища програмування забезпечувати можливість паралельної (або псевдопаралельної) обробки декількох процесів. На комп'ютерах з одним одноядерним процесором одночасно може виконуватись лише одна задача, тому багатозадачність організовується через розподілення часу виконання задачі на процесорі. Справжня багатозадачність операційної системи можлива тільки в багатопроцесорних, або кількаядерних системах, або в розподілених обчислювальних системах. Властивості багатозадачного середовища Примітивні багатозадачні середовища забезпечують чисте «розділення ресурсів», коли за кожним завданням закріплюється певна ділянка пам'яті, і завдання активізується в строго певні інтервали часу. Розвиненіші багатозадачні системи проводять розподіл ресурсів динамічно, коли завдання стартує в пам'яті або покидає пам'ять залежно від її пріоритету і від стратегії системи. Таке багатозадачне середовище володіє такими особливостями: Кожне завдання має свій пріоритет, відповідно до якого отримує час і пам'ять Система організовує черги завдань так, щоб всі завдання отримали ресурси, залежно від пріоритетів і стратегії системи Система організовує обробку переривань, за яких завдання можуть активуватися, деактивуватися і віддалятися Після закінчення покладеного кванта часу завдання може тимчасово викидатися з пам'яті, віддаючи ресурси іншим завданням, а потім через визначений системою час, відновлюватися в пам'яті (свопінг) Система забезпечує захист пам'яті від несанкціонованого втручання інших завдань Система розпізнає збої й зависання окремих завдань і припиняє їх Система вирішує конфлікти доступу до ресурсів і пристроїв, не допускаючи тупикових ситуацій загального зависання від очікування заблокованих ресурсів Система гарантує кожному завданню, що рано чи пізно його буде активовано Система обробляє запити реального часу Система забезпечує комунікацію між процесами Труднощі реалізації багатозадачного середовища Основною трудністю реалізації багатозадачного середовища є її надійність, виражена в захисті пам'яті, обробці збоїв і переривань, оберіганні від зависань і тупикових ситуацій. Окрім надійності, багатозадачне середовище має бути ефективним. Витрати ресурсів на її підтримку не повинні заважати процесам проходити, уповільнювати їхню роботу, різко обмежувати пам'ять. Історія багатозадачних операційних систем Спочатку реалізація багатозадачних операційних систем була серйозною технічною трудністю, тому впровадження багатозадачних систем затягувалося, а користувачі довгий час після впровадження віддавали перевагу однозадачним. Надалі, після появи кількох вдалих рішень, багатозадачні середовища стали удосконалюватися, і в наш час уживаються повсюдно. Однією з перших багатозадачних систем була OS/360 (1966 Mealy G.H., Witt B.I., Clark W.A. The functional structure of OS/360, IBM Systems Journal, 5, #1, 1966), використовувана для комп'ютерів фірми IBM і їхніх радянських аналогів ЄС ЕОМ. Розробки системи були сильно затягнуті, і на початковий час фірма IBM висунула однозадачний DOS/360, щоб задовольнити замовників до повної здачі OS/360 в експлуатацію. Систему розкритикували через низьку надійність і важкість в експлуатації. У 1969 році з'явилася система UNIX з першим досить акуратним алгоритмічним розв'язанням проблеми багатозадачності. В наш час на базі UNIX створені десятки операційних систем. На комп'ютерах PDP-11 і їх радянських аналогах СМ-4 використовувалася багатозадачна система RSX-11 (радянський аналог ОС РВ), і система розподілу часу TSX-PLUS, що забезпечує обмежені можливості багатозадачності й розрахований на багато користувачів режим розділення часу, що емулював для кожного користувача однозадачну RT-11 (радянський аналог РАФОС). Останнє рішення було вельми популярне через низьку ефективність і надійність повноцінної багатозадачної системи. Акуратним рішенням виявилася операційна система VMS, розроблена спочатку для комп'ютерів VAX (радянський аналог — СМ-1700) як розвиток RSX-11. Перший у світі мультимедійний персональний комп'ютер Amiga 1000 (1984 р.) спочатку проєктувався з розрахунком на повну апаратну підтримку витискальної багатозадачності реального часу в ОС AmigaOS. У цьому випадку розробка апаратної й програмної частини велася паралельно, це привело до того, що за показником квантування планувальника багатозадачності (1/50 секунди на перемикання контексту) AmigaOS довгий час залишалася неперевершеною серед персональних комп'ютерів. Багатозадачність забезпечувала також фірма Microsoft в операційних системах Windows. При цьому Microsoft вибрала дві лінії розробок — на базі Windows 0.9 (яка після довгого допрацювання початкової системи кооперативної багатозадачності, аналогічної Mac OS, згодом вилилася в лінійку Windows 9x), і Windows NT, на основі ідей, закладених у VMS. Використання досвіду VMS забезпечило системам істотно вищу продуктивність і надійність. За часом перемикання контексту багатозадачності (квантування) тільки ці операційні системи можуть бути порівнянні з AmigaOS і UNIX (а також його нащадками, такими, як ядро Linux). Примітки Див. також Паралелізм (інформатика) Багатонитковість М'ютекс Семафор (програмування) Категорія:Технології операційних систем Категорія:Архітектура комп'ютера Категорія:Програмування Категорія:Конкурентні обчислення"}
{"category": "Програмування", "title": "Безумовний перехід", "abstract": "Безумовний перехід (англ. unconditional branch) - перехід у певну точку програми без перевірки виконання будь-яких умов. В багатьох мовах програмування такому переходу відповідає спеціальна інструкція goto, в деяких BRANCH або JUMP.\nУ мові асемблера безумовні й умовні переходи належать до найвживаніших інструкцій. Безумовні переходи широко використовувалися в деяких ранніх мовах програмування високого рівня, наприклад, BASIC, COBOL, Фортран. Проте з ростом складності і розміру програм та розвитком структурного програмування використання цієї інструкції стало небажаним через ризик виникнення помилок і плутанини, що виникає в процесі програмування з її використанням. В 1968 Едсгер Дейкстра написав листа до Communications of the ACM (CACM) під початковою назвою «Справа проти інструкції GO TO». CACM перейменував лист у «Інструкція Go To вважається шкідливою». Нині використання оператора безумовного переходу вважають поганим стилем програмування, а в деяких сучасних мовах високого рівня він взагалі не підтримується (наприклад, у Java).\nУ невеликих програмах, goto може полегшити і спростити написання програмного коду. Хоча зазвичай її використання можна замінити іншими інструкціями, наприклад, циклом.\nЗловживання операціями безумовного переходу у високорівневих мовах зазвичай називають \"кодом-спагеті\".", "content": "Безумовний перехід () - перехід у певну точку програми без перевірки виконання будь-яких умов. В багатьох мовах програмування такому переходу відповідає спеціальна інструкція goto, в деяких BRANCH або JUMP . У мові асемблера безумовні й умовні переходи належать до найвживаніших інструкцій. Безумовні переходи широко використовувалися в деяких ранніх мовах програмування високого рівня, наприклад, BASIC, COBOL, Фортран. Проте з ростом складності і розміру програм та розвитком структурного програмування використання цієї інструкції стало небажаним через ризик виникнення помилок і плутанини, що виникає в процесі програмування з її використанням. В 1968 Едсгер Дейкстра написав листа до Communications of the ACM (CACM) під початковою назвою «Справа проти інструкції GO TO». CACM перейменував лист у «Інструкція Go To вважається шкідливою». Нині використання оператора безумовного переходу вважають поганим стилем програмування, а в деяких сучасних мовах високого рівня він взагалі не підтримується (наприклад, у Java). У невеликих програмах, goto може полегшити і спростити написання програмного коду. Хоча зазвичай її використання можна замінити іншими інструкціями, наприклад, циклом. Зловживання операціями безумовного переходу у високорівневих мовах зазвичай називають \"кодом-спагеті\". Приклад програми з безумовним переходом Нижче наведено cирцевий код програми на мові програмування C++, для знаходження N-го числа Фібоначчі: #include <iostream> using namespace std; int main() { int N; cout << \"Задайте номер N: \"; cin >> N; int a = 1, b = 0, c; label: // Мітка (місце в програмі куди здійснюється перехід) if (N == 0) { cout << \"Шукане число: \" << a << endl; return 0; } N--; c = b; b = a; a += c; goto label; // Оператор переходу } Порівняння з програмою без безумовного переходу На думку Дейкстри, люди краще розуміють статичні зв'язки ніж динамічні, бо останні вимагають постійної зміни розуміння. Отже, легше зрозуміти як програма працює в термінах властивостей програми ніж через те як програма виконується. В першому випадку знання як працює програма залишається дійсним допоки хтось не змінить код програми, але в другому випадку воно може змінюватись за кожного запуску програми. Щоб розуміти значення властивостей програми для можливості вказати на точку в програмі і подумати: «Кожного разу коли програма дістається цього місця певні умові істині», розглянемо приклад: if (n < 0) n = 0; Припустимо, що n це змінна вбудованого числового типу, ми знаємо, що по виконанні цього коду вона невід'ємна. А тепер розгляньмо переписану ділянку коду: if (n >= 0) goto nonneg; n = 0; nonneg: ; Теоретично, змінений код має працювати так само. Однак, змінилось дещо важливе: тепер існує можливість передати керування до nonneg з іншого місця в програмі. Інакше кажучи, ми більше не можемо сказати, що по досягненні наступної за цим шматком коду інструкції n невід'ємне. Також goto ускладнює можливість зрозуміти програму статично через ускладнення розуміння який поступ відбувся в програмі під час виконання. Якщо програма використовує лише структури керування подібні до if і while, то можна говорити про те, який шлях виконання обрав кожен if і скільки разів було виконано тіло кожного while, і так вибудувати повну історію виконання програми. Така картина дає нам можливість зрозуміти програму через твердження такі як «Кількість ітерацій у циклі однакова з кількістю записів на вході». goto ускладнює відстеження виконання програми, бо немає можливості сказати як сильно кожне goto може змінити перебіг програми. Як наслідок, історія виконання програми стає складнішою для описання. Обидва ці ризики інструкції goto впливають на нашу здатність розмірковувати про програму, особливо на можливість зрозуміти динамічну поведінку програми через використання статичних тверджень. Джерела Категорія:Програмування Категорія:Едсгер Дейкстра Категорія:Статті з прикладами коду мовою C"}
{"category": "Програмування", "title": "Бета-версія", "abstract": "Бета-версія — версія програми, яка була протестована внутрішньо, і тепер потребує перевірки більш широким колом користувачів. Іде після альфа-версії; раніше називалася «реліз-кандидат». Терміни «альфа» і «бета» походять від назв перших двох літер в грецькому алфавіті: α (альфа) і β (бета).\nРеліз-кандидатом або попередньою версією іноді називають гамма-версію, а офіційна версія називається «омега-версія». Іноді після реліз-кандидату далі ідуть номера: Реліз-кандидат 2 (RC2) = дельта-версія, Реліз-кандидат 3 (RC3) = епсилон-версія, і т. д.\nБета-версія програми ще не достатньо стабільна, щоб бути запущеною у виробництво, але вже (частково) функціональна. Бета-версії часто поширюються серед обраної групи користувачів для тестування. Це закрите бета-тестування (англ. closed beta). А якщо бета-тестування відкрите для кожного користувача, то це відкрите бета-тестування (open beta).\nДля участі в таких тестуваннях може знадобитися бета-ключ. Це робиться, наприклад, в онлайн-іграх. Це код, який дає доступ до бета-тестування. Для популярних ігор цей бета-ключ є доволі цінним, оскільки в цьому бета-тестуванні хочуть взяти участь багато людей. Бета-ключі для ігор компанії Blizzard Entertainment іноді продаються досить дорого ($ 400 — $ 1000) на сайті eBay.", "content": "Бета-версія — версія програми, яка була протестована внутрішньо, і тепер потребує перевірки більш широким колом користувачів. Іде після альфа-версії; раніше називалася «реліз-кандидат». Терміни «альфа» і «бета» походять від назв перших двох літер в грецькому алфавіті: α (альфа) і β (бета). Реліз-кандидатом або попередньою версією іноді називають гамма-версію, а офіційна версія називається «омега-версія». Іноді після реліз-кандидату далі ідуть номера: Реліз-кандидат 2 (RC2) = дельта-версія, Реліз-кандидат 3 (RC3) = епсилон-версія, і т. д. Бета-версія програми ще не достатньо стабільна, щоб бути запущеною у виробництво, але вже (частково) функціональна. Бета-версії часто поширюються серед обраної групи користувачів для тестування. Це закрите бета-тестування (). А якщо бета-тестування відкрите для кожного користувача, то це відкрите бета-тестування (). Для участі в таких тестуваннях може знадобитися бета-ключ. Це робиться, наприклад, в онлайн-іграх. Це код, який дає доступ до бета-тестування. Для популярних ігор цей бета-ключ є доволі цінним, оскільки в цьому бета-тестуванні хочуть взяти участь багато людей. Бета-ключі для ігор компанії Blizzard Entertainment іноді продаються досить дорого ($ 400 — $ 1000) на сайті eBay.Starcraft II beta accounts fetching astronomical prices , Yahoo! Games, 22 лютого 2010. Див. також Альфа-версія Бета-тестування Посилання Категорія:Програмування"}
{"category": "Програмування", "title": "Бета-тестування", "abstract": "Бета-тестування (англ. beta testing) або випробування — інтенсивне використання майже готової версії продукту (як правило, програмного або апаратного забезпечення) з метою виявлення максимального числа помилок в його роботі для їх подальшого усунення перед остаточним виходом (релізом) продукту на ринок, до масового споживача.\nНа відміну від альфа-тестування, що проводиться силами штатних розробників або тестувальників, бета-тестування передбачає залучення добровольців з числа звичайних майбутніх користувачів продукту, яким доступна згадана попередня версія продукту (так звана бета-версія). Рушієм таких добровольців (їх називають бета-тестерами) є цікавість до нового продукту — цікавість, заради задоволення якого вони цілком згодні миритися з можливістю випробувати наслідки ще не знайдених (а тому й не виправлених) помилок.\nКрім того, бета-тестування може використовуватися як частина стратегії просування продукту на ринок (наприклад, безкоштовна роздача бета-версій дозволяє залучити увагу споживачів до остаточної дорогої версії продукту), а також для одержання попередніх відгуків про неї від широкого кола майбутніх користувачів.", "content": "Бета-тестування () або випробування — інтенсивне використання майже готової версії продукту (як правило, програмного або апаратного забезпечення) з метою виявлення максимального числа помилок в його роботі для їх подальшого усунення перед остаточним виходом (релізом) продукту на ринок, до масового споживача. На відміну від альфа-тестування, що проводиться силами штатних розробників або тестувальників, бета-тестування передбачає залучення добровольців з числа звичайних майбутніх користувачів продукту, яким доступна згадана попередня версія продукту (так звана бета-версія). Рушієм таких добровольців (їх називають бета-тестерами) є цікавість до нового продукту — цікавість, заради задоволення якого вони цілком згодні миритися з можливістю випробувати наслідки ще не знайдених (а тому й не виправлених) помилок. Крім того, бета-тестування може використовуватися як частина стратегії просування продукту на ринок (наприклад, безкоштовна роздача бета-версій дозволяє залучити увагу споживачів до остаточної дорогої версії продукту), а також для одержання попередніх відгуків про неї від широкого кола майбутніх користувачів. Українськомовна форма Українські розробники пропонують використовувати замість англомовної форми слово випроба. Слово відповідає процесові відкритого випробування певного продукту, є лаконічним і усталеним в українській академічній термінології ще 20-х років XX сторіччя. Щоправда, останнім часом не входило до вжитку. Посилання Випроба замість beta-testing Див. також Стадії розробки програмного забезпечення Примітки Категорія:Програмування Категорія:Тестування програмного забезпечення Категорія:Програмна інженерія"}
{"category": "Програмування", "title": "Бібліотека підпрограм", "abstract": "Бібліотека (від англ. library) — збірка об'єктів чи підпрограм для вирішення близьких за тематикою задач. У залежності від мови програмування бібліотеки містять об'єктні модулі чи початковий код та дані, допоміжні для задіяння та інтеграції нових можливостей в програмні рішення.\nБібліотека може означати те саме, що модуль, або декілька модулів.\nЗ точки зору комп'ютерних наук бібліотеки діляться на статичні та динамічні.", "content": "Бібліотека (від ) — збірка об'єктів чи підпрограм для вирішення близьких за тематикою задач. У залежності від мови програмування бібліотеки містять об'єктні модулі чи початковий код та дані, допоміжні для задіяння та інтеграції нових можливостей в програмні рішення. Бібліотека може означати те саме, що модуль, або декілька модулів. З точки зору комп'ютерних наук бібліотеки діляться на статичні та динамічні. Статичні бібліотеки Можуть бути у вигляді початкового тексту, що підключається програмістом до своєї програми на етапі написання (наприклад, для мови Fortran існує величезна кількість бібліотек для вирішення різних завдань саме в початкових текстах), або у вигляді об'єктних файлів, що приєднуються (лінкуються) до виконуваної програми на етапі компіляції (у Microsoft Windows такі файли мають розширення .lib, у UNIX-подібніх ОС — зазвичай .a). В результаті програма включає всі необхідні функції, що робить її автономною, але збільшує розмір. Динамічні бібліотеки Також називаються розподілюваними бібліотеками (), або бібліотеками, що динамічно підключаються (, DLL). Це окремі файли, що надають програмі набір використовуваних функцій для завантажування на етапі виконання при зверненні програми до ОС із заявкою на виконання функції з бібліотеки. Якщо необхідна бібліотека вже завантажена в оперативну пам'ять, програма використовуватиме завантажену копію бібліотеки. Такий підхід дозволяє зекономити час і пам'ять, оскільки декілька програм використовують одну копію бібліотеки, вже завантажену в пам'ять. Динамічні бібліотеки зберігаються зазвичай у визначеному місці й мають стандартне розширення. Наприклад, файли .library у логічному томі Libs: у AmigaOS; у Microsoft Windows і OS/2 файли бібліотек загального користування мають розширення .dll; у UNIX-подібних ОС — зазвичай .so; у MacOS — .dylib. При написанні програми програмістові досить вказати транслятору мови програмування (компілятору або інтерпретатору), що слід підключити таку-от бібліотеку і використовувати таку-от функцію зі вказаної бібліотеки. Ні початковий текст, ні виконуваний код функції до складу програми не входить. Див. також Каркас (програмування) Категорія:Програмування Категорія:Файли Категорія:Технології операційних систем"}
{"category": "Програмування", "title": "Блок (програмування)", "abstract": "Блок в програмуванні (англ. block) — замкнена складова частина програми, яка являє собою сукупність інструкцій, які утворюють сферу дії деяких ідентифікаторів (імен). Блоки є одним з головних елементів структурного програмування.\nПоняття «блок» відповідає поняттю «підзадача» або «підалгоритм». Використовуючи блоки, можна розділити задачу на частини, які допускають автономне програмування.\nКожен блок вводить новий рівень позначень шляхом описання ідентифікаторів і міток. В блоці може міститись як оператор інший блок.\nУ багатьох сучасних мовах програмування блоки використовуються для описання тіла процедур, циклів, для визначення дій в операторах умовного переходу, а також можуть використовуватися самі по собі.", "content": "Блок в програмуванні () — замкнена складова частина програми, яка являє собою сукупність інструкцій, які утворюють сферу дії деяких ідентифікаторів (імен). Блоки є одним з головних елементів структурного програмування. Поняття «блок» відповідає поняттю «підзадача» або «підалгоритм». Використовуючи блоки, можна розділити задачу на частини, які допускають автономне програмування. Кожен блок вводить новий рівень позначень шляхом описання ідентифікаторів і міток. В блоці може міститись як оператор інший блок. У багатьох сучасних мовах програмування блоки використовуються для описання тіла процедур, циклів, для визначення дій в операторах умовного переходу, а також можуть використовуватися самі по собі. Історія Ідеї щодо структурних блоків програми з'явилися у 1950-х роках при розробці перших автокодів, і були формалізовані з публікацією звітів про мови програмування Algol 58 і Algol 60. У Algol 58 було представлено поняття «комбінованого оператора» (), тісно пов'язаного з потоком виконання. Наступний «Доопрацьований звіт» () з описом синтаксису і семантики мови Algol 60 ввів поняття блоку і області видимості блоку (); блок складався з «послідовності декларацій, за якою слідує послідовність операторів; блок міститься між ключовими словами begin і end...», а «... кожна декларація у блоці є дійсною лише для даного блоку». Джерела інформації Енциклопедія кібернетики, Халілов А. І., т. 1, с. 166. Див. також Область видимості (програмування) Замикання (програмування) Потік керування Локальна змінна Категорія:Програмування"}
{"category": "Програмування", "title": "Вбудована програма", "abstract": "Вбудована програма або прошивка (англ. firmware) — комп'ютерна програма, вбудована («вшита») в апаратний пристрій. Термін інколи використовується для позначення фіксованих, як правило, досить невеликих, програм, що контролюють різні електронні пристрої. Найчастіше фізичний носій вбудованої програми — мікросхема пам'яті постійного зберігання, така як флешпам'ять або EPROM.\nТипові приклади — від кінцевих продуктів для користувача, таких як телевізор, пральна машина, мікрохвильова піч, дистанційне керування і калькулятори, до комп’ютерних частин та пристроїв, таких як BIOS, модем, жорсткий диск і клавіатура, монітор і карта пам'яті, до наукових приладів та промислових роботів. Крім того, складніші споживчі пристрої, як, наприклад, мобільний телефон, цифрова камера і синтезатор тощо, містять вбудовані програмні засоби, що забезпечують виконання як основних дій, так і функцій вищого рівня.\nПриродно, немає чітко визначеної межі між вбудованими програмами та просто програмним забезпеченням, оскільки обидва терміни — позначають досить гнучкі поняття. Разом з тим, вбудовані програми завжди пов’язані з досить низьким базовим рівнем операцій у пристрої, без якого пристрій буде абсолютно нефункціональним.\nПрості вбудовані програми, як правило, розташовано в пам’яті тільки для читання або PROM, в той час як складніші вбудовані програми часто використовують флешпам'ять, що дозволяє їх оновлення. Найпоширеніші причини для оновлення вбудованих програм — виправлення помилок та додавання функцій пристрою. Це, здебільшого, включає завантаження двійкового файлу образу, наданого виробником пристрою, згідно з конкретною процедурою, що інколи виконується кінцевим користувачем.", "content": "frame|right|Пульт дистанційного керування телевізора містить мікроконтролер з вбудованою програмою Вбудована програма або прошивка () — комп'ютерна програма, вбудована («вшита») в апаратний пристрій. Термін інколи використовується для позначення фіксованих, як правило, досить невеликих, програм, що контролюють різні електронні пристрої. Найчастіше фізичний носій вбудованої програми — мікросхема пам'яті постійного зберігання, така як флешпам'ять або EPROM. Типові приклади — від кінцевих продуктів для користувача, таких як телевізор, пральна машина, мікрохвильова піч, дистанційне керування і калькулятори, до комп’ютерних частин та пристроїв, таких як BIOS, модем, жорсткий диск і клавіатура, монітор і карта пам'яті, до наукових приладів та промислових роботів. Крім того, складніші споживчі пристрої, як, наприклад, мобільний телефон, цифрова камера і синтезатор тощо, містять вбудовані програмні засоби, що забезпечують виконання як основних дій, так і функцій вищого рівня. Природно, немає чітко визначеної межі між вбудованими програмами та просто програмним забезпеченням, оскільки обидва терміни — позначають досить гнучкі поняття. Разом з тим, вбудовані програми завжди пов’язані з досить низьким базовим рівнем операцій у пристрої, без якого пристрій буде абсолютно нефункціональним. Прості вбудовані програми, як правило, розташовано в пам’яті тільки для читання або PROM, в той час як складніші вбудовані програми часто використовують флешпам'ять, що дозволяє їх оновлення. Найпоширеніші причини для оновлення вбудованих програм — виправлення помилок та додавання функцій пристрою. Це, здебільшого, включає завантаження двійкового файлу образу, наданого виробником пристрою, згідно з конкретною процедурою, що інколи виконується кінцевим користувачем. Сучасні вбудовані програми Вбудована програма тепер означає майже будь-який зміст апаратного пристрою, що програмується, тобто не лише машинний код для мікропроцесора, а й також конфігурація і дані для інтегральних схем конкретного застосування, програмовних логічних пристроїв тощо. Хоча сучасні пристрої, які дозволяють оновлення, як правило, забезпечують для цього напівавтоматичний спосіб, в деяких випадках потрібно заміняти накопичувач даних (що було типовою процедурою до середини 1990-х років). Комп'ютерна периферія Більшість комп'ютерних периферійних пристроїв є самі по собі спеціальними комп'ютерами. Хоча зовнішні пристрої зберігають вбудовані програми всередині, сучасні комп’ютерні периферійні картки, як правило, вимагають завантаження досить великої частини вбудованої програми з головного комп’ютера при запуску, оскільки така процедура є гнучкішою. Такі пристрої можуть бути серйозно обмежені у функціонуванні, поки головний комп’ютер не надасть необхідні прошивки. Часто це робиться за допомогою конкретного драйвера пристрою (чи, якщо точніше, підсистемою всередині драйвера). Сучасні драйвери пристроїв можуть також надавати прямий користувацький інтерфейс для конфігурації на додаток до основних викликів операційної системи та прикладного програмного інтерфейсу. Проблеми вбудованих програм на ПК В багатьох випадках, компоненти прошивки так само важливі, як і операційна система в комп’ютері. Однак, на відміну від більшості сучасних операційних систем, вбудовані програми рідко мають добре розвинутий механізм для оновлення та усування проблем функціонування, яких було виявлено після постачання обладнання. BIOS можна досить просто оновити в сучасних ПК; такі пристрої як відеокарти або модеми часто залежать від динамічного завантаження вбудованих програм за допомогою драйвера і таким чином, оновлення може бути зроблено прозоро через механізм оновлення операційної системи. На відміну від цього, програми, вбудовані в пристроях накопичення інформації, оновлюються рідко; механізми для виявлення версії прошивки та її оновлення не стандартизовано. Тому ці пристрої, як правило, мають вищий рівень функціональних проблем, у порівнянні з іншими частинами сучасної комп’ютерної системи. Приклади Приклади вбудованих програм: Системи керування і відліку часу для пральних машин BIOS та UEFI в IBM-сумісних персональних комп’ютерах Open Firmware, що використовується в комп’ютерах Sun Microsystems та Apple Computer ARCS, що використовується в комп’ютерах Silicon Graphics Run-Time Abstraction Services (служби абстрагування для часу виконання), що використовуються в комп'ютерах IBM System i та IBM System p Чипи EPROM, що використовуються в серії цифрових музичних процесорів Eventide H-3000. Cisco IOS Несанкціоновані зміни вбудованих програм Деколи з’являються неофіційні нові або змінені версії прошивки, створені третіми сторонами для забезпечення нових функцій або розблокування прихованих. Наприклад Rockbox для цифрового аудіоплеєра, CHDK для цифрових фотоапаратів Canon, а також OpenWRT для бездротових маршрутизаторів, а також багато доморослих проектів для ігрових консолей. Найчастіше розблоковується функціональність загального призначення у пристроях де її обмежено (наприклад, запуск Doom на Ipod). Більшість латок несанкціонованих змін для вбудованих програм є вільним програмним забезпеченням з відкритими сирцевими текстами. Для встановлення і активізації цих змін, як правило, користаються можливостями оновлення вбудованих програм. Однак, деякі зміни вдаються до експлуатації проблем безпеки, оскільки виробник спробував заблокувати апаратні засоби, щоб зупиняти його роботи в разі встановлення неліцензованого коду. Див. також Образ ROM BIOS LinuxBIOS Мікрокод Блоб Джерела Категорія:Вбудовані системи Категорія:Програмування Категорія:Апаратне забезпечення"}
{"category": "Програмування", "title": "Взаємне блокування", "abstract": "Взає́мне блокува́ння (англ. Deadlock) — ситуація, коли кожен із групи процесів очікує на подію, яку може викликати лише інший процес з цієї групи. Часто, така ситуація спостерігається в парадоксах типу «Курка чи яйце?». Також зустрічаються назви тупикова ситуація, тупик, клінч. В англомовній літературі ця ситуація має назву англ. deadlock (вимовляється як дедлок).\nУ галузі інформаційних технологій, взаємним блокуванням називають ситуацію, коли два або більше процесів чекають поки інший не звільнить певний ресурс, або коли більше ніж два процеси чекають на звільнення ресурсів у замкненому ланцюгу.\nЯк приклад схожої ситуації можна навести двох чоловіків, що креслять схеми, маючи лише одну лінійку та один олівець. Якщо один з чоловіків візьме лінійку, а інший олівець, між ними виникає ситуація взаємного блокування коли для того, аби звільнити лінійку треба олівець, а для звільнення олівця треба лінійка.\nВзагалі кажучи, блокуванням (або зависанням) є така ситуація, коли не залежно від того, скільки сплине часу, жоден прехід із одного стану в інший відбутись не може.", "content": "thumb|right|200px Взає́мне блокува́ння () — ситуація, коли кожен із групи процесів очікує на подію, яку може викликати лише інший процес з цієї групи.(Таненбаум 2002), глава 3 , стор. 188.(Abraham 2005), глава 7, стор. 246. Часто, така ситуація спостерігається в парадоксах типу «Курка чи яйце?». Також зустрічаються назви тупикова ситуація, тупик, клінч. В англомовній літературі ця ситуація має назву (вимовляється як дедлок). У галузі інформаційних технологій, взаємним блокуванням називають ситуацію, коли два або більше процесів чекають поки інший не звільнить певний ресурс, або коли більше ніж два процеси чекають на звільнення ресурсів у замкненому ланцюгу. Як приклад схожої ситуації можна навести двох чоловіків, що креслять схеми, маючи лише одну лінійку та один олівець. Якщо один з чоловіків візьме лінійку, а інший олівець, між ними виникає ситуація взаємного блокування коли для того, аби звільнити лінійку треба олівець, а для звільнення олівця треба лінійка. Взагалі кажучи, блокуванням (або зависанням) є така ситуація, коли не залежно від того, скільки сплине часу, жоден прехід із одного стану в інший відбутись не може.(Bowman, Gomez) розділ 12.2 Умови виникнення взаємного блокування Було показано, що для виникнення ситуації взаємного блокування, необхідно виконання наступних чотирьох умов водночас:(Coffman et al 1971)(Таненбаум 2002), стор. 188—189(Abraham 2005), розділ 7.2, стор. 247—249 Умова взаємного виключення (). Кожен ресурс в поточний момент або зайнятий рівно одним процесом або вільний. Тобто, ресурси знаходяться в режимі ексклюзивного користування. Умова утримання та очікування (). Процеси, що в поточний момент утримують отримані раніше ресурси, можуть робити запити на отримання нових ресурсів. Умова відсутності примусового звільнення ресурсів (). Неможливо примусити процес звільнити раніше отримані ресурси. Процес, що володіє ресурсами, повинен сам їх звільняти. Умова циклічного очікування (). Має існувати кільцева послідовність із двох або більше процесів, кожен із яких очікує на звільнення ресурса, що утримується наступним членом послідовності. Іншими словами, має існувати множина процесів , так, що процес очікує на звільнення ресурів процесу , очікує на , …, очікує на , а очікує на звільнення ресурсів процесом . Для виникнення ситуації взаємного блокування, необхідно виконання всіх чотирьох умов водночас. Якщо хоча б одна з умов не виконується, взаємне блокування неможливе. Livelock Динамічне взаємне блокування чи livelock — це коли стани процесів постійно змінюється один відносно одного — але все одно вони «у безвихідному циклі», що не робить ніякої корисної роботи. Життєвий приклад такої ситуації: двоє зустрічаються у вузькому коридорі. Кожен з них намагається відійти вбік, щоб пропустити іншого, але не можуть розминутись, бо відходять в одну і ту ж сторону одночасно. Моделювання тупикових ситуацій thumb|250px|right|Приклад графу виділення ресурсів. В цьому прикладі всі процеси отримають доступ до необхідних ресурсів, отже, взаємне блокування неможливе. Ситуації взаємного блокування можливо описати точніше з допомогою спеціального засобу — графу виділення ресурсів (). В цьому орієнтованому графі, множина вершин складається із двох підмножин — всіх активних процесів у системі () та існуючих типів ресурсів ().(Holt 1972)(Abraham 2005) розділ 7.2.2, стор. 249.(Таненбаум 2002), стор. 189—192 Ребро від процесу до ресурсу позначається як ; означає, що процес подав запит на одну одиницю ресурсу типу та очікує на цей ресурс (скорочено, ребро запиту). Ребро від ресурсу типу до процесу позначається як ; означає, що одиницю ресурсу типу було надано процесу (скорочено, ребро виділення). Оскільки може існувати декілька одиниць ресурсів одного типу, вершини з ресурсами позначаються у вигляді прямокутників із крапками в середині. Кількість крапок позначає кількість одиниць ресурсу цього типу. Маючи таке визначення графу виділення ресурсів, можна довести, що за умови відсутності циклів в графі жоден із процесів не потрапляє в тупик. За умови наявності циклу в графі, існує можливість для виникнення тупиків. Якщо кожен тип ресурсів має лише один екземпляр, то із наявності циклу випливає наявність тупика. Кожен процес в циклі потрапляє в тупик. Якщо є типи ресурсів з декількома екземплярами, то із наявності циклу наявність тупика не випливає. В цьому випадку наявність циклу є необхідною, але не достатньою умовою для виникнення тупиків. Мережі Петрі В мережах Петрі, тупиком називається така множина позицій, що кожен перехід, який на виході має одну із позицій тупика, використовує будь-яку позицію тупика як вхід. Тобто, якщо всі позиції тупика в деякий момент спорожніють, то вся ця множина позицій залишиться порожньою назавжди. Жоден із переходів не може пересунути фішку в тупик, оскільки в тупику відсутні фішки, які б дозволили перехід, виходом якого є позиція з тупика.(Hack 1972)(Питерсон 1984), розділ 7.4.3, стор. 202—203. Пасткою називається така множина позицій, для якої кожен перехід, входом якого є одна із позицій множини на виході має іншу позицію множини. Тобто, якщо в довільній позиції пастки є фішка, то вона завжди перебуватиме в деякій із позицій пастки. Було доведено, що необхідною і достатньою умовою активності маркованої мережі Петрі з вільним вибором є вимога того, щоб кожен тупик містив пастку з фішкою. Обробка тупикових ситуацій Обробку та поводження із ситуаціями взаємного блокування можна умовно поділити на:(Таненбаум 2002), глава 3, стор. 192. Нехтування проблемою взагалі (т. з. «страусиний алгоритм»). Виявлення та відновлення. Дозволити відбутися взаємному блокуванню, виявити його, та виконати деякі дії. Динамічне уникнення взаємного блокування шляхом правильного розподілу ресурсів. Запобігання шляхом невиконання однієї із чотирьох умов виникнення взаємного блокування. Перший підхід використовується в більшості сучасних операційних систем: правильне поводження у ситуації взаємного блокування є відповідальністю розробника ПЗ.(Abraham 2005), розділ 7.3, стор. 252. Запобігання Як було вказано вище, для виникнення ситуації взаємного блокування необхідне одночасне виконання чотирьох умов. Якщо хоча б одна з них не виконується, то ситуації взаємного блокування виникати не будуть.(Havender 1968)(Таненбаум 2002), стор. 206.(Abraham 2005), розділ 7.4, стор. 253. Нижче наведено описання підходів до кожної з умов. Взаємне виключення Умова взаємного виключення, або екслюзивного користування повинна виконуватись для нероздільних ресурсів. Наприклад, принтер має використовуватись екслюзивно, одним процесом. Однак, деякі роздільні ресурси, такі, як доступ до файлів на читання, можуть роздаватись багатьом процесам. В загальному випадку, умову взаємного виключення неможливо обійти, оскільки деякі з ресурсів мають використовуватись лише в екслюзивному режимі. Утримання та очікування Для невиконання цієї умови, кожен раз, коли процес потребує нові ресурси, він повинен не утримувати інші ресурси. Можливі такі алгоритми: Отримувати всі ресурси на початку роботи процесу до виконання решти операцій. Отримувати новий ресурс лише за умови вивільнення зайнятих ресурсів. Перед запитом нового ресурсу, процес звільняє зайняті ним ресурси. Недоліком першого алгоритму є неефективне використання та простій ресурсів. Також, існує можливість «голоду»: в перенавантаженій системі, процес, що потребує декілька популярних ресурсів, може ніколи їх не отримати, оскільки хоча б один із них може бути зайнятий іншим процесом. Примусове звільнення ресурсів Для невиконання умови відсутності примусового звільнення ресурсів, можливі такі алгоритми: У випадках, коли процес запитує доступ до ресурсу, який не може бути одразу надано, він звільняє решту зайнятих ресурсів, і передає їх в чергу на запит. Роботу процесу буде відновлено після отримання доступу до всіх ресурсів у черзі (старі та нові ресурси). Спочатку перевірити можливість надання ресурсу, якщо можливість надати ресурс відсутня через використання його іншим процесом, що очікує на звільнення деяких інших ресурсів, то звільнити цей ресурс, і передати його процесу-замовнику. Якщо необхідний ресурс як недоступний, так і процес, що його використовує, не очікує на звільнення інших ресурсів, то перевести процес, що подав запит, в стан очікування. Під час очікування, деякі утримувані ним ресурси можуть бути звільнено через запити третіх процесів. Процес відновлює роботу після того, як отримає необхідні ресурси та ресурси, що були звільнені під час очікування. Такий алгоритм використовується для ресурсів, стан яких може бути легко збережено та відтворено, таких як регістри процесора або простори пам'яті. Циклічне очікування Уникнення циклічного очікування досягається встановленням порядку отримання доступу до ресурсів різних типів. Нехай — множина типів ресурсів. Ототожнимо з кожним з них ціле число, що дозволить порівнювати ресурси та встановлювати пріоритети (див. частково впорядкована множина). Тепер, для уникнення циклічного очікування, встановимо наступне правило: процес може запитувати ресурси лише в зростаючому порядку номерів. Як варіант, процес має звільняти ресурс з більшим порядковим номером перед поданням запиту на ресурс з меншим номером. Попри те, що встановлення та дотримання правильного порядку отримання доступу до ресурсів є відповідальністю розробника ПЗ, існють спеціалізовані інструменти для перевірки дотримання порядку та повідомлення про помилки. Одним з прикладів є програма witness, що працює на операційних системах сім'ї BSD. Уникнення Для уникнення тупикових сутацій, програми мають зазделегідь надавати операційній системі інформацію про ресурси, що будуть використані процесом під час роботи. Маючи цю інформацію операційна система може вирішувати на задоволення яких запитів процес може зачекати. Аби вирішити, чи повинен процес чекати, операційна система має брати до уваги доступні ресурси, ресурси виділені процесам та майбутні запити, які можуть зробити процеси. Інструменти Відомі такі інструменти для роботи з клінчами в обчислювальних системах: witness програма witness, що працює на операційних системах сімейства BSD, отримує інформацію про отримані локи та перевіряє на припустимість ці запити. SPIN система для верифікації моделей розподілених систем. Примітки Coffman, E. G., Elphick, M. J. and Shoshani, A.: «System Deadlocks», Computing Surveys, vol. 3, pp. 67—78, червень 1971. Havender, J. W.: «Avoiding Deadlock in Multitasking Systems», IBM Systems Journal, vol. 7, pp. 74—84, 1968. Holt, R. C.: «Some Deadlock Properties of Computer Systems», Computing Surveys, vol. 4, pp. 179—196, вересень 1972. Hack M., Analysis of Production Schemata by Petri Nets, Master's thesis, Department of Electrical Engineering, Massachusetts Institute of Technology, лютий 1972. Література (пер. з англ.) Див. також Паралельне програмування Процес Зависання Проблема зупинки Пі-числення Мережа Петрі Обмін повідомленнями Теорія графів Категорія:Програмування Категорія:Паралельні обчислення Категорія:Помилки програмування Категорія:Едсгер Дейкстра"}
{"category": "Програмування", "title": "Видима продуктивність", "abstract": "Видима продуктивність або сприйнята продуктивність, відчувана продуктивність (англ. Perceived performance) - це як швидко програма виконує свої функції з точки зору користувача, на відміну від того що показують результати профілювання.", "content": "Видима продуктивність або сприйнята продуктивність, відчувана продуктивність () - це як швидко програма виконує свої функції з точки зору користувача, на відміну від того що показують результати профілювання. Посилання Категорія:Програмування"}
{"category": "Програмування", "title": "Вираз (інформатика)", "abstract": "Ви́раз (англ. expression) — мовна конструкція для обчислення значення невідомої величини за допомогою одного або декількох операндів. Це комбінація певних сутностей, констант, змінних, операторів і функцій, які інтерпретуються згідно з певними правилами черговості і асоціації для конкретної мови програмування, яка обчислює і потім виробляє інше значення. Цей процес, як у математичних виразах, називається обчисленням. Значення можуть бути різних типів, наприклад: числові, рядкові й логічні.\nФункції, а отже, і вирази, що містять функцію, можуть мати побічні ефекти. Вирази з побічними ефектами, як правило, не мають властивостей «прозорості посилань».", "content": "Ви́раз () — мовна конструкція для обчислення значення невідомої величини за допомогою одного або декількох операндів. Це комбінація певних сутностей, констант, змінних, операторів і функцій, які інтерпретуються згідно з певними правилами черговості і асоціації для конкретної мови програмування, яка обчислює і потім виробляє інше значення. Цей процес, як у математичних виразах, називається обчисленням. Значення можуть бути різних типів, наприклад: числові, рядкові й логічні. Функції, а отже, і вирази, що містять функцію, можуть мати побічні ефекти. Вирази з побічними ефектами, як правило, не мають властивостей «прозорості посилань». Див. також Інструкція (програмування) Категорія:Програмування Категорія:Поняття мов програмування"}
{"category": "Програмування", "title": "Візуальне програмування", "abstract": "Візуа́льне програмува́ння — спосіб створення програм шляхом маніпулювання графічними об'єктами замість написання програмного коду в текстовому вигляді.\nВізуальне програмування дозволяє програмувати, використовуючи графічні або символьні елементи, якими можна маніпулювати інтерактивним чином згідно з деякими правилами, причому просторове розташування графічних об'єктів використовувати як елементи синтаксису програми. Значна частина візуальних мов програмування базується на ідеї «фігур і ліній», де фігури (прямокутники, овали та ін.) розглядаються як суб'єкти і з'єднуються лініями (стрілками, дугами тощо), які являють собою відношення. Приклад: UML\nМови візуального програмування можуть бути додатково класифіковані в залежності від типу і ступеня візуального вираження, на типи[джерело?]:\n\nПриродно-візуальні мови мають невід'ємне візуальне вираження, для якого немає очевидного текстового еквіваленту (наприклад, графічна мова G в середовищі LabVIEW).\nВізуально-перетворені мови є невізуальними мовами з накладеним візуальним представленням.\nЗначна кількість сучасних мов програмування має розвинуті візуальні засоби для розробки графічного інтерфейсу, причому здійснюється програмування розміщених на спеціальних формах об'єктів з настроюванням їх властивостей та поведінки. CodeGear Delphi і C++ Builder, Microsoft Visual Studio та мови, які включає в себе цей засіб (Visual Basic, Visual C#, Visual J# тощо) часто плутають з візуальними мовами програмування. Всі ці мови є текстовими, а не візуальними (графічними). MS Visual Studio та Delphi є візуальними середовищами програмування, але не візуальними мовами програмування.", "content": "thumb|right|KTechLab Візуа́льне програмува́ння — спосіб створення програм шляхом маніпулювання графічними об'єктами замість написання програмного коду в текстовому вигляді. Візуальне програмування дозволяє програмувати, використовуючи графічні або символьні елементи, якими можна маніпулювати інтерактивним чином згідно з деякими правилами, причому просторове розташування графічних об'єктів використовувати як елементи синтаксису програми. Значна частина візуальних мов програмування базується на ідеї «фігур і ліній», де фігури (прямокутники, овали та ін.) розглядаються як суб'єкти і з'єднуються лініями (стрілками, дугами тощо), які являють собою відношення. Приклад: UML Мови візуального програмування можуть бути додатково класифіковані в залежності від типу і ступеня візуального вираження, на типи: Природно-візуальні мови мають невід'ємне візуальне вираження, для якого немає очевидного текстового еквіваленту (наприклад, графічна мова G в середовищі LabVIEW). Візуально-перетворені мови є невізуальними мовами з накладеним візуальним представленням. Значна кількість сучасних мов програмування має розвинуті візуальні засоби для розробки графічного інтерфейсу, причому здійснюється програмування розміщених на спеціальних формах об'єктів з настроюванням їх властивостей та поведінки. CodeGear Delphi і C++ Builder, Microsoft Visual Studio та мови, які включає в себе цей засіб (Visual Basic, Visual C#, Visual J# тощо) часто плутають з візуальними мовами програмування. Всі ці мови є текстовими, а не візуальними (графічними). MS Visual Studio та Delphi є візуальними середовищами програмування, але не візуальними мовами програмування. Мови візуального програмування A-Flow, програмне забезпечення загального призначення, яке не вимагає написання коду AgentSheets , простий у використанні авторський засіб розробки Alice AudioMulch Macromedia Authorware Apple Automator Aviary Peacock Baltie Befunge , мова, розроблена для проекту космічного корабля Буран EICASLAB Executable UML eXpecco Flowcode Flowstone DSP [FxEngine Framework] JMCAD G, мова, яка використовується в LabVIEW Game Maker, легке у використанні середовище для розробки ігор Godot (гральний рушій) має візуальний редактор шейдерної мови та візуальну реальізацію своєї скриптової мови GDScript Google App Inventor, засіб для створення застосунків Google Android, заснований на OpenBlocks і Kawa GNU Radio Companion Grasshopper 3D Helix HiAsm Illumination Software Creator Kodu , програмний засіб для створення ігор з 3D-інтерфейсом, розроблений в Microsoft Research Kwikpoint KTechLab LabVIEW Ladder logic Lava Lily Limnor Mama (програмний засіб) Marten Max Max/MSP Pure Data jMax nato.0+55+3d Microsoft Visual Programming Language , мова програмування для робототехніки, яка є одним з компонентів Microsoft Robotics Studio Mindscript Morphic MST Workshop Lego Mindstorms NXT , візуальна мова програмування для набору робототехніки Lego Mindstorms OpenAlea.Visualea OpenBlocks OpenDX OpenMusic OpenWire OutSystems Piet PointDragon Prograph Ptolemy PWCT [PWGL], мова, заснована на Common Lisp, CLOS та OpenGL [Pypes] Quartz Composer Quest3D Reaktor Red-R SCADA Scala Multimedia Scicos Simulink Засновані на Squeak Etoys графічно-скриптова мова програмування Scratch, програмний засіб Массачусетського технологічного інституту для дітей 7-12 років Autodesk Softimage Stagecast Creator SourceBinder SynthMaker SynthEdit Tarpipe Tersus TestShell ThingLab ToonTalk , система програмування для дітей Agilent VEE VisSim Virtools VISION/HPC WireFusion Vsxu Посилання Див. також Node-RED Скретч (мова програмування) Категорія:Програмування"}
{"category": "Програмування", "title": "Візуальне середовище програмування", "abstract": "Візуальне середовище програмування  - інтегроване середовище розробки програмних засобів (IDE, яке містить редактор вихідного коду, компілятор чи/або інтерпретатор, засоби автоматизації збірки та засоби для спрощення розробки графічного інтерфейсу користувача). Середовища для візуального програмування також надають змогу конструювати програми шляхом оперування графічними об’єктами. Багато сучасних візуальних середовищ програмування використовуються для реалізації принципів об'єктно-орієнтованого підходу у розробці програмного забезпечення.", "content": "Візуальне середовище програмування - інтегроване середовище розробки програмних засобів (IDE, яке містить редактор вихідного коду, компілятор чи/або інтерпретатор, засоби автоматизації збірки та засоби для спрощення розробки графічного інтерфейсу користувача). Середовища для візуального програмування також надають змогу конструювати програми шляхом оперування графічними об’єктами. Багато сучасних візуальних середовищ програмування використовуються для реалізації принципів об'єктно-орієнтованого підходу у розробці програмного забезпечення. Див. також Середовище розробки програмного забезпечення Інструментальна система Категорія:Програмування Категорія:Візуалізація"}
{"category": "Програмування", "title": "Гексагональна архітектура (програмування)", "abstract": "Гексагональна архітектура, або архітектура портів та адаптерів, є прикладом архітектури, що використовується при розробці програмного забезпечення. Вона спрямована на створення слабкозв'язних компонентів застосувань, які можна легко підключити до програмного середовища за допомогою портів та адаптерів. Це робить компоненти легкозамінними на будь-якому рівні та полегшує автоматизацію тестування.", "content": "Гексагональна архітектура, або архітектура портів та адаптерів, є прикладом архітектури, що використовується при розробці програмного забезпечення. Вона спрямована на створення слабкозв'язних компонентів застосувань, які можна легко підключити до програмного середовища за допомогою портів та адаптерів. Це робить компоненти легкозамінними на будь-якому рівні та полегшує автоматизацію тестування. Походження Гексагональну архітектуру винайшов Алістер Кокберн, намагаючись уникнути відомих усім структурних підводних каменів в об'єктно-орієнтованому дизайні програмного забезпечення, таких як небажані залежності між архітектурними рівнями та присутність бізнес-логіки в коді користувальницького інтерфейсу. Вона опублікована в 2005 році. Термін «гексагональний» походить від графічних домовленостей, які показують компонент програми, такий як гексагональна комірка. Було необхідно залишити достатньо місця для представлення різних інтерфейсів, необхідних для зв'язку між компонентом та зовнішнім світом і одночасно не допустити, що буде 6 границь. Принцип альт=Example of hexagonal architecture with an inner hexagon representing the application core, and an outer hexagon for the adapters, the border between the two being the ports|міні|313x313пкс| Приклад гексагональної архітектури Гексагональна архітектура розділяє систему на декілька вільнопов'язаних взаємозамінних компонентів, таких як ядро програми, база даних, користувальницький інтерфейс, тестові скрипти та інтерфейси з іншими системами. Цей підхід є альтернативою традиційній багатошаровій архітектурі. Кожен компонент з'єднаний з іншими через безліч відкритих «портів». Зв'язок через ці порти здійснюється за певним протоколом залежно від їх призначення. Порти та протоколи визначають абстрактний API, який може бути реалізований будь-якими відповідними технічними засобами (наприклад, виклик методу об'єктно-орієнтованою мовою, віддалені виклики процедур або вебслужби). Деталізованість портів та їх кількість не обмежена: одного порту в деяких випадках може бути достатньо (наприклад, у випадку простого споживача послуг); як правило, є порти для джерел подій (користувальницький інтерфейс, автоматичне подавання), сповіщень (вихідні сповіщення), бази даних (для взаємодії компонента з будь-якою підходящою СУБД) та адміністрування (для управління компонентом); в крайньому випадку, для кожного випадку використання може бути інший порт, якщо це необхідно. Адаптери — це міст, що поєднує компоненти та зовнішній світ. Вони адаптують обмін між зовнішнім світом та портами, що відповідають вимогам внутрішньої частини компонента програми. Для одного порту може бути кілька адаптерів, наприклад, якщо дані можуть бути надані користувачем через графічний інтерфейс або інтерфейс командного рядка, через автоматизоване джерело даних або за допомогою тестових скриптів. Критика За словами Мартіна Фаулера, гексагональна архітектура має перевагу використання і схожості між шаром презентації та рівнем джерела даних для створення симетричних компонентів, виготовлених із ядра, оточеного інтерфейсами, але з недоліком приховування властивої асиметрії між постачальником послуг та споживачем послуги. Цей недолік можна було б виправити, якщо представити у вигляді шарів. На думку деяких авторів, гексагональна архітектура базована на основі мікросервісної архітектури. Варіанти Цибулева архітектура, запропонована Джеффрі Палермо в 2008 році, схожа на шестигранну архітектуру: вона також дає можливість зовнішнього існування інфраструктури з належними інтерфейсами для забезпечення вільного зв'язку між додатком та базою даних. Він додатково розкладає серцевину додатка на кілька концентричних кілець за допомогою інверсії керування. Чиста архітектура, запропонована Робертом К. Мартіном у 2012 році, поєднує принципи гексагональної архітектури, цибулевої архітектури та декількох інших варіантів. Вона забезпечує додаткові рівні деталізації компонента, які представлені у вигляді концентричних кілець. Це ізолює адаптери і інтерфейси (призначений для користувача інтерфейс, бази даних, зовнішні системи, пристрій) в зовнішніх кільцях архітектури і залишає внутрішні кільця для варіантів використання і бізнес-правил рівня підприємства. Чиста архітектура використовує принцип інверсії залежностей із суворим правилом, згідно з яким залежності повинні існувати лише між зовнішнім кільцем та внутрішнім кільцем, а ніколи не навпаки. Див. також Архітектурні візерунки Складена структурна схема Об'єктно-орієнтований аналіз та проектування Список літератури Категорія:Об'єктно-орієнтоване програмування Категорія:Архітектурні шаблони програмного забезпечення Категорія:Проєктування програмного забезпечення Категорія:Програмування Категорія:Програмне забезпечення"}
{"category": "Програмування", "title": "Генерація коду", "abstract": "Генерація коду або кодогенерація — частина процесу компіляції, коли спеціальна частина компілятора, кодогенератор, конвертує синтаксично коректну програму в послідовність інструкцій, які можуть виконуватися на машині. При цьому можуть застосовуватися різні, в першу чергу машинно-залежні оптимізації. Часто кодогенератор є спільною частиною для багатьох компіляторів. Кожен з них генерує проміжний код, який подається на вхід кодогенератору.\nЗазвичай, на вхід генератора коду подається дерево розбору або абстрактне синтаксичне дерево. Дерево перетвориться в лінійну послідовність інструкцій проміжної мови.\nСкладні компілятори, як правило, роблять кілька проходів через різні проміжні форми коду. Цей багатокроковий процес використовується тому, що багато алгоритмів оптимізації коду простіше реалізувати окремо, або ж тому, що якийсь крок оптимізації залежить від результату обробки другого кроку. Окрім того, при такій організації легко створити один компілятор, який буде створювати код для кількох платформ, так як достатньо замінити останній крок генерації коду (англ. backend ).\nПодальші етапи компіляції можуть і не належати до «генерації коду», в залежності від того, наскільки значними будуть зміни, що вносяться ними. Так, локальна оптимізація навряд чи може називатися «генерацією коду», проте сам генератор коду може включати в себе етап локальної оптимізації.", "content": "Генерація коду або кодогенерація — частина процесу компіляції, коли спеціальна частина компілятора, кодогенератор, конвертує синтаксично коректну програму в послідовність інструкцій, які можуть виконуватися на машині. При цьому можуть застосовуватися різні, в першу чергу машинно-залежні оптимізації. Часто кодогенератор є спільною частиною для багатьох компіляторів. Кожен з них генерує проміжний код, який подається на вхід кодогенератору. Зазвичай, на вхід генератора коду подається дерево розбору або абстрактне синтаксичне дерево. Дерево перетвориться в лінійну послідовність інструкцій проміжної мови. Складні компілятори, як правило, роблять кілька проходів через різні проміжні форми коду. Цей багатокроковий процес використовується тому, що багато алгоритмів оптимізації коду простіше реалізувати окремо, або ж тому, що якийсь крок оптимізації залежить від результату обробки другого кроку. Окрім того, при такій організації легко створити один компілятор, який буде створювати код для кількох платформ, так як достатньо замінити останній крок генерації коду (англ. backend ). Подальші етапи компіляції можуть і не належати до «генерації коду», в залежності від того, наскільки значними будуть зміни, що вносяться ними. Так, локальна оптимізація навряд чи може називатися «генерацією коду», проте сам генератор коду може включати в себе етап локальної оптимізації. Завдання генератора коду В додачу до основного завдання — перетворення коду з проміжного представлення в машинні інструкції — генератор коду зазвичай намагається оптимізувати код, створений тими чи іншими способами. Наприклад, він може використовувати більш швидкі інструкції, використовувати менше інструкцій, використовувати наявні регістри і запобігати надлишковим обчисленням. Деякі завдання, які, зазвичай, вирішують складні генератори коду: Вибір інструкцій: які саме інструкції використати; Планування інструкцій: у якому порядку розміщувати ці інструкції. Планування — це оптимізація, котра може значно впливати на швидкість виконання програми на конвеєрних процесорах; Розміщення у регістрах: розміщення змінних програми у регістрах процесора; Генерація даних для налагодження, якщо потрібно, так що код може бути налагоджений. Вибір інструкцій зазвичай виконується рекурсивним обходом абстрактного синтаксичного дерева. В цьому випадку порівнюються частини конфігурацій дерева з шаблонами. Наприклад, дерево W:=ADD(X,MUL(Y,Z)) може бути перетворене в лінійну послідовність інструкцій рекурсивну генерації послідовностей t1:=X і t2:=MUL(Y,Z) , а потім в інструкцію ADD W,t1,t2 . В компіляторах, які використовують проміжну мову, може бути дві стадії вибору інструкцій — одна для перетворення дерева розбору в проміжний код, а друга (виконується значно пізніше) — для перетворення проміжного коду в інструкції цільової системи команд. Друга стадія не вимагає обходу дерева : вона може виконуватися послідовно і зазвичай складається з простої заміни операцій проміжної мови відповідними їм кодами операцій. Насправді, якщо компілятор фактично є транслятором (наприклад, один переводить Eiffel в C), то друга стадія генерації коду може включати побудову дерева з лінійного проміжного коду. Генерація коду під час виконання Коли генерація коду відбувається під час виконання програми, як в JIT, важливо, щоб весь процес генерації коду був ефективний як в часі, так і у використаній пам'яті. Наприклад, при інтерпретації регулярних виразів, частіше створюються недетерміновані кінцеві автомати, ніж детерміновані , тому, що вони створюються швидше і займають менше пам'яті. Незважаючи на те, що створюється, загалом, менш ефективний код, генерація коду в JIT може надати можливість профілювання інформації, доступної тільки під час виконання програми. Рефлексія Загалом синтаксичний та семантичний аналізатор намагаються отримати структуру програми з вихідного коду, а генератор коду використовує цю структурну інформацію (наприклад, типи даних) для створення коду. Іншими словами, перший додає інформацію, тоді як останній втрачає певну інформацію. Одним із наслідків такої втрати інформації є те, що рефлексія стає складною або навіть неможливою. Щоб протистояти цій проблемі, генератори коду часто вставляють синтаксичну та семантичну інформацію на додаток до коду, необхідного для виконання. Див. також Компіляція Примітки Література Дональд Кнут. Мистецтво програмування. Альфред Ст. Агв, Моніка С. Лам, Рави Мережі, Джеффрі Д. Ульман. Компілятори: принципи, технології та інструментарій = Компілятори: Principles, Techniques, and Tools. — 2-е вид. — М.: Вільямс, 2008. — ISBN 978-5-8459-1349-4. Робін Хантер. Основні концепції компіляторів = The Essence of Компілятори. — М.: «Вільямс», 2002. — С. 256. — ISBN 5-8459-0360-2. Посилання Семантичний аналізатор Семантичний аналіз тексту Синтаксичний аналіз Корнійко Ілля. Створення компілятора Архитектура набора команд (ISA) Code Generation: The Real Lesson of Rails Категорія:Програмування Категорія:Машинний код Категорія:Теорія компіляторів"}
{"category": "Програмування", "title": "Гомоіконність", "abstract": "«Гомоіконність» (англ. Homoiconicity) — властивість мови програмування, у яких нема синтаксичного розрізнення між інструкціями програми і даними. Завдяки цьому код програми описується, як структура даних, яка однозначно відповідає її синтаксичному дереву. Це дозволяє мові легко описувати метапрограми, які можуть динамічно міняти свої інструкції. Наприклад, у Common Lisp та Scheme і код, і дані, описуються у вигляді так званих «списків». Машинні команди в архітектурі фон Неймана теж є гомоіконними, бо розглядають інструкції й дані узагальнено, як послідовність байтів.", "content": "«Гомоіконність» () — властивість мови програмування, у яких нема синтаксичного розрізнення між інструкціями програми і даними. Завдяки цьому код програми описується, як структура даних, яка однозначно відповідає її синтаксичному дереву. Це дозволяє мові легко описувати метапрограми, які можуть динамічно міняти свої інструкції. Наприклад, у Common Lisp та Scheme і код, і дані, описуються у вигляді так званих «списків». Машинні команди в архітектурі фон Неймана теж є гомоіконними, бо розглядають інструкції й дані узагальнено, як послідовність байтів. Див. також S-вислови Джерела http://c2.com/cgi/wiki?DefinitionOfHomoiconic Категорія:Програмування"}
{"category": "Програмування", "title": "Грабер", "abstract": "Грабер (англ. grabber) — сленговий термін IT-спеціалістів, що позначає програму, яка вміє збирати певну інформацію з різного роду файлів або носіїв або якогось зовнішнього ресурсу (наприклад з вебсайту) і передавати їх господареві грабера. Вона може бути як автоматичною, так і ручною. Буває, наприклад, грабер екрану. Це коли програма захоплює те, що виводиться на екран. В інтернеті часто застосовують грабери контенту. Зазвичай, грабери контенту пишуть на мові програмування PHP чи JavaScript.\nПроцес розробки і написання граберу до певного інтернет-ресурсу називається грабінгом.", "content": "Грабер () — сленговий термін IT-спеціалістів, що позначає програму, яка вміє збирати певну інформацію з різного роду файлів або носіїв або якогось зовнішнього ресурсу (наприклад з вебсайту) і передавати їх господареві грабера. Вона може бути як автоматичною, так і ручною. Буває, наприклад, грабер екрану. Це коли програма захоплює те, що виводиться на екран. В інтернеті часто застосовують грабери контенту. Зазвичай, грабери контенту пишуть на мові програмування PHP чи JavaScript. Процес розробки і написання граберу до певного інтернет-ресурсу називається грабінгом. Див. також Audiograbber Парсер Посилання Що таке грабер. Категорія:Програмування Категорія:Програмне забезпечення"}
{"category": "Програмування", "title": "Двійковий програмний інтерфейс", "abstract": "Двійковий програмний інтерфейс, чи двійковий інтерфейс застосунків (англ. Application Binary Interface, англ. ABI) — низькорівневий, на рівні машинних кодів, інтерфейс взаємодії між прикладною програмою (чи будь-яким іншим типом програм) та операційною системою, бібліотеками або іншою програмою на даній платформі.", "content": "Двійковий програмний інтерфейс, чи двійковий інтерфейс застосунків (англ. Application Binary Interface, ) — низькорівневий, на рівні машинних кодів, інтерфейс взаємодії між прикладною програмою (чи будь-яким іншим типом програм) та операційною системою, бібліотеками або іншою програмою на даній платформі. Визначення Двійковий програмний інтерфейс визначає тип, розмір та вирівнювання типів даних, формат передачі аргументів під час виклику і завершення функції, формат системних викликів, формати виконуваних файлів, файлів бібліотек, об'єктних файлів і т.п. Деякі ABI описують перетворення імен функцій (наприклад в C++) та підтримку винятків. Двійковий програмний інтерфейс відрізняється від прикладного програмного інтерфейсу () тим, що API визначає інтерфейс взаємодії на рівні початкового коду, забезпечуючи можливість компіляції коду на будь-якій платформі. У свою чергу, ABI дозволяє скомпільованому об'єктному коду функціонувати без змін на будь-якій платформі, де використовується та ж конфігурація ABI. Див. також Прикладний програмний інтерфейс Категорія:Технології операційних систем Категорія:Програмування"}
{"category": "Програмування", "title": "Денотаційна семантика", "abstract": "Денотати́вна сема́нтика — це підхід до формалізації семантики програмних систем за допомогою математичних об'єктів, які описують зміст системи. Кожній конструкції мови програмування відповідає якась математична інтерпретація.\nДенотаційна семантика виникла в роботах Кристофера Стречи та Дана Скотта на початку 60-х років минулого століття. У їх ранніх роботах денотат (зміст) комп'ютерної системи інтерпретувався функцією яка відображає вхідні дані у вихідні. Пізніше Скотт перейшов до денотативної семантики заснованої на доменах. Опис системи у денотативній семантиці здійснюється за допомогою математичних об'єктів та абстрагований від її реалізації конкретною мовою програмування.\nВажливим аспектом денотативної семантики є принцип композиційності, за яким денотат програми будується з денотатів її складових частин за допомогою операції композиції.\nДо того як Еугеніо Моджі відкрив що побічні ефекти можна описувати монадами, денотаційна семантика не підходила для опису таких програм, які щоправда дуже просто описувались операційною семантикою.", "content": "Денотати́вна сема́нтика — це підхід до формалізації семантики програмних систем за допомогою математичних об'єктів, які описують зміст системи. Кожній конструкції мови програмування відповідає якась математична інтерпретація. Денотаційна семантика виникла в роботах та Дана Скотта на початку 60-х років минулого століття. У їх ранніх роботах денотат (зміст) комп'ютерної системи інтерпретувався функцією яка відображає вхідні дані у вихідні. Пізніше Скотт перейшов до денотативної семантики заснованої на доменах. Опис системи у денотативній семантиці здійснюється за допомогою математичних об'єктів та абстрагований від її реалізації конкретною мовою програмування. Важливим аспектом денотативної семантики є принцип композиційності, за яким денотат програми будується з денотатів її складових частин за допомогою операції композиції. До того як Еугеніо Моджі відкрив що побічні ефекти можна описувати монадами, денотаційна семантика не підходила для опису таких програм, які щоправда дуже просто описувались операційною семантикою. Див. також Операційна семантика Аксіоматична семантика Зноски Посилання Denotational Semantics на WikiWikiWeb Процик Петро Павлович. \"Методи та засоби специфікації програмних систем\" Категорія:Теорія програмування Категорія:Програмування Категорія:Семантика мов програмування Категорія:Моделі обчислень Категорія:Логіка в інформатиці Категорія:Мови формальних специфікацій Категорія:Денотаційна семантика"}
{"category": "Програмування", "title": "Депрекація", "abstract": "Депрекація (англ. deprecation — осуд, заперечення, несхвалення) — зменшення цінності або корисності старого об'єкта, що залишається дійсним і корисним як є, але який більше не рекомендується, і його слід уникати в нових випадках використання. Може стосуватися класу, інтерфейсу, методу, чи поля, використання яких більше не рекомендовано, тому що вони застарілі та можуть бути видалені у наступній версії мови.", "content": "Депрекація ( — осуд, заперечення, несхвалення) — зменшення цінності або корисності старого об'єкта, що залишається дійсним і корисним як є, але який більше не рекомендується, і його слід уникати в нових випадках використання. Може стосуватися класу, інтерфейсу, методу, чи поля, використання яких більше не рекомендовано, тому що вони застарілі та можуть бути видалені у наступній версії мови. Посилання Категорія:Сумісність Категорія:Програмування"}
{"category": "Програмування", "title": "Дескриптор (Windows)", "abstract": "Дескриптор (англ. Handle) — це структура даних, яка представляє відкритий екземпляр базового об'єкта операційної системи, наприклад, файл, ключ реєстру, об’єкт синхронізації тощо. Дескриптор однозначно ідентифікує створений об'єкт і надає доступ до об'єкта, дозволяючи читати та змінювати його стан.", "content": "Дескриптор () — це структура даних, яка представляє відкритий екземпляр базового об'єкта операційної системи, наприклад, файл, ключ реєстру, об’єкт синхронізації тощо. Дескриптор однозначно ідентифікує створений об'єкт і надає доступ до об'єкта, дозволяючи читати та змінювати його стан. Дескриптори об'єктів операційної системи Дескриптор може бути використаний будь-яким потоком процесу для доступу до властивостей об’єкта, і саме його передають функціям, які працюють з об’єктами. Для покращення надійності у роботі операційної системи Microsoft забезпечила залежність дескрипторів від конкретного процесу. Тому, якщо передати дескриптор іншому процесу, він не зможе використовувати відповідний об'єкт ядра. При ініціалізації процесу система створює в ньому таблицю дескрипторів об'єктів ядра, яка містить інформацію про всі використані ним об’єкти та набір привілеїв доступу до них. Коли процес ініціалізується, таблиця дескрипторів порожня. При кожному виклику функції, що створює об'єкт, відразу після його створення ядро переглядає таблицю дескрипторів процесу, знаходить перший вільний запис і записує у нього дані про об’єкт (вказівник на область пам’яті, за якою знаходиться об’єкт, та параметри доступу). Всі функції, які створюють об'єкти ядра, повертають прив'язані до конкретного процесу дескриптори, що можуть бути використані в будь-якому потоці цього процесу. Значення дескриптора є байтовим зміщенням від початку таблиці дескрипторів процесу. Якщо при звертанні до об’єкта ядра відповідній функції передати неправильний дескриптор, вона завершиться з помилкою ERROR_INVALID_HANDLE (недопустимий дескриптор). Якщо виклик функції, яка створює об'єкт ядра, невдалий, то звичайно повертається значення 0 (NULL). Така ситуація можлива при гострій нестачі пам'яті або за наявності проблем із доступом. Робота з дескриптором Програма отримує дескриптор під час створення нового або відкривання існуючого об'єкта. Наприклад, при створенні потоку за допомогою функції CreateThread вона повертає дескриптор створеного потоку. Незалежно від того, яким чином отримано дескриптор, при закінченні роботи його потрібно закрити викликом функції CloseHandle: function CloseHandle(hObject: THandle): BOOL; Ця функція спочатку перевіряє таблицю дескрипторів викликаючого процесу, щоб переконатися, чи ідентифікує переданий їй дескриптор об'єкт, до якого цей процес дійсно має доступ. Якщо переданий індекс правильний, система отримує адресу структури даних об'єкта й зменшує в цій структурі лічильник числа користувачів (а як тільки лічильник обнулиться, ядро видалить об'єкт із пам'яті). Якщо дескриптор неправильний, функція CloseHandle повертає значення false. Перед поверненням у викликаючу програму CloseHandle видаляє відповідний запис із таблиці дескрипторів: після цього дескриптор вже недійсний у процесі й використовувати його не можна. При цьому запис видаляється незалежно від того, знищений об'єкт ядра чи ні. Після виклику CloseHandle процес більше не отримає доступу до цього об'єкта ядра (але якщо його лічильник не обнулено, об'єкт залишається в пам'яті). Після завершення процесу операційна система автоматично звільняє всі ресурси, які йому належали, і у випадку об'єктів ядра діє так: у момент завершення процесу переглядає його таблицю дескрипторів і закриває всі відкриті дескриптори. Дескриптори є процесо-залежними, проте часто виникає необхідність їх сумісного використання кількома процесами. У Windows реалізовано такі механізми сумісного доступу до об’єктів ядра кількома процесами: спадкування дескрипторів, їх іменування та дублювання. Спадкування стосується лише споріднених процесів (батьківський-дочірній). Батьківський процес при створенні може передати права доступу до своїх об’єктів ядра дочірньому процесу. Для цього поле bInheritHandle структури SECURITY_ATTRIBUTES слід встановити у true. При такому наслідуванні система, крім копіювання записів з таблиці дескрипторів, збільшує значення лічильників відповідних об'єктів ядра, оскільки вони тепер використовуються обома процесами. Щоб знищити якийсь об'єкт ядра, його дескриптор повинні закрити (викликом CloseHandle) обидва процеси. Успадковуються тільки дескриптори об'єктів, що існують на момент створення дочірнього процесу. Якщо батьківський процес створить після цього нові об'єкти ядра з успадковуваними дескрипторами, вони будуть недоступні дочірньому процесу. При спадкуванні дочірній процес «не знає», що він успадкував якісь дескриптори, тому йому окремо передають значення очікуваного ним дескриптора об'єкта ядра (наприклад, як аргумент у командному рядку чи змінну оточення). Дескриптори дозволяють різним процесам використовувати системні об'єкти. Інший спосіб, який дозволяє кільком процесам спільно використовувати об'єкти ядра, пов'язаний з іменуванням цих об'єктів. Іменувати можна багато (але не всі) об'єкти ядра. Наприклад, іменовані об'єкти створюють такі функції: CreateMutex, CreateEvent, CreateSemaphore, CreateFileMapping тощо. За відомим іменем об’єкта інші процеси можуть відкрити його дескриптор і отримати таким чином до нього доступ. Ще один механізм спільного використання об'єктів ядра кількома процесами — це застосування функції DuplicateHandle, яка отримує запис у таблиці дескрипторів одного процесу й створює її копію в таблиці іншого. Як і при спадкуванні, процес-приймач ніяк не повідомляється про те, що він одержав доступ до нового об'єкта ядра, тому його потрібно спеціально інформувати про це. Дескриптор захисту Об'єкти ядра можна захистити дескриптором захисту (security descriptor), який описує, хто створив об'єкт і хто має право доступу до нього. Майже всі функції, що створюють об'єкти ядра, приймають аргумент – вказівник на структуру SECURITY_ATTRIBUTES. Більшість програм замість цього аргументу передає NULL, що приводить до створення об'єкта із захистом за замовчуванням. Така ситуація передбачає, що творець об'єкта й будь-який користувач групи адміністраторів отримує до нього повний доступ, а всі інші не допускаються. Однак для зміни цієї поведінки можна самостійно створити й ініціалізувати структуру SECURITY_ATTRIBUTES, а потім передати її адресу функції створення об’єкта. Вона має такий вигляд (описано мовою Delphi): _SECURITY_ATTRIBUTES = record nLength: DWORD; // Розмір структури lpSecurityDescriptor: Pointer; // Адреса дескриптора захисту bInheritHandle: BOOL; // Чи успадковувати дескриптор end; SECURITY_ATTRIBUTES = _SECURITY_ATTRIBUTES; Лише один елемент цієї структури має стосунок до захисту — lpSecurityDescriptor. Якщо слід обмежити доступ до об'єкта, потрібно створити дескриптор захисту й ініціалізувати структуру SECURITY_ATTRIBUTES. Проте специфічний захист об'єктів використовують рідко. Інші види дескрипторів Дескриптори віртуальних адрес (virtual address descriptors, VAD) — це структури даних, які використовуються диспетчером пам'яті для обліку адрес віртуальної пам'яті, задіяних процесом. Примітки Категорія:Програмування Категорія:Microsoft Windows Категорія:Типи даних Категорія:Статті з прикладами коду мовою C"}
{"category": "Програмування", "title": "Дизасемблер", "abstract": "Дизасе́мблер (анг. disassembler) — комп'ютерна програма, що транслює мову машинних кодів у мову асемблер. Дизасемблер не є декомпілятором. Результатом роботи декомпілятора є представлення програмного коду мовою високого рівня. Дизасемблер представляє програмний код у вигляді асемблерного коду. Результат роботи дизасемблера, дизасембльований код, форматується для простішого сприйняття людиною, перетворюючи дизасемблер у засіб для зворотної розробки. Його використання дозволяє розібратися з деталями функціонування коду, провести певну оптимізацію окремих критичних ділянок коду, а також може використовуватися для усунення вбудованого захисту (тобто зламу).\nДизасемблери можуть просто подавати код у вигляді асемблерного коду, а можуть бути інтерактивними.\nДизасемблери можна поділити на:\n\nІнтерактивні — IDA (Дозволяють змінювати правила дизасемблювання, тому є зручним інструментом для дослідження програм)\nАвтоматичні — Sourcer", "content": "thumb|Приклад дії монітора машинного коду як дизасемблера. В третій колоні (яка починається від:6C 36 00) знаходяться команди асемблера для процесора MOS 6502. Дизасе́мблер (анг. disassembler) — комп'ютерна програма, що транслює мову машинних кодів у мову асемблер. Дизасемблер не є декомпілятором. Результатом роботи декомпілятора є представлення програмного коду мовою високого рівня. Дизасемблер представляє програмний код у вигляді асемблерного коду. Результат роботи дизасемблера, дизасембльований код, форматується для простішого сприйняття людиною, перетворюючи дизасемблер у засіб для зворотної розробки. Його використання дозволяє розібратися з деталями функціонування коду, провести певну оптимізацію окремих критичних ділянок коду, а також може використовуватися для усунення вбудованого захисту (тобто зламу). Дизасемблери можуть просто подавати код у вигляді асемблерного коду, а можуть бути інтерактивними. Дизасемблери можна поділити на: Інтерактивні — (Дозволяють змінювати правила дизасемблювання, тому є зручним інструментом для дослідження програм) Автоматичні — Sourcer Дизасемблери Sourcer Hiew Beye Hacker Disassembler Engine CADt Vb-decompiler Radare2 HT Editor — Бінарний редактор для Linux та Windows. Win32 Program disassembler — дизасемблер з відкритим програмним кодом. Примітки Посилання transformation Wiki on disassembly OpenRCE: Various Disassembler Resources and Plug-ins The free country Programmer's heaven Категорія:Програмування Категорія:Засоби розробки Категорія:Асемблер Категорія:Зневадження"}
{"category": "Програмування", "title": "Діаграма потоків даних", "abstract": "Діаграма потоків даних (англ. Data Flow Diagram) — модель проектування, графічне представлення «потоків» даних в інформаційній системі. Діаграма потоків даних також може використовуватись для візуалізації процесів обробки даних (структурне проектування).\nДля розробника вважається звичним спочатку креслити діаграму потоків даних рівня контексту, завдяки чому буде показано взаємодію системи із зовнішніми модулями. Ця діаграма в подальшому підлягає уточненню шляхом деталізації процесів та потоків даних з метою показати розлого розроблювану систему.\nДіаграми потоків даних містять чотири типи графічних елементів: \n\nпроцеси - являють собою трансформацію даних в рамках описуваної системи;\nсховища даних (репозиторії);\nзовнішні по відношенню до системи сутності;\nпотоки даних між елементами трьох попередніх типів.", "content": "міні|270пкс|Приклад діаграми міні|140пкс|Нотація Йордана-ДеМарко Діаграма потоків даних () — модель проектування, графічне представлення «потоків» даних в інформаційній системі. Діаграма потоків даних також може використовуватись для візуалізації процесів обробки даних (структурне проектування). Для розробника вважається звичним спочатку креслити діаграму потоків даних рівня контексту, завдяки чому буде показано взаємодію системи із зовнішніми модулями. Ця діаграма в подальшому підлягає уточненню шляхом деталізації процесів та потоків даних з метою показати розлого розроблювану систему. Діаграми потоків даних містять чотири типи графічних елементів: процеси - являють собою трансформацію даних в рамках описуваної системи; сховища даних (репозиторії); зовнішні по відношенню до системи сутності; потоки даних між елементами трьох попередніх типів. Див. також Модель «сутність — зв'язок» Посилання Стислий довідник Стаття \"Data Flow Diagrams (DFD) \" автора Vicki L. Sauter. Стаття \"Data Flow Diagrams \" автора Tony Drewry Стаття \"The Semantics of Data Flow Diagrams \" авторів P. D. Bruza та Th. P. van der Weide Стаття \"How to draw data flow diagrams \" авторство Smartdraw Розділ \"Dataflow Diagrams\" автора Ed Yourdon Розділ \"Just Enough Structured Analysis - Chapter 9\" автора Ed Yourdon Категорія:Програмування"}
{"category": "Програмування", "title": "Діаграма профілю", "abstract": "Діаграма профілю працює на рівні метамоделі, щоб показати стереотипи як класи зі «stereotype», а профілі як пакети зі стереотипом «profile» . Відношення розширення (суцільна лінія із замкнутим, заповненим наконечником стрілки) вказує, який елемент метамоделі поширює даний стереотип.", "content": "праворуч|360x360пкс| Приклад визначення та використання спрощеного профілю для цілей моделювання організації. Діаграма профілю працює на рівні метамоделі, щоб показати стереотипи як класи зі «stereotype», а профілі як пакети зі стереотипом «profile» . Відношення розширення (суцільна лінія із замкнутим, заповненим наконечником стрілки) вказує, який елемент метамоделі поширює даний стереотип. Історія Діаграми профілю не існувало в UML 1. Вона була представлена у UML 2 для відображення використання профілів. До її впровадження для відображення цієї проблеми використовувалися інші діаграми. . Див. також UML діаграми Примітки Посилання Крістоф Кечер: \"UML 2.0 - Das umfassende Handbuch\" Galileo Computing, 2006, Категорія:UML Категорія:Об'єктно-орієнтоване програмування Категорія:Програмування Категорія:Стандарти ISO"}
{"category": "Програмування", "title": "Додатки вікі", "abstract": "Додатки вікі — набір програм, що слугують для перетворення розмітки вікі в придатне для читання подання на мові HTML і взаємодії користувача з базою даних.", "content": "Додатки вікі — набір програм, що слугують для перетворення розмітки вікі в придатне для читання подання на мові HTML і взаємодії користувача з базою даних. thumb|Wiki Wiki Mart DekiWiki DekiWiki — вікі з відкритим кодом для організації цілей. Проект базується на МедіаВікі та його розвитку включає: Візуалізацію процесу створення сторінок (розвинутий wysiwyg-редактор), розвинутий пошук, гнучкі засоби для роботи з документами MS-Office, розробку мови для створення мешапів учасниками. Написаний на PHP, C#. DidiWiki DidiWiki — дуже маленький і дуже простий вікі-додаток. Написаний на C та має вбудований http-сервер. DokuWiki DokuWiki — легкий вікі-додаток, написаний на PHP, не потребує присутності бази даних (всю інформацію зберігає в файлах). З базами даних працює через плагіни, наявність в дистрибутиві файла mysql.conf.php.example говорить про можливості їх повноцінного підключення. Початково розроблявся, як додаток для створення і збереження різної документації в структурно нескладних організаціях. Повністю русифікований, використовує кодування UTF-8. Використовується сайтом php.net dominoWiki dominoWiki — OpenNTF.Org-проект вікі (англ.) для Lotus Notes/Domino FlexWiki FlexWiki — .NET-вікі. Розроблений співпрацівником фірми Microsoft та широко використовується в корпорації. Вміщує такі інструменти, як простори імен (namespaces) та вбудовану мову програмування (WikiTalk). Generic Applications Server HDWiki HDWiki — HDWiki website — додаток, розроблений для найбільшої в світі китайської онлайн-енциклопедії Hudong. Цей додаток використовується щонайменше на 1000 китайських сайтах. Включає функціональність соціальних мереж (профілі, групи по інтересах, форуми). Instiki Instiki — маленький вікі-додаток. Написаний на Ruby, має вбудовану базу даних і http-сервер. Розгортування на сервері в 3 кліки. Підтримується мова розмітки RedCloth. JSPWiki JSPWiki — вікі-додаток, написаний на JSP. thumb|Символ MediaWiki MediaWiki MediaWiki — орієнтований на веб додатки, написаний на PHP з використанням бази даних MySQL чи PostgreSQL. Розробка фонду «Вікімедіа», що використовує його для Вікіпедії та інших своїх вікі-сторінок. Розширюється за допомогою великої кількості додаткових модулів. MoinMoin MoinMoin — простий у використанні та розширюваний додаток, написаний на мові Python. Як сховище використовують файлову систему. Використовується в ряді сайтів. Підтримує ряд синтаксисів розмітки, в том числі Creole, reStructured, DocBook/XML/XSLT. Oddmuse Oddmuse — додаток, написаний на мові Perl.Складається з одного скрипту, для збереження документів використовується файлова система. Веде свою історію від WikiWikiWeb. Open Site Code Open Site Code — вікі-додаток, що увібрав у себе багато ідей Open Directory Project. PmWiki PmWiki — невеликий, безкоштовний та дуже гнучкий вікі-додаток, написаний на PHP. Легкий в установці та супроводженні. Має добре розвинуту мову розмітки сторінок. Дозволяє працювати автономно на локальному комп'ютері з урізаним PHP 4.4 — сервером. Не потребує бази даних, всі записи зберігає в файлах. Легко розширюється за допомогою великої кількості безкоштовних плагінів (рецептів) та скінів. Розвинуті засоби доступу. Русифікований, але існують складності з пошуком по тексту в кодуванні UTF8. Rumba Wiki Rumba Wiki — простий та компактний (~25 Кб) вікі-додаток з автоматичним перегортуванням сторінок, написаний на PHP. Підтримує російську мову. TiddlyWiki TiddlyWiki — TiddlyWiki — вікі-органайзер, написаний на JavaScript. являє собою 1 HTML-файл, котрий всі зміни зберігає сам в собі. Для роботи потребує тільки браузер. Є русифікований варіант. Остання англомовна версія — 2.6.5. TWiki TWiki — вікі-додаток на мові Perl. Орієнтований на використання в техніці. Використовується переважно як сховище стандартів і норм, системи документообороту на великих та середніх підприємствах. 27.10.2008 від проекту відділився NextWiki, який пізніше був перейменований в Foswiki. WakkaWiki WakkaWiki - додатки, основані на ньому: WackoWiki WikkaWiki — вікі-додаток, написаний на PHP та продовжує розвиток припиненої розробки проекту WikiNi (англ.) WikidPad WikidPad — простий вікі-додаток для персонального використання. Дозволяє створювати свою власну Вікіпедію на домашньому комп'ютері. являє собою текстовий редактор сполучений з базою даних і можливістю експорту сторінок в HTML/XML. WikiPad WikiPad — простий і не великий (розміром біля 100 Кб) вікі-додаток, написаний на PHP. Вся інформація зберігається в простих текстових файлах. Додаток не потребує спеціальної установки, може легко допрацьовуватись під свої потреби, має ряд властивостей: формування статичного сайту однією кнопкою, можливість завантажувати сторінки з вікі-розміткою через FTP, а не тільки через вебінтерфейс та ін. ZWiki ZWiki — багатомовний вікі-додаток для сервера додатків Zope і системи публікацій Plone Zen-wiki Zen-wiki — простий вікі-додаток, написаний на python для Google_App_Engine. підтримує синтаксис Markdown та підсвітку кода. Редагувати вікі може тільки власник. Також доступний у вигляді сервісу. Категорія:Програмування Категорія:Вікі"}
{"category": "Програмування", "title": "Додаток (програма)", "abstract": "Додаток (англ. add-on) в програмуванні — це клас відносно невеликих програм, що доповнюють і розширюють можливості основного застосунку (англ. application) або ж міняють його зовнішній вигляд. Ці програми використовують дозволений і окремо специфікований програмний інтерфейс основного застосунку і мають сенс тільки в межах основного застосунку.\nВиробники програмного забезпечення називають ці продукти по різному: доповнення (англ. add-on), вставка (англ. plug-in), розширення (англ. extension), іноді модуль (англ. module). Хоча деякі розробники навіть будують внутрішні ієрархії з цих понять, в цілому індустрія не виробила стандартних визначень для них, і їхнє використання визначається в рамках кожної компанії чи спільноти розробників.\nЯк правило розробники зацікавлені в створенні системи додатків до своїх провідних продуктів. Додатки не тільки забезпечують гнучку систему налаштування і розширення під потреби користувача — така модульна архітектура допомагає залучити до розробки численних незалежних розробників, які пропонують свої розробки на платній чи безплатній основі.\nПрикладами можуть служити додатки Mozilla, додаткові модулі Eclipse, розширення Microsoft Visual Studio чи додатки Microsoft Flight Simulator.", "content": "Додаток () в програмуванні — це клас відносно невеликих програм, що доповнюють і розширюють можливості основного застосунку () або ж міняють його зовнішній вигляд. Ці програми використовують дозволений і окремо специфікований програмний інтерфейс основного застосунку і мають сенс тільки в межах основного застосунку. Виробники програмного забезпечення називають ці продукти по різному: доповнення (), вставка (), розширення (), іноді модуль (). Хоча деякі розробники навіть будують внутрішні ієрархії з цих понять, в цілому індустрія не виробила стандартних визначень для них, і їхнє використання визначається в рамках кожної компанії чи спільноти розробників. Як правило розробники зацікавлені в створенні системи додатків до своїх провідних продуктів. Додатки не тільки забезпечують гнучку систему налаштування і розширення під потреби користувача — така модульна архітектура допомагає залучити до розробки численних незалежних розробників, які пропонують свої розробки на платній чи безплатній основі. Прикладами можуть служити додатки Mozilla, додаткові модулі Eclipse, розширення Microsoft Visual Studio чи додатки Microsoft Flight Simulator. Див. також Плагін Поточний список встановлених розширень MediaWiki Категорія:Програмування"}
{"category": "Програмування", "title": "Документація програмного забезпечення", "abstract": "Документація програмного забезпечення(англ. software documentation) - супроводжуючі документи до програмного забезпечення, які містять в собі інформацію, що описує загальні положення необхідні для ознайомлення перед тим як використовувати його за призначенням. Така документація дуже важлива і описує не тільки яким чином правильно використовувати поставлене програмне забезпечення, а й пояснює основні використані алгоритми. В залежності від складності кожного окремого програмного забезпечення, його специфіки, а також ліцензії під якою воно створене - документація може варіюватися за обсягом і за змістом.", "content": "Документація програмного забезпечення() - супроводжуючі документи до програмного забезпечення, які містять в собі інформацію, що описує загальні положення необхідні для ознайомлення перед тим як використовувати його за призначенням. Така документація дуже важлива і описує не тільки яким чином правильно використовувати поставлене програмне забезпечення, а й пояснює основні використані алгоритми. В залежності від складності кожного окремого програмного забезпечення, його специфіки, а також ліцензії під якою воно створене - документація може варіюватися за обсягом і за змістом. Основні компоненти специфікація - перелік і призначення всіх файлів програмного виробу, включаючи файли документації; відомість власників оригіналів - список підприємств, які зберігають оригінали програмних документів, складається тільки для складних програмних виробів; текст програми - запис кодів програми та коментарі до них; опис програми - інформація про логічну структуру та функціонування програми; програма і методика випробувань - перелік і опис вимог, які повинні бути перевірені в ході випробування програми, методи контролю; технічне завдання - документ, в якому викладаються призначення і область застосування програми, вимоги до програмного виробу, стадії і терміни розробки, види випробувань; пояснювальна записка - обґрунтування прийнятих і застосованих технічних і техніко-економічних рішень, схеми та опис алгоритмів, загальний опис роботи програмного виробу; До програмних документів віднесено також документи, що забезпечують функціонування та експлуатацію програм - експлуатаційні документи: відомість експлуатаційних документів - містить список експлуатаційних документів на програмний виріб, до яких відносяться формуляр, опис застосування, керівництво системного програміста, керівництво програміста, керівництво оператора, опис мови, керівництво з технічного обслуговування; формуляр - містить основні характеристики програмного виробу, склад і відомості про експлуатацію програми; опис застосування - містить інформацію про призначення та галузі застосування програмного виробу, обмеження при застосуванні, клас і методи вирішуваних завдань, конфігурацію технічних засобів; керівництво системного програміста - містить відомості для перевірки, настроювання і функціонування програми при конкретному застосуванні; керівництво програміста - містить відомості для експлуатації програмного виробу; керівництво оператора - містить докладну інформацію для користувача, який забезпечує його спілкування з ЕОМ у процесі виконання програми; опис мови - містить синтаксис і семантику мови; керівництво з технічного обслуговування - містить відомості для застосування тестових і діагностичних програм при обслуговуванні технічних засобів. Стандартизація програм На сьогодні існує цілий комплекс стандартів, які регламентують різні аспекти життєвого циклу ПЗ. До їх розробки були залучені такі міжнародні організації, як IEEE (Institute of Electrical and Electronic Engineers, Інститут інженерів з електротехніки та електроніки), ISO (International Standards Organization, Міжнародна організація зі стандартизації), EIA (Electronic Industry Association, Асоціація електронної промисловості), IEC (International Electrotechnical Commission, Міжнародна комісія з електротехніки), а також деякі національні дослідні інститути (ANSI, American National Standards Institute, Американський національний інститут стандартів; SEI, (Software Engineering Institute, Інститут програмної інженерії). Посилання International Organization for Standardization Міжнародна організація зі стандартизації Закон про стандартизацію Закон про захист інформації в інформаційно-телекомунікаційних системах Закон про авторське право Категорія:Цифрові обчислення Категорія:Програмування Категорія:Комп'ютерні технології Категорія:Технічна комунікація Категорія:Документування програмного забезпечення"}
{"category": "Програмування", "title": "Домовленості про стиль коду", "abstract": "Норми кодування (англ. Coding conventions) — це сукупність вказівок, що стосуються певної конкретної мови програмування і встановлюють правила стильового оформлення коду, практики та методи написання програм цією мовою. Ці норми зазвичай охоплюють організацію файлів, відступи, коментарі, оголошення, інструкції, пропуски, норми найменування, практики та принципи програмування, емпіричні правила програмування, найкращі архітектурні практики та ін.. Це поради стосовно структурної якості програмного забезпечення. Розробникам програмного забезпечення наполегливо рекомендується слідувати цим вказівкам, щоб покращити читабельність їхнього коду та полегшити підтримку програмного забезпечення. Норми кодування застосовні лише до людей-підтримувачів та рецензентів програмного забезпечення. Норми можуть бути формалізовані в документованому наборі правил, яких дотримується ціла команда чи компанія, або бути такими ж неформальними, як звичні індивідуальні практики кодування. Норми кодування не нав'язуються компіляторами. А отже, не дотримання деяких, чи навіть всіх правил не впливає на ефективність виконання програмного коду.", "content": "Норми кодування () — це сукупність вказівок, що стосуються певної конкретної мови програмування і встановлюють правила стильового оформлення коду, практики та методи написання програм цією мовою. Ці норми зазвичай охоплюють організацію файлів, відступи, коментарі, оголошення, інструкції, пропуски, норми найменування, практики та принципи програмування, емпіричні правила програмування, найкращі архітектурні практики та ін.. Це поради стосовно структурної якості програмного забезпечення. Розробникам програмного забезпечення наполегливо рекомендується слідувати цим вказівкам, щоб покращити читабельність їхнього коду та полегшити підтримку програмного забезпечення. Норми кодування застосовні лише до людей-підтримувачів та рецензентів програмного забезпечення. Норми можуть бути формалізовані в документованому наборі правил, яких дотримується ціла команда чи компанія, або бути такими ж неформальними, як звичні індивідуальні практики кодування. Норми кодування не нав'язуються компіляторами. А отже, не дотримання деяких, чи навіть всіх правил не впливає на ефективність виконання програмного коду. Підтримка програмного забезпечення Зменшення затратності підтримки програмного забезпечення є найбільш поширеною причиною дотримання норм кодування. У своїй передмові до норм програмування мовою Java, Sun Microsystems наводить такі міркування: Норми кодування важливі для розробників програмного забезпечення з кількох причин: 40 %–80 % загальної вартості програмного забезпечення витрачається на його утримання.Robert L. Glass: Facts and Fallacies of Software Engineering; Addison Wesley, 2003. Майже ніколи програмне забезпечення не підтримується до самого кінця своїм початковим автором. Норми кодування покращують читабельність програмного забезпечення, дозволяючи розробникам швидше й краще розбиратись в новому коді. Подібно до всякого іншого продукту, програмне забезпечення має бути «добре упакованим» і чистим. Програмна інженерія Програмна інженерія це процес розробки змісту та дизайну проєкту. Вона є визначальною в питаннях успіху проєктів, зокрема й великих. Процес програмної інженерії — це те, що доводить процес кодування до успішного завершення. Хороша програмна інженерія задає різницю між проєктами успішним — у фінансовому й технічному розумінні — та такими, що, в найгіршому випадку, перебувають у стані «клінічної смерті». Хороша програмна інженерія зведе до мінімуму подальші витрати і підвищить успіх проєкту на ринку. Документація проєкту Згідно з нормами кодування, проєкт повинен містити наступні документи: Досьє проєкту (). Процес розробки починається зі створення цього документу. Строго кажучи, це лише короткий опис проєкту, що входить до ланцюга його офіційних документів. Опис вимог (). В цьому документі вказується, що саме робить проєкт. Він є найважливішим в ланцюгу документів, усі інші документи тісно пов'язані з ним. Дизайн проєкту (). Це офіційний документ з описом дизайну. Він перелічує модулі й компоненти, описує їх інтерфейси та пояснює зв'язки між ними. Програмний інженер, що працює над цим документом виконує такі завдання: Вибір найкращого варіанту дизайну з наявних опцій на основі їх аналізу. Ананіз всі аспекти, зокрема технічні, комерційні, питання якості, адміністрування й логістики. Це передбачає й час та вартість розробки, утримання, підтримки й використання — як поточні, так і подальші. Опис тестів (). Цей документ описує всі тести, які має пройти проєкт, та результати, яких варто чекати від такого тестування. Дуже часто тестування виконується спеціальними програмними пакетами, а отже ці тести описуються відповідними файлами. Результати тестів (). Опис проєкту від досьє до результатів тестування становить так званий ланцюг документів. Кожен документ пов'язаний з попереднім відношенням «один до одного». Крім того, опис тестів пов'язаний з описом вимог. Ланцюг документів двонапрямний — опис іде вниз, результати повертаються нагору. Ці методи називаються формальними. Рефакторинг Рефакторинг — це процес зміни існуючого коду для його вдосконанлення та відповідності існуючим домовленостям про стиль коду без зміни його поведінки. Рефакторинг існуючого коду є важливою складовою його підтримки та потенційно переслідує такі цілі: Вдосконалення дизайну, структури та імплементації програмного забезпечення. Збільшення читабельності та спрощення сирцевого коду. Сприяння ефективній підтримці програмного забезпечення — пришвидшення додавання нового функціоналу. Ефективне використання апаратного забезпечення, збільшення швидкості виконання коду. Практика норм кодування Існують декілька підходів до покращення читабельності коду, серед них такі: Домовленості з найменування змінних, функцій та класів. Дотримання правил відступів, пробілів та знаків табуляції. Додавання коментарів в код для сприяння розумінню функціоналу. Домовленості з найменування Першочергова ціль правил найменування змінних значно спрощує розуміння сирцевого коду та ролі конкретної змінної. Кожна змінна повинна мати чітку та лаконічну назву, що надає семантики кінцевому коду. Вибране правило найменування змінних має бути дотриманим в усьому коді Різні мови програмування можуть мати різні норми найменування змінних, що дозволяє розрізняти операнди та ключові слова. В свою чергу, найменування змінних підрозділяються на такі варіанти: Зміїний регістр У формі нотації \"зміїний регістр\" () використовується знак підкреслення для виділення окремих слів в назві змінної: var_one var_two регістр Паскаля Регістр Паскаля () передбачає виділення окремих слів за рахунок перших букв кожного з них в верхньому регістрі: VarOne VarTwo Верблюжий регістр Верблюжий регістр () повторює Pascalcase - кожне слово виділяєтья першою буквою у верхньому регістрі за винятком першої букви: varOne varTwo Шашличний регістр Шашличний регістр () повторює підхід зміїного регістру з розділенням слів в найменуванні знаками пунктуаціями, для цього використовуються знаки тире (dash, '-'): var-one var-two Угорська нотація В Hungarian Notation (Угорській нотації) виділяється перше слово найменування, що визначає тип змінної, а решта слів визначає її функцію. Приклад такої нотації в Camel case: arrExpVarOne // букв. \"масив, приклад змінної 1\" intExpVarTwo // букв. \"ціле число, приклад змінної 2\" All caps All caps (All capitals, всі великі) має всі літери в верхньому регістрі та застосовується для позначення констант у коді: CONST_ONE CONST_TWO Примітки Посилання Норми кодування для мов ActionScript: Flex SDK coding conventions and best practices Ada: Ada 95 Quality and Style Guide: Guidelines for Professional Programmers Ada: Guide for the use of the Ada programming language in high integrity systems (ISO/IEC TR 15942:2000) Ada: NASA Flight Software Branch — Ada Coding Standard Ada: European Space Agency's Ada Coding Standard (BSSC(98)3) C: Ganssle Group's Firmware Development Standard C: Netrino Embedded C Coding Standard C: Install Java On Windows C++: Quantum Leaps C/C++ Coding Standard C++: C++ Programming/Programming Languages/C++/Code/Style Conventions C++: GeoSoft's C++ Programming Style Guidelines C++: Google's C++ Style Guide C++: High Integrity C++ C#: C# Coding Conventions (C# Programming Guide) C#: Design Guidelines for Developing Class Libraries C#: Brad Abrams C#: Philips Healthcare D: The D Style Dart: The Dart Style Guide Erlang: Erlang Programming Rules and Conventions Flex: Code conventions for the Flex SDK Java: Ambysoft's Coding Standards for Java Java: Code Conventions for the Java Programming Language Java: GeoSoft's Java Programming Style Guidelines Java: Java: SoftwareMonkey's Coding Standards for Java and other C-like languages JavaScript: Code Conventions for the JavaScript Programming Language Lisp: Riastradh's Lisp Style Rules MATLAB: Neurobat Coding Conventions for MATLAB Mono: Programming style for Mono Object Pascal: Object Pascal Style Guide Perl: Perl Style Guide PHP::PEAR: PHP::PEAR Coding Standards PHP::FIG: PHP Framework Interop Group Python: Style Guide for Python Code Ruby: The Unofficial Ruby Usage Guide Ruby: GitHub Ruby style guide Норми кодування для проєктів Apache Developers' C Language Style Guide Drupal PHP Coding Standards Zend Framework Coding Standards GNU Coding Standards Style guides for Google-originated open-source projects Linux Kernel Coding Style (or Documentation/CodingStyle in the Linux Kernel source tree) ModuLiq Zero Indent Coding Style Mozilla Coding Style Guide Road Intranet's C++ Guidelines The NetBSD source code style guide (formerly known as the BSD Kernel Normal Form) OpenBSD Kernel source file style guide (KNF) (PDF ) Категорія:Програмування Категорія:Незавершені статті про програмування Категорія:Програмна інженерія"}
{"category": "Програмування", "title": "Енергетичне моделювання", "abstract": "Енергетичне моделювання або моделювання енергетичної системи — процес побудови комп'ютерних моделей енергетичних систем для того, щоб проаналізувати їх. Такі моделі часто використовують аналіз сценарію для вивчення різноманітних припущень про технічні та економічні умови під час дії. Результати можуть показати ефективність системи, викиди парникових газів, загальні фінансові витрати, використання природних ресурсів та енергоефективність досліджуваної системи. Застосовується широкий спектр методів, починаючи від повністю економічного до повністю інженерного. Математична оптимізація часто використовується для визначення, в якомусь сенсі, найменшої вартості. Моделі можуть бути міжнародними, регіональними, національними, міськими чи автономними. Уряди підтримують національне енергетичне моделювання для розвитку енергетичної політики.\nЕнергетичне моделювання, як правило, покликані сприяти різним системним операціями, інженерне проектування або розробки енергетичної політики. Енергетичне моделювання окремої будівлі очевидно виключені, хоча вони також іноді називаються енергетичними моделями. Інтегровані моделі в стилі Міжурядової групи експертів з питань змін клімату (МГЕЗК, від англ. IPCC - Intergovernmental Panel on Climate Change), які також мають уявлення про світову енергетичну систему і використовуються для вивчення глобальних шляхів трансформації до 2050 або 2100.\nЕнергетичне моделювання набуває все більшого значення, так як важливість пом'якшення наслідків зміни клімату стала більш важливою. Сектор енергозабезпечення є найбільшим джерелом глобальних викидів парникових газів. МГЕЗК повідомляє, що пом'якшення наслідків зміни клімату потребує кардинальної зміни системи енергопостачання, в тому числі включаючи заміну неосвоєної (окрім процесу захоплення та зберігання вуглецю) технології переробки викопного палива на альтернативи з низьким рівнем викиду парникових газів.", "content": "Енергетичне моделювання або моделювання енергетичної системи — процес побудови комп'ютерних моделей енергетичних систем для того, щоб проаналізувати їх. Такі моделі часто використовують аналіз сценарію для вивчення різноманітних припущень про технічні та економічні умови під час дії. Результати можуть показати ефективність системи, викиди парникових газів, загальні фінансові витрати, використання природних ресурсів та енергоефективність досліджуваної системи. Застосовується широкий спектр методів, починаючи від повністю економічного до повністю інженерного. Математична оптимізація часто використовується для визначення, в якомусь сенсі, найменшої вартості. Моделі можуть бути міжнародними, регіональними, національними, міськими чи автономними. Уряди підтримують національне енергетичне моделювання для розвитку енергетичної політики. Енергетичне моделювання, як правило, покликані сприяти різним системним операціями, інженерне проектування або розробки енергетичної політики. Енергетичне моделювання окремої будівлі очевидно виключені, хоча вони також іноді називаються енергетичними моделями. Інтегровані моделі в стилі Міжурядової групи експертів з питань змін клімату (МГЕЗК, від ), які також мають уявлення про світову енергетичну систему і використовуються для вивчення глобальних шляхів трансформації до 2050 або 2100. Енергетичне моделювання набуває все більшого значення, так як важливість пом'якшення наслідків зміни клімату стала більш важливою. Сектор енергозабезпечення є найбільшим джерелом глобальних викидів парникових газів. МГЕЗК повідомляє, що пом'якшення наслідків зміни клімату потребує кардинальної зміни системи енергопостачання, в тому числі включаючи заміну неосвоєної (окрім процесу захоплення та зберігання вуглецю) технології переробки викопного палива на альтернативи з низьким рівнем викиду парникових газів. Типи моделей Використовуються найрізноманітніші типи моделей. Моделям, взагалі, може знадобитись захопити складну динаміку, таку як: робота енергетичної системи технологія обороту запасів інноваційні технології поведінка компанії і домашнього господарства енергетичні і не енергетичні капіталовкладення та динаміка корегування ринку праці, які ведуть до економічної реконструкції розгортання структури і міського планування Моделі можуть бути обмежені певним електричним сектором, або можуть спробувати охопити всю енергетичну систему. Більшість енергетичних моделей використовуються для аналізу сценарію. Сценарій — це послідовний набір припущень про можливу систему. Нові сценарії тестують для порівняння щодо базового сценарію — зазвичай буденна справа — і відзначають відмінність в результатах Важливим фактором є часовий горизонт моделі. Однорічні моделі — встановлені або в сьогодні або в майбутньому (скажімо, у 2050) — припускають не розвиток структури капіталу, натомість зосереджуються на оперативній динаміці системи. Однорічні моделі зазвичай мають вбудовані значні часові (зазвичай погодинний дозвіл) і технічні деталі (наприклад, окремі фабрики і лінії трансмісій). Довготривалі моделі — які тривають протягом одного або декількох десятиліть (від нині і, скажімо, до 2050 г.) — намагаються інкапсулювати структурну еволюцію системи і використовуються для вивчення проблем розширення потужностей і переходу енергосистеми. Моделі часто використовують математичну оптимізацію для вирішення надлишку в специфікації системи. Деякі з використовуваних методів є наслідком дослідження операцій. Більшість покладається на лінійне програмування (в тому числі програмування зі змішаними цілими числами), хоча деякі використовують нелінійне програмування. Обчислювачі можуть використовувати класичну або генетичну оптимізацію, такі як KMA-СЕ (Коваріаційна матриця Адаптації — стратегія еволюції, від англ. CMA-ES — Covariance Matrix Adaptation — Evolution Strategy). Моделі можуть бути рекурсиво-динамічними, такими, що послідовно вирішують для кожного часового інтервалу, а, отже, розвиваються з часом. Або ж вони можуть бути оформлені у вигляді однієї майбуньої міжчасової проблеми, і тим самим припускати, ідеальні передбачення. Однорічні інженерні моделі, як правило, намагаються мінімізувати короткострокові фінансові витрати, в той час як однорічні ринкові моделі використовувати оптимізацію для визначення ринкового клірингу. Довгострокові моделі, як правило, охоплюють кілька десятиліть, намагаються звести до мінімуму як короткострокові, так і довгострокові витрати як однієї міжчасової проблеми. Попит (або домен кінцевого користувача) історично отримав відносно мало уваги, часто моделюється лише проста крива попиту. Криві споживання енергії кінцевого користувача, принаймні в короткостроковій перспективі, як правило, виявляються вельми нееластичними. Поступово, як нестійкі джерела енергії та управління попитом на енергію стають все більш вагомим, моделі повинні були запровадити погодинний тимчасовий дозвіл, щоб краще фіксувати їхню динаміку в реальному часі. Довгострокові моделі часто обмежені розрахунками з щорічними інтервалами, на основі типових денних профілів, і, отже, менш підходить для систем зі значною зміною обновлюваної енергії. Реалізація мов включає GAMS, MathProg, MATLAB, Python, R, Fortran, Java, C, C ++ і Vensim. Іноді використовуються електронні таблиці. Інтегровані МГЕЗК моделі поєднують в собі спрощені під моделі світової економіки, сільського господарства та землекористування, а також глобальної кліматичної системи на додаток до світової енергетичної системи. Наприклад, Глобальну модель зміни оцінювання, повідомлення і нагадування. Опубліковані дослідження з моделювання енергетичної системи були зосереджені на методах, загальній класифікації, огляді, децентралізованому плануванні, методах моделювання, поновлюваних джерелах енергії, політики галузевої енергоефективності, інтеграції електричних засобів транспорту, міжнародному розвитку, і на використанні багаторівневих моделей для підтримки політики захисту клімату. Дослідники проекту шляхів повної декарбонізації також проаналізували моделі типологій. Документ 2014 року описує задачі моделювання у майбутньому, оскільки енергетичні системи стають все більш складними, а людський і соціальний фактори стають все більш актуальними. Моделі електроенергетичного сектора Моделі сектора електроенергії використовуються для моделювання електроенергетичних систем. Масштаби можуть бути національними або регіональними, в залежності від обставин. Наприклад, з огляду на наявність міжнаціональних зв'язку, європейська система західної електроенергії може бути змодельована в повному обсязі. Інженерні моделі, як правило, містять хорошу характеристику використаних технологій, в тому числі мережі передачі змінного струму високої напруги, де це необхідно. Деякі моделі (наприклад, моделі для Німеччини) можуть приймати одну загальну шину або «мідну пластину», де решітка є сильною. Попит в сфері моделювання електроенергетичного сектора, як правило, представлений в профілі фіксованого навантаження. Ринкові моделі, крім того, являють собою переважаючий ринок електроенергії, який може включати в себе вузлове ціноутворення. Теорія ігор і модель на основі агентів використовуються для збору і вивчення стратегічної поведінки на ринках електроенергії. Моделі енергосистеми На додаток до галузі електроенергетики, енергосистема модель включає в себе тепло, газ, мобільність і інші сектори, якщо це потрібно. Моделі енергосистем часто національний характер, але може бути й муніципальними (міським) або міжнародними. Так звані спадні моделі цілковито економічного характеру за походженням і базуються на частковій або повній рівновазі. Моделі загальної рівноваги мають спеціалізовану діяльність і вимагають чітко визначених алгоритмів. Частково рівноважні моделі є більш поширеними. Так звані висхідні моделі захоплюють інженерію і часто опираються на методи з дослідницьких операцій. Окремі заводи характеризуються їхніми кривими ефективності (також відомі як вхідні / вихідні відносини), номінальна потужність, інвестиційні витрати (CAPEX) і експлуатаційні витрати (OPEX). В деяких моделях ці параметри залежать від зовнішніх умов, таких як температура навколишнього середовища. Виробництво гібридних: моделей зверху вниз / знизу вверх, щоб захопити як економіку та інженерію, виявилося складним завданням. Штатні моделі Вони, як правило, у віданні національних урядів: LEAP LEAP (Альтернативна енергетична система планування на великих відстанях) являє собою програмний інструмент для аналізу енергетичної політики і оцінки пом'якшення наслідків зміни клімату. LEAP була розроблена в SEI Центрі Стокгольмського Інституту навколишнього середовища в США. LEAP може бути використана для вивчення міських, загальнодержавних, національних і регіональних енергетичних систем. LEAP зазвичай використовується для прогнозування досліджень, які триватимуть приблизно від 20 до 50 років. Велика частина розрахунків відбувається інтервалом в один рік. LEAP дозволяє аналітикам політикам створювати й оцінювати альтернативні сценарії і порівняти їх енергетичні потреби, соціальні витрати і вигоди, а також вплив на навколишнє середовище. MARKAL/TIMES MARKAL (Allocation MARKET) являє собою інтегровану платформу енергетичних систем моделювання, що використовуються для аналізу енергетичних, економічних і екологічних проблем на глобальному, національному та муніципальному рівні за період до декількох десятиліть. MARKAL може бути використана для кількісної оцінки взаємодії опцій політики, технічного розвитку і виснаження природних ресурсів. Програмне забезпечення було розроблене Програмою аналізу систем енергетичних технологій (ETSAP) Міжнародного енергетичного агентства (МЕА), протягом майже 20 років. TIMES (Інтегрована система MARKAL-EFOM є еволюцією MARKAL — обидві енергетичні моделі мають багато подібного. TIMES замінила MARKAL в 2008 році. Обидві моделі є технологічно точними, динамічними моделями часткової рівноваги на ринках енергетики. В обох випадках рівновага визначається шляхом максимізації загальної користі і для споживачів і для виробників за допомогою лінійного програмування. І MARKAL і TIMES написані в Гамс. Генератор моделі TIMES також був розроблений в рамках технології програмної системи аналізу енергії (ETSAP). TIMES поєднує в собі два різних, але доповнюючих один одного, системні підходи до моделювання енергії — інженерний і економічний підхід. TIMES використовує технологію моделі генератора «від низу до верху», яка використовує лінійне програмування для одержання найменшої вартості енергетичної системи, оптимізованої відповідно до числа певних обмежень користувача, від середньо- до довготривалого. Він використовується для «дослідження можливих майбутніх енергоносіїв на основі різних сценаріїв». рік, моделі генераторів MARKAL і TIMES використовуються в 177 установах в більш ніж в 70 країнах. NEMS NEMS ( — Національна система енергетичної моделі) є давньою моделлю державної політики Сполучених Штатів, за якою працює Департамент енергетики (DOE). НЕМС обчислює рівну ціну на паливо і потрібну кількість для енергетичного сектора США. Для цього, програмне забезпечення циклічно вирішує послідовність лінійних програм і нелінійних рівнянь. НЕМС використовується для моделювання попиту, зокрема, щоб визначити вибір споживачем технологій в житловому і комерційному секторах. NEMS використовується для створення Щорічного енергетичного результату — наприклад, в 2015 році. Критика Енергетичні моделі державної політики були піддані критиці за те, що недостатньо прозорі. Код і дані багатьох джерел повинні хоча б бути доступні для експертної оцінки, якщо не опубліковані. З метою підвищення прозорості та громадського визнання, деякі моделі проводяться у вигляді програмних проектів з відкритим вихідним кодом, часто розвиваються різноманітні співтовариства, коли вони починають діяти. OSeMOSYS є одним з таких товариств. Див. також Climate change mitigation — actions to limit long-term climate change Climate change mitigation scenarios — possible futures in which global warming is reduced by deliberate actions Economic model Energy system — the interpretation of the energy sector in system terms Energy Modeling Forum — a Stanford University-based modeling forum Open Energy Modelling Initiative — an open source energy modeling initiative, centered on Europe Open energy system databases — database projects which collect, clean, and republish energy-related datasets Open energy system models — a review of energy system models that are also open source Моделі ACEGES — a global agent-based computational economics model iNEMS (Integrated National Energy Modeling System) — a national energy model for China MARKAL — an energy model NEMS — the US government national energy model Prospective Outlook on Long-term Energy Systems (POLES) — an energy sector world simulation model Примітки Посилання COST TD1207 Mathematical Optimization in the Decision Support Systems for Efficient and Robust Energy Networks wiki — a typology for optimization models EnergyPLAN — a freeware energy model from the Department of Development and Planning, Aalborg University, Denmark Open Energy Modelling Initiative open models page — a list of open energy models Тичковський Р., Цегелик Г. Математичне моделювання оптимального використання потужностей еом в обчислювальних мережах Львів 2003, Вісник ЛНУ. ім. І.Франка Категорія:Обчислювальні науки Категорія:Програмування Категорія:Економічне моделювання Категорія:Енергія Категорія:Енергетична політика Категорія:Математичне моделювання Категорія:Дослідження операцій Категорія:Наукове моделювання Категорія:Симуляція Категорія:Теорія систем"}
{"category": "Програмування", "title": "З'єднувальний код", "abstract": "З'єднувальний код (англ. glue code) — технологія в програмуванні, яка за допомогою додавання допоміжного коду до коду основної програми дозволяє використовувати інші функції, бібліотеки або фрагменти коду, що буди створені за іншою технологією або написані іншою мовою програмування. Ця технологія дозволяє використовувати разом частини програмного забезпечення, яке не сумісне між собою, без потреби їхньої зміни.\nЗ'єднувальний код часто використовується в технології побудови інтерфейсу до зовнішніх функцій, такого як Java Native Interface, або для можливості використання фрагментів іншої мови програмування (наприклад, SQL) в тексті основного коду.\nЗ'єднувальний код може бути сформований як основною мовою програмування, так й через застосування скриптових мов програмування.\nЗ'єднувальний код ефективний у середовищах швидкого прототипування, де часто потрібно швидко об'єднувати декілька компонентів в один застосунок та керувати ними.", "content": "З'єднувальний код () — технологія в програмуванні, яка за допомогою додавання допоміжного коду до коду основної програми дозволяє використовувати інші функції, бібліотеки або фрагменти коду, що буди створені за іншою технологією або написані іншою мовою програмування. Ця технологія дозволяє використовувати разом частини програмного забезпечення, яке не сумісне між собою, без потреби їхньої зміни. З'єднувальний код часто використовується в технології побудови , такого як Java Native Interface, або для можливості використання фрагментів іншої мови програмування (наприклад, SQL) в тексті основного коду. З'єднувальний код може бути сформований як основною мовою програмування, так й через застосування скриптових мов програмування. З'єднувальний код ефективний у середовищах швидкого прототипування, де часто потрібно швидко об'єднувати декілька компонентів в один застосунок та керувати ними. Обмеження Оскільки кожен компонент є незалежним й спроектований окремо, його поведінка може змінюватися під час виконання сценарію. Інша версія компоненту може поводитися по-іншому, ніж та версія компоненти, яка використовувалась при написанні та відлагоджуванні скрипта. Крім того, з'єднувальний код має обмежену можливість контролювати поведінку компонента. Використання з'єднувального коду може приводити до зменшення швидкості виконання програми, так як він використовує техніку інтерпретування. Якщо швидкість має значення, то часто замість з'єднувального коду використовують сценарії конфігурування. Див. також Адаптер Скриптова мова SWIG Lua Glue logic Обгортка бібліотеки Функція-заглушка Джерела Категорія:Програмування"}
{"category": "Програмування", "title": "Замикання (програмування)", "abstract": "У програмуванні замиканням (англ. closure), callback називають підпрограму, що виконується в середовищі, яке містить одну або більше зв'язаних змінних[що це?]. Підпрограма має доступ до цих змінних під час виконання.\nЗастосування замикань асоціюється з функційним програмуванням. У функціональному програмуванні за допомогою замикань можуть моделюватись такі конструкції, як об'єкти в інших мовах програмування.\nУ деяких мовах програмування[яких?] замикання створюється для підпрограм, що визначені всередині інших підпрограм, і внутрішня підпрограма має доступ до локальних змінних зовнішньої. Під час виконання, коли обчислюється зовнішня підпрограма, утворюється замикання, до якого потрапляє код внутрішньої підпрограми, та посилання на ті змінні зовнішньої підпрограми, що використовуються у внутрішній підпрограмі. Посилання на змінні зовнішньої підпрограми залишаються дійсними всередині вкладеної внутрішньої підпрограми доти, поки існує ця вкладена підпрограма, навіть якщо зовнішня підпрограма завершила виконання і вийшла з області видимості. Концепцію замикань було повністю розроблено в 1960-ті роки та реалізовано як особливість мови програмування Scheme. Відтоді було розроблено багато мов програмування з підтримкою замикань.", "content": "У програмуванні замиканням (), callback називають підпрограму, що виконується в середовищі, яке містить одну або більше зв'язаних змінних. Підпрограма має доступ до цих змінних під час виконання. Застосування замикань асоціюється з функційним програмуванням. У функціональному програмуванні за допомогою замикань можуть моделюватись такі конструкції, як об'єкти в інших мовах програмування. У деяких мовах програмування замикання створюється для підпрограм, що визначені всередині інших підпрограм, і внутрішня підпрограма має доступ до локальних змінних зовнішньої. Під час виконання, коли обчислюється зовнішня підпрограма, утворюється замикання, до якого потрапляє код внутрішньої підпрограми, та посилання на ті змінні зовнішньої підпрограми, що використовуються у внутрішній підпрограмі. Посилання на змінні зовнішньої підпрограми залишаються дійсними всередині вкладеної внутрішньої підпрограми доти, поки існує ця вкладена підпрограма, навіть якщо зовнішня підпрограма завершила виконання і вийшла з області видимості. Концепцію замикань було повністю розроблено в 1960-ті роки та реалізовано як особливість мови програмування Scheme. Відтоді було розроблено багато мов програмування з підтримкою замикань. Приклад реалізації на Lua function addfunc(x) return function(y) -- Повертає нову функцію без назви, яка додає x до аргументу return x + y -- Коли ми будемо посилатися на змінну x, що знаходиться поза даною областю й існування якої менше ніж даної безіменної функції, -- Lua створить замикання end end num_plus = addfunc(2) -- Тепер num_plus - функція, в якій замість x підставлено 2 print(num_plus(5)) -- В результаті буде виведено 7 Приклад на JavaScript Функції (зокрема в JS) можна зобразити як спеціальні об'єкти, що включають код, який можна запускати, а також властивості. Кожна функція має властивість [scope], котра відображає оточення на момент створення функції. Якщо ж функцію створено викликом з іншої функції, тоді це відображення старого оточення «перекривається» нової функцією і це називається замиканням. const myClosure = (function outerFunction() { let hidden = 1; return { innerFunction() { return hidden++; } }; }()); myClosure.innerFunction(); // повертає 1 myClosure.innerFunction(); // повертає 2 myClosure.innerFunction(); // повертає 3 Коли JS-код працює, локальні змінні зберігаються в scope. В JavaScript локальні змінні можуть лишатись в пам'яті навіть після того, як функція повернула значення. Створення замикання в JavaScript Усі функції в JavaScript — це замикання; коли задається функція — задається замикання. Так що замикання створюється при визначенні функції. Але треба розуміти різницю між створенням замикання і створенням нового scope-об'єкту: замикання (функція + посилання на поточний ланцюжок scope-об'єктів) створюється при визначенні функції, але новий scope-об'єкт створюється (і використовується для модифікації ланцюжка scope-об'єктів замикання) при виклику функції. Видалення замикання Збірник сміття обробляє і видаляє замикання, як і будь-який інший об'єкт у JavaScript, коли на нього більше немає посилань. Примітки Категорія:Програмування Категорія:Функційне програмування Категорія:Поняття мов програмування Категорія:Статті з прикладами коду мовою Lua Категорія:Статті з прикладами коду мовою JavaScript"}
{"category": "Програмування", "title": "Запахи коду", "abstract": "Код із запашком (код з душком, код, що погано пахне англ. code smell) — термін, що позначає код з ознаками (запахами) проблем в системі. Був введений Кентом Беком і використаний Мартіном Фаулером в його книзі «Рефакторинг. Поліпшення існуючого коду», з тих пір активно використовується розробниками ПЗ.\nЗапахи коду — це ключові ознаки необхідності рефакторингу. Існують запахи, специфічні як для парадигм програмування, так і для конкретних мов. Основною проблемою, з якою стикаються розробники при боротьбі з запахами коду, є те, що критерії своєчасності рефакторингу неможливо чітко формалізувати без апеляції до естетики і умовного почуття прекрасного. Запахи коду — це не набір чітких правил, а опис місць, на які потрібно звертати увагу при рефакторингу. Вони легко виявляються, але при цьому не у всіх випадках свідчать про проблеми.\nКод із запашком веде до розпаду коду, розробники повинні прагнути до усунення запашку шляхом застосування одноразового або багаторазового рефакторинга.\nУ процесі рефакторингу відбувається позбавлення від запахів коду, що забезпечує можливість подальшого розвитку додатків з тією ж або більшою швидкістю. Відсутність регулярного рефакторинга з плином часу здатна повністю паралізувати проект, тому запахи коду необхідно усувати на ранніх стадіях.\nІснують інструменти пошуку та виправлення запахів коду, проте досвід показує, що ніякі системи показників не можуть змагатися з людською інтуїцією, основаною на інформації.\nЧасто глибша проблема, вказана запахом коду, може бути розкрита, коли код піддається короткому циклу зворотного зв'язку, де вона перетворена в невеликі, керовані кроки, і отримана конструкція перевіряється, щоб побачити будь-які запахи коду, які можуть вказувати на необхідність більшого рефакторингу. З точки зору програміста, якому доручено виконувати рефакторинг, запах коду це евристичний алгоритм, який вказує, коли відбувався рефакторинг і які конкретні методи рефакторингу використовували. Таким чином, запах коду це наслідок рефакторингу. Але чому це відбувається?\nДослідження 2015 року з використанням автоматизованого аналізу півмільйона комітів і ручного обстеження 9,164 комітів встановило, що:\n\nІснує емпіричне підтвердження наслідків «технічного боргу», але існує лише непідтверджена інформація про те, як, коли і чому це відбувається.\n«Здоровий глузд підказує, що невідкладні заходи з технічного обслуговування і тиск, а також встановлення пріоритетів на ринку для створення більш якісного коду — є причинами таких запахів».\n\n", "content": "Код із запашком (код з душком, код, що погано пахне ) — термін, що позначає код з ознаками (запахами) проблем в системі. Був введений Кентом Беком і використаний Мартіном Фаулером в його книзі «Рефакторинг. Поліпшення існуючого коду», з тих пір активно використовується розробниками ПЗ. Запахи коду — це ключові ознаки необхідності рефакторингу. Існують запахи, специфічні як для парадигм програмування, так і для конкретних мов. Основною проблемою, з якою стикаються розробники при боротьбі з запахами коду, є те, що критерії своєчасності рефакторингу неможливо чітко формалізувати без апеляції до естетики і умовного почуття прекрасного. Запахи коду — це не набір чітких правил, а опис місць, на які потрібно звертати увагу при рефакторингу. Вони легко виявляються, але при цьому не у всіх випадках свідчать про проблеми. Код із запашком веде до розпаду коду, розробники повинні прагнути до усунення запашку шляхом застосування одноразового або багаторазового рефакторинга. У процесі рефакторингу відбувається позбавлення від запахів коду, що забезпечує можливість подальшого розвитку додатків з тією ж або більшою швидкістю. Відсутність регулярного рефакторинга з плином часу здатна повністю паралізувати проект, тому запахи коду необхідно усувати на ранніх стадіях. Існують інструменти пошуку та виправлення запахів коду, проте досвід показує, що ніякі системи показників не можуть змагатися з людською інтуїцією, основаною на інформації. Часто глибша проблема, вказана запахом коду, може бути розкрита, коли код піддається короткому циклу зворотного зв'язку, де вона перетворена в невеликі, керовані кроки, і отримана конструкція перевіряється, щоб побачити будь-які запахи коду, які можуть вказувати на необхідність більшого рефакторингу. З точки зору програміста, якому доручено виконувати рефакторинг, запах коду це евристичний алгоритм, який вказує, коли відбувався рефакторинг і які конкретні методи рефакторингу використовували. Таким чином, запах коду це наслідок рефакторингу. Але чому це відбувається? Дослідження 2015 року з використанням автоматизованого аналізу півмільйона комітів і ручного обстеження 9,164 комітів встановило, що: Існує емпіричне підтвердження наслідків «технічного боргу», але існує лише непідтверджена інформація про те, як, коли і чому це відбувається. «Здоровий глузд підказує, що невідкладні заходи з технічного обслуговування і тиск, а також встановлення пріоритетів на ринку для створення більш якісного коду — є причинами таких запахів». Запахи коду Загальні запахи об'єктно-орієнтованого коду Дублювання коду thumb | Приклад триразового дублювання коду та позбавлення від цього запашку за допомогою виділення методу і наступних викликів коду створеного методу Дублювання коду — це використання однакових структур коду в декількох місцях. Об'єднання цих структур дозволить поліпшити програмний код. Приклади дублювання і методи їх усунення: Один і той самий вираз, що присутній в двох методах одного і того ж класу, то необхідно застосувати «Відокремлення методу» (Extract Method) і викликати код створеного методу з обох точок; Один і той самий вираз є в двох підкласах, що знаходяться на одному рівні: необхідно застосувати «Виділення методу» (Extract Method) для обох класів з подальшим «Підйомом поля» (Pull Up Field) або «Формуванням шаблону методу» (Form Template Method), якщо код схожий, але не збігається повністю. Якщо обидва методи роблять одне і те ж за допомогою різних алгоритмів, можна вибрати більш чіткий з цих алгоритмів і застосувати «Заміщення алгоритму» (Substitute Algorithm); Дублювання коду знаходиться в двох різних класах: необхідно застосувати «Виділення класу» (Extract Class) в одному класі, а потім використовувати новий компонент в іншому. Довгий метод Серед об'єктних програм найдовше живуть програми з короткими методами. Чим довша процедура, тим важче її зрозуміти. Якщо у методу гарна назва, то не потрібно дивитися його тіло. Слід дотримуватися евристичного правила: якщо відчувається необхідність щось прокоментувати, потрібно написати метод. Навіть один рядок має сенс виділити в метод, якщо він потребує роз'яснень. Для скорочення методу досить застосувати «Виділення методу» (Extract Method); Якщо локальні змінні і параметри перешкоджають виділенню методу, можна застосувати «Заміну тимчасової змінної викликом методу» (Replace Temp with Query), «Введення граничного об'єкту» (Introduce Parametr Object) і «Збереження всього об'єкта» (Preserve Whole Object); Умовні оператори і цикли свідчать про можливість виділення в окремий метод. Для роботи з умовними виразами підходить «Декомпозиція умовних операторів» (Decompose Conditional). Для роботи з циклом — «Виділення методу» (Extract Method). Великий клас Коли клас реалізує занадто велику функціональність, варто подумати про винесення деякої частини коду в підклас. Це позбавить розробників від надмірної кількості наявних у класу атрибутів і дублювання коду. Для зменшення класу використовується «Виділення класу» (Extract Class) або «Виділення підкласу» (Extract Subclass). При цьому слід звертати увагу на спільність у назві атрибутів і на те, чи використовує клас їх всі одночасно; Якщо великий клас є класом GUI, може знадобитися переміщення його даних і поведінку в окремий об'єкт предметної області. При цьому може виявитися необхідним зберігати копії деяких даних у двох місцях і забезпечити їх узгодженість. «Дублювання видимих ​​даних» (Duplicate Observed Data) пропонує шлях, яким можна це здійснити. Довгий список параметрів У довгих списках параметрів важко розбиратися, вони стають суперечливими і складними у використанні. Використання об'єктів дозволяє, в разі зміни переданих даних, модифікувати тільки сам об'єкт. Працюючи з об'єктами, слід передавати рівно стільки, щоб метод міг отримати необхідні йому дані. «Заміна параметра викликом методу» (Replace Parameter with Method) застосовується, коли можна отримати дані шляхом виклику методу об'єкта. Цей об'єкт може бути полем або іншим параметром. «Збереження всього об'єкта» (Preserve Whole Object) дозволяє взяти групу даних, отриманих від об'єкта, і замінити їх цим об'єктом. «Введення граничного об'єкта» (Introduce Parameter Object) застосовується, якщо є кілька елементів даних без логічного об'єкта. Розбіжні модифікації Проблема виникає, коли при модифікації в системі неможливо виділити певне місце, яке потрібно змінити. Це є наслідком поганої структурованості ПЗ або програмування методом копіювання-вставлення. Якщо набір методів необхідно змінювати кожного разу при внесенні певних модифікацій в код, то застосовується «Виділення класу» (Extract Class) (Наприклад, три методи змінюються кожного разу коли підключається нова база даних, а чотири — при додаванні фінансового інструменту). Стрільба дробом При виконанні будь-яких модифікацій доводиться вносити безліч дрібних змін у велике число класів. «Стрільба дробом» схожа на «Розбіжну модифікацію», але є її протилежністю. «Розбіжна модифікація» має сенс, коли є один клас, в якому проводиться багато різних змін, а «Стрільба дробом» — це одна зміна, що зачіпає багато класів. Винести всі зміни в один клас дозволять «Переміщення методу» (Move Method) і «Переміщення поля» (Move Field); Якщо немає відповідного класу, то слід створити новий клас; Якщо це необхідно, слід скористатися «Вбудовуванням класу» (Inline Class). Заздрісні функції Метод звертається до даних іншого об'єкта частіше, ніж до власних даних. «Переміщення методу» (Move Method) застосовується, якщо метод явно слід перевести в інше місце; «Виділення методу» (Extract Method) застосовується до частини методу, якщо тільки ця частина звертається до даних іншого об'єкта; Метод використовує функції декількох класів: визначається, в якому класі знаходиться найбільше даних, і метод поміщається в клас разом з цими даними, або за допомогою «Виділення методу» (Extract Method) метод розбивається на кілька частин і вони поміщаються в різні місця. Фундаментальне практичне правило говорить: «Те, що змінюється одночасно, треба зберігати в одному місці». Дані та функції, що використовують ці дані, які зазвичай змінюються разом, але бувають винятки. Групи даних Групи даних, що зустрічаються спільно, потрібно перетворювати в самостійний клас. «Виділення методу» (Extract Method) використовується для полів; «Введення граничного об'єкту» (Introduce Parameter Object) або «Збереження всього об'єкта» (Preserve Whole Object) для параметрів методів. Хороша перевірка: видалити одне із значень даних і перевірити, чи збереже сенс решта. Якщо ні, то це вірна ознака того, що дані напрошуються на об'єднання їх в об'єкт. Одержимість елементарними типами Проблема пов'язана з використанням елементарних типів замість маленьких об'єктів для невеликих завдань, таких як валюта, діапазони, спеціальні рядки для телефонних номерів тощо «Заміна значення даних об'єктом» (Replace Data Value with Object); «Заміна масиву об'єктом» (Replace Array with Object); Якщо це код типу, то використовуйте «Заміну коду типу класом» (Replace Type Code with Class), «Заміну коду типу підкласами» (Replace Type Code with Subclasses) або «Заміну коду типу станом / стратегією» (Replace Type Code with State / Strategy). Оператори типу switch Одним з очевидних ознак об'єктно-орієнтованого коду служить порівняно рідкісне використання операторів типу switch (або case). Часто один і той же блок switch виявляється розкиданим по різних місцях програми. При додаванні в перемикач нового варіанту доводиться шукати всі ці блоки switch і модифікувати їх. Як правило, помітивши блок switch, слід подумати про поліморфізм. Якщо switch перемикається по коду типу, то слід використовувати «Заміну коду типу підкласами» (Replace Type Code with Subclasses) або «Заміну коду типу станом / стратегією» (Replace Type Code with State / Strategy); Може знадобитися «Виділення методу» (Extract Method) і «Переміщення методу» (Move Method) щоб ізолювати switch і помістити його в потрібний клас; Після налаштування структури спадкування слід використовувати «Заміну умовного оператора поліморфізмом» (Replace Conditional with Polymorphism). Паралельні ієрархії успадкування У коді з таким запашком щоразу при породженні підкласу, одного з класів, доводиться створювати підклас іншого класу. Загальна стратегія усунення дублювання полягає в тому, щоб змусити екземпляри однієї ієрархії посилатися на екземпляри іншого ієрархії, а потім прибрати ієрархію в класі за допомогою «Переміщення методу» (Move Method) і «Переміщення поля» (Move Field). Лінивий клас Клас, витрати на існування якого не окупаються виконуваними ним функціями, повинен бути ліквідований. При наявності підкласів з недостатніми функціями спробуйте «Згортання ієрархії» (Collapse Hierarchy); Майже даремні компоненти повинні підлягати «Вбудовуванню класу» (Inline Class). Теоретична спільність Цей випадок виникає, коли на певному етапі існування програми забезпечується набір механізмів, який, можливо, буде потрібен для деякої майбутньої функціональності. У підсумку програму стає важче розуміти і супроводжувати. Для незадіяних абстрактних класів використовуйте «Згортання ієрархії» (Collapse Hierarhy); Непотрібна делегація може бути вилучена за допомогою «Вбудовування класу» (Inline Class); Методи з невикористовуваними параметрами повинні підлягати «Видаленню параметрів» (Remove Parameter). Тимчасове поле Тимчасові поля — це поля, які потрібні об'єкту лише за певних обставин. Такий стан речей важкий для розуміння, так як очікується, що об'єкту потрібні всі його поля. Тимчасові поля і весь код, який працює з ними, слід помістити в окремий клас за допомогою «Виділення класу» (Extract Class); Видалити умовно код, що використовується, можна за допомогою «Введення об'єкта Null» (Introduce Null Object) для створення альтернативного компонента. Ланцюжок викликів Ланцюжок викликів з'являється тоді, коли клієнт запитує у одного об'єкта інший об'єкт, інший об'єкт запитує ще один об'єкт і т. д. Такі послідовності викликів означають, що клієнт пов'язаний з навігацією за структурою класів. Будь-які зміни проміжних зв'язків означають необхідність модифікації клієнта. Для видалення ланцюжка викликів застосовується прийом «Приховування делегування» (Hide Delegate). Посередник Надмірне використання делегування може призвести до появи класів, у яких більшість методів складаються тільки з виклику методу іншого класу. Якщо велику частину методів клас делегує іншого класу, потрібно скористатися «Видаленням посередника» (Remove Middle Man). Недоречна близькість «Недоречна близькість» виникає тоді, коли класи частіше, ніж варто було б, занурені в закриті частини один одного. Позбутися «недоречної близькості» можна за допомогою «Переміщення методу» (Move Method) й «Переміщення поля» (Move Field); За можливістю слід вдатися до «Заміни двобічного зв'язку односпрямованим» (Change Bidirectional Association to Unidirectional), «Виділення класу» (Extract Class) або скористатися «Приховуванням делегування» (Hide Delegate). Альтернативні класи з різними інтерфейсами Два класи, в яких частина функціональності загальна, але методи, що реалізують її, мають різні параметри. Застосовуйте «Перейменування методу» (Rename Method) до всіх методів, які виконують однакові дії, але з різними сигнатурами. Неповнота бібліотечного класу Бібліотеки через деякий час перестають задовольняти вимогам користувачів. Природне рішення — змінити дещо в бібліотеках, але бібліотечні класи не змінювати. Слід використовувати методи рефакторінга, спеціально призначені для цієї мети. Якщо треба додати пару методів, використовується «Запровадження зовнішнього методу» (Introduce Foreign Method); Якщо треба серйозно поміняти поведінку класу, використовується «Введення локального розширення» (Introduce Local Extension). Класи даних Класи даних — це класи, які містять тільки поля і методи для доступу до них, це просто контейнери для даних, що використовуються іншими класами. Слід застосувати «Інкапсуляцію поля» (Encapsulate Field) й «Інкапсуляцію колекції» (Encapsulate Collection). Відмова від наслідування Якщо спадкоємець використовує лише малу частину успадкованих методів і властивостей батька — це є ознакою неправильної ієрархії. Необхідно створити новий клас на одному рівні з нащадком, і за допомогою «Спуска метода» (Push Down Method) і «Спуска поля» (Push Down Field) виштовхнути в нього всі недіючі методи. Завдяки цьому в батьківському класі буде міститися тільки те, що використовується спільно. Коментарі Часто коментарі грають роль «дезодоранту» коду, який з'являється в ньому лише тому, що код поганий. Відчувши потребу написати коментар, спробуйте змінити структуру коду так, щоб будь-які коментарі стали зайвими. Якщо для пояснення дій блоку все ж потрібен коментар, спробуйте застосувати «Виділення методу» (Extract Method); Якщо метод вже виділений, але як і раніше потрібен коментар для пояснення його дії, скористайтеся «Перейменування методу» (Rename Method); Якщо потрібно викласти деякі правила, що стосуються необхідного стану системи, застосуйте «Введення затвердження» (Introduce Assertion). Див. також Антипатерн Статичний аналіз коду Примітки Література Посилання Категорія:Програмування Категорія:Об'єктно-орієнтоване програмування"}
{"category": "Програмування", "title": "Заперечення (значення)", "abstract": "Дія зі значенням заперечити.\nЗаява про незгоду з ким або чим-небудь, доказ проти чогось. Спростування чого-небудь.Заперечення проти позову — аргументовані докази, що спростовують пред'явлений позов.\nНевизнання існування, значення, доцільності чого-небудь.\nЗаперечення (психоаналіз) — використовується для психологічного захисного механізму, коли людина стикається з тим, що занадто незручно приймати і замість того відкидає його, наполягаючи на тому, що це не відповідає дійсності, при цьому незважаючи на те, що можуть бути незаперечні докази іншого.\nЗаперечення (філософія) — знищення, подолання, заміна старого новим, попереднього наступним у процесі поступального розвитку. Те, що своєю появою, самим фактом свого існування заперечує що-небудь, свідчить про його неспроможність.\nЗаперечення (граматика) — слово, яке заперечує зміст іншого слова або речення (в українській мові – частки не, ні).\nЗаперечення — унарна операція над судженням.\nЗаперечення, інверсія (англ. negation) — булева операція, результат якої має булеве значення, протилежне булевому значенню операнда.", "content": "Дія зі значенням заперечити. Заява про незгоду з ким або чим-небудь, доказ проти чогось. Спростування чого-небудь.Заперечення проти позову — аргументовані докази, що спростовують пред'явлений позов. Невизнання існування, значення, доцільності чого-небудь. Заперечення (психоаналіз) — використовується для психологічного захисного механізму, коли людина стикається з тим, що занадто незручно приймати і замість того відкидає його, наполягаючи на тому, що це не відповідає дійсності, при цьому незважаючи на те, що можуть бути незаперечні докази іншого. Заперечення (філософія) — знищення, подолання, заміна старого новим, попереднього наступним у процесі поступального розвитку. Те, що своєю появою, самим фактом свого існування заперечує що-небудь, свідчить про його неспроможність. Заперечення (граматика) — слово, яке заперечує зміст іншого слова або речення (в українській мові – частки не, ні). Заперечення — унарна операція над судженням. Заперечення, інверсія () — булева операція, результат якої має булеве значення, протилежне булевому значенню операнда. ОперандРезультатІстинаХибаХибаІстина Джерела Посилання Заперечення інстинкт // Категорія:Логіка Категорія:Програмування"}
{"category": "Програмування", "title": "Захист від збоїв живлення", "abstract": "Захист від збоїв живлення в програмуванні - призупинення  роботи мікроконтролера при зникненні напруги живлення (англ. Black-Out) або при напрузі живлення нижче допустимого рівня (англ. Brown-Out).\nДля того щоб CPU мікроконтролера міг успішно декодувати і виконувати інструкції програми, напруга живлення повинна завжди бути більше мінімально допустимого рівня, що залежить від робочої частоти. Коли напруга живлення опускається нижче цього рівня, процесор може почати виконувати деякі інструкції неправильно. В результаті можуть відбуватися не заплановані процеси у внутрішній пам'яті і на лініях управління. Це може привести до пошкодження інформації в регістрах процесора, I/O регістрах і в пам'яті даних.\nДля того щоб уникнути цього, необхідно не допустити виконання коду CPU, при провалах напруги живлення. Для цього найкраще використовувати зовнішній детектор зниженої напруги живлення. При зменшенні напруги нижче фіксованого порога, детектор формує низький (активний) рівень на виведення RESET. Це негайно зупиняє CPU, не дозволяючи йому виконувати програму. Поки напруга живлення нижче порогового, мікроконтролер зупинений, і система перебувати у відомому стані. Коли напруга живлення знову піднімається до встановленого значення, вивід RESET звільняється і мікроконтролер починає виконувати програму з адреси вектора перезапуску (0x0000).", "content": "Захист від збоїв живлення в програмуванні - призупинення роботи мікроконтролера при зникненні напруги живлення () або при напрузі живлення нижче допустимого рівня (). Для того щоб CPU мікроконтролера міг успішно декодувати і виконувати інструкції програми, напруга живлення повинна завжди бути більше мінімально допустимого рівня, що залежить від робочої частоти. Коли напруга живлення опускається нижче цього рівня, процесор може почати виконувати деякі інструкції неправильно. В результаті можуть відбуватися не заплановані процеси у внутрішній пам'яті і на лініях управління. Це може привести до пошкодження інформації в регістрах процесора, I/O регістрах і в пам'яті даних. Для того щоб уникнути цього, необхідно не допустити виконання коду CPU, при провалах напруги живлення. Для цього найкраще використовувати зовнішній детектор зниженої напруги живлення. При зменшенні напруги нижче фіксованого порога, детектор формує низький (активний) рівень на виведення RESET. Це негайно зупиняє CPU, не дозволяючи йому виконувати програму. Поки напруга живлення нижче порогового, мікроконтролер зупинений, і система перебувати у відомому стані. Коли напруга живлення знову піднімається до встановленого значення, вивід RESET звільняється і мікроконтролер починає виконувати програму з адреси вектора перезапуску (0x0000). Примітки Див. також Посилання ST AN5833:software techniques for improving EMC performance Категорія:Програмування"}
{"category": "Програмування", "title": "Збірне програмування", "abstract": "Збі́рне програмува́ння - варіант модульного програмування для розподілених систем, який використовує в процесі збирання програми не тільки готові модулі, а і інші готові елементи (об’єкти, компоненти, каркаси тощо), реалізовані можливо у різних операційних середовищах. Для забезпечення їх правильної взаємодії використовуються спеціальні інтерфейсні мови такі як IDL (Interface Definition Language), CLR (Common Language Runtime) тощо. Підтримується системами CORBA, COM.", "content": "Збі́рне програмува́ння - варіант модульного програмування для розподілених систем, який використовує в процесі збирання програми не тільки готові модулі, а і інші готові елементи (об’єкти, компоненти, каркаси тощо), реалізовані можливо у різних операційних середовищах. Для забезпечення їх правильної взаємодії використовуються спеціальні інтерфейсні мови такі як IDL (Interface Definition Language), CLR (Common Language Runtime) тощо. Підтримується системами CORBA, COM. Див. також Парадигма програмування Модульне програмування Програмування Категорія:Програмування"}
{"category": "Програмування", "title": "Зв'язаний список", "abstract": "Зв'язаний список у програмуванні — одна з найважливіших структур даних, у якій елементи лінійно впорядковані, але порядок визначається не номерами елементів, а вказівниками, які входять до складу елементів списку та вказують на наступний за цим елемент (в однозв'язаних або однобічно зв'язаних списках) або на наступний та попередній елементи (у двозв'язаних або двобічно зв'язаних списках). Список має «голову» — перший елемент та «хвіст» — останній елемент.\nЗв'язані списки мають низку переваг порівняно з масивами. Зокрема, у них набагато ефективніше (за час О(1), тобто незалежно від кількості елементів) виконуються процедури додавання та вилучення елементів. Натомість, масиви набагато кращі в операціях, які потребують безпосереднього доступу до кожного елемента, що в разі зі зв'язаними списками неможливо та потребує послідовного перебору всіх елементів, які передують цьому.", "content": "Зв'язаний список у програмуванні — одна з найважливіших структур даних, у якій елементи лінійно впорядковані, але порядок визначається не номерами елементів, а вказівниками, які входять до складу елементів списку та вказують на наступний за цим елемент (в однозв'язаних або однобічно зв'язаних списках) або на наступний та попередній елементи (у двозв'язаних або двобічно зв'язаних списках). Список має «голову» — перший елемент та «хвіст» — останній елемент. Зв'язані списки мають низку переваг порівняно з масивами. Зокрема, у них набагато ефективніше (за час О(1), тобто незалежно від кількості елементів) виконуються процедури додавання та вилучення елементів. Натомість, масиви набагато кращі в операціях, які потребують безпосереднього доступу до кожного елемента, що в разі зі зв'язаними списками неможливо та потребує послідовного перебору всіх елементів, які передують цьому. Різновиди зв'язаних списків Однобічно зв'язані списки Файл:Singly-linked-list.svgОднобічно зв'язаний список з трьох елементів В однобічно зв'язаному списку, який є найпростішим різновидом зв'язаних списків, кожний елемент складається з двох полів: data або даних, та вказівника next на наступний елемент. Якщо вказівник не вказує на інший елемент (інакше: next = NULL), то вважається, що цей елемент — останній у списку. Двобічно зв'язаний список Файл:Doubly-linked-list.svgДвобічно зв'язаний список У двобічно зв'язаному списку елемент складається з трьох полів — вказівника на попередній елемент prev, поля даних data та вказівника next на наступний елемент. Якщо prev=NULL, то в елемента немає попередника (тобто він є «головою» списку), якщо next=NULL, то в нього немає наступника («хвіст» списка). Кільцевий список Файл:Circularly-linked-list.svgКільцевий однобічно зв'язаний список У кільцевому списку перший та останній елемент зв'язані. Тобто поле prev голови списка вказує на хвіст списка, а поле next хвоста списка вказує на голову списка. Застосування списків Списки інтенсивно застосовуються в програмуванні як самостійні структури. Також на їхній основі можуть будуватися складніші структури даних на кшталт дерева. На базі списків також можуть бути реалізовані стеки та черги. Переваги та недоліки Загалом, якщо необхідно оперувати з динамічними множинами, де присутні інтенсивні операції з додавання або видалення елементів, існують досить переконливі аргументи для використання саме зв'язаних списків. Зв'язані списки та масиви Списки мають деякі переваги над масивами. Вони досить ефективні щодо операцій додавання або видалення елементу на початку, або в кінці списка, виконуючи їх за постійний час O(1), тоді як масиви для цього потребують часу O(n) (окрім видалення останнього елемента), тобто час зростає з ростом кількості елементів масиву. Водночас додавання/видалення довільного елемента залежить від розміру списку і складність такого алгоритму O(n). У списках також не існує проблеми «розширення», яка рано чи пізно виникає в масивах фіксованого розміру, коли виникає необхідність помістити в нього додаткові елементи. Так само фіксований масив, з якого було видалено багато елементів (або вони просто не використовуються) є дуже неефективним з огляду використання пам'яті. Функціонування списків можливо в ситуації, коли пам'ять комп'ютера фрагментована, тоді як масиви переважно потребують неперервної області для зберігання. З іншого боку, масиви дозволяють безпосередній доступ до будь-якого елемента. Однобічно зв'язані списки, натомість, потребують проходження всіх попередніх елементів. Це призводить до складнощів застосування списків у задачах, де необхідно швидко знаходити елемент за його індексом, наприклад в алгоритмах сортування. Кешування списків у таких випадках майже не дає ефекту. Іншим очевидним недоліком списків є необхідність разом з корисною інформацією додаткового збереження інформації про вказівники, що позначається на ефективності використання пам'яті цими структурами. Двобічне та однобічне зв'язування Двобічне зв'язування потребує більше пам'яті на елемент та більших обчислювальних затрат на виконання елементарних операцій. Але такими списками легше маніпулювати, тому що вони дозволяють проходження по списку в обох напрямах, що є необхідною умовою функціонування деяких алгоритмів. Джерела Категорія:Структури даних Категорія:Програмування"}
{"category": "Програмування", "title": "Зворотна розробка", "abstract": "Зворо́тна розро́бка (англ. reverse engineering) — дослідження деякого пристрою чи програми з метою розуміння принципів роботи досліджуваного об'єкта. Найчастіше використовується з метою створення об'єкта, за функціональністю аналогічного досліджуваному але без точного копіювання його функцій.\nЗазвичай використовується у випадках, коли розробник оригінального пристрою чи програми не надає точних відомостей про алгоритми функціонування виробу, або будь-яким чином намагається завадити використанню технологій, що задіяні його функціоналом.\nУ наш час зворотна розробка найширше вживається для аналізу програмного забезпечення з закритими вихідним кодом. При цьому людина, що використовує даний метод дослідження, аналізує машинний код програми (зазвичай в дизасембльованому вигляді) та складає алгоритм функціонування ПЗ для подальшої реалізації в окремому продукті або відтворює його у відповідних специфікаціях.\nЗазвичай зворотна розробка є забороненою законом та/або ліцензійними угодами з кінцевим користувачем, але продукти, створені на основі аналізу алгоритмів є цілком законними, оскільки кінцевий продукт дуже рідко є схожим на оригінальний.", "content": "Зворо́тна розро́бка () — дослідження деякого пристрою чи програми з метою розуміння принципів роботи досліджуваного об'єкта. Найчастіше використовується з метою створення об'єкта, за функціональністю аналогічного досліджуваному але без точного копіювання його функцій. Зазвичай використовується у випадках, коли розробник оригінального пристрою чи програми не надає точних відомостей про алгоритми функціонування виробу, або будь-яким чином намагається завадити використанню технологій, що задіяні його функціоналом. У наш час зворотна розробка найширше вживається для аналізу програмного забезпечення з закритими вихідним кодом. При цьому людина, що використовує даний метод дослідження, аналізує машинний код програми (зазвичай в дизасембльованому вигляді) та складає алгоритм функціонування ПЗ для подальшої реалізації в окремому продукті або відтворює його у відповідних специфікаціях. Зазвичай зворотна розробка є забороненою законом та/або ліцензійними угодами з кінцевим користувачем, але продукти, створені на основі аналізу алгоритмів є цілком законними, оскільки кінцевий продукт дуже рідко є схожим на оригінальний. Використання Програмне забезпечення Дослідження програм часто використовують з метою подальшої їхньої модифікації, розширення функціоналу або створення засобів, що дозволяють обходити обмеження на їхнє використання (наприклад умовно-безкоштовні програми). Також такі методи можуть використовуватися для отримання специфікації протоколів обміну інформацією (наприклад мережевих протоколів) або способів її зберігання (формати файлів). Зворотна розробка програмного забезпечення зазвичай проводиться такими методами: Моніторинг активності. Таким способом найчастіше проводиться дослідження протоколів обміну інформацією. Наприклад для дослідження мережевих проколів може використовуватися перехоплення потоків даних в мережі за допомогою спеціалізованих програмних чи/та апаратних засобів. Цей метод може не дати повного уявлення про алгоритми функціонування ПЗ. Дизасемблювання. Машинний код програми читається та перекладається мовою асемблера для свого розуміння в чистому вигляді. Таким способом можна досліджувати будь-яке програмне забезпечення, але за допомогою використання певних технологій при розробці ПЗ дизасемблювання можна значно ускладнити. Метод вимагає високої кваліфікації людини, що проводить зворотну розробку та великих затрат часу. Декомпіляція. Полягає у перекладі машинного коду програми мовою високого рівня. Метод важко реалізувати з огляду на складність створення інструментів. Див. також Бенчмаркінг Категорія:Програмування Категорія:Початковий код"}
{"category": "Програмування", "title": "Зворотно-орієнтоване програмування", "abstract": "Зворотно-орієнтоване програмування (англ. return oriented programming, ROP) — метод експлуатації вразливостей в програмному забезпеченні, використовуючи який атакуючий може виконати необхідний йому код за наявності в системі захисних технологій, наприклад технології, що забороняє виконання коду з певних сторінок пам'яті. Метод полягає в тому, що атакуючий може отримати контроль над стеком викликів, знайти в коді послідовності інструкцій, які виконують потрібні дії і звані «гаджетами», виконати «гаджети» в потрібній послідовності. «Гаджет», як правило, закінчується інструкцією повернення і розташовується в оперативній пам'яті в існуючому коді (в коді програми або в коді використовуваної бібліотеки). Атакуючий домагається послідовного виконання гаджетів за допомогою інструкцій повернення, складає послідовність гаджетів так, щоб виконати потрібні операції. Атака реалізувати навіть на системах, що мають механізми для запобігання більш простих атак.", "content": "Зворотно-орієнтоване програмування (, ROP) — метод експлуатації вразливостей в програмному забезпеченні, використовуючи який атакуючий може виконати необхідний йому код за наявності в системі захисних технологій, наприклад технології, що забороняє виконання коду з певних сторінок пам'яті. Метод полягає в тому, що атакуючий може отримати контроль над стеком викликів, знайти в коді послідовності інструкцій, які виконують потрібні дії і звані «гаджетами», виконати «гаджети» в потрібній послідовностіErik Buchanan, Ryan Roemer, Hovav Shacham and Stefan Savage; When Good Instructions Go Bad: Generalizing Return-Oriented Programming to RISC , in Proceedings of CCS 2008, ACM Press, October 2008.. «Гаджет», як правило, закінчується інструкцією повернення і розташовується в оперативній пам'яті в існуючому коді (в коді програми або в коді використовуваної бібліотеки). Атакуючий домагається послідовного виконання гаджетів за допомогою інструкцій повернення, складає послідовність гаджетів так, щоб виконати потрібні операції. Атака реалізувати навіть на системах, що мають механізми для запобігання більш простих атак. Історія Атака на переповнення буфера Зворотно-орієнтоване програмування — це вдосконалена версія атаки на переповнення буфера. При цій атаці атакувальник використовує помилку в програмі, коли функція не перевіряє (або неправильно перевіряє) межі при запису в буфер даних, отриманих від користувача. Якщо користувач передає більше даних, ніж розмір буфера, то зайві дані потрапляють в область пам'яті, призначену для інших локальних змінних, а також можуть перезаписати адреси повернення. Якщо адреса повернення виявляється перезаписаною, то при поверненні з функції керування буде передано знову записаній адресі. У найпростішій версії атаки на переповнення буферу, атакувальник поміщає код(«корисне навантаження») у стек, а потім перезаписує адресу повернення адресою тільки що записаних ним інструкцій. До кінця 90-х років більшість операційних систем не надавало ніякого захисту від цих атак. У системах Windows не було захисту від атак переповнювання буфера до 2004 року. Врешті решт, операційні системи стали боротися з експлуатацією вразливостей переповнення буфера, позначаючи певні сторінки пам'яті як невиконувані (технологія, яка отримала назву «Запобігання виконання даних»). При включеному запобіганні виконання даних машина відмовиться виконувати код у сторінках пам'яті, позначені «тільки для даних», включаючи сторінки, що містять стек. Це не дозволяє помістити корисне навантаження в стек, а потім перейти на нього, перезаписавши адреси повернення. Пізніше для посилення захисту з'явилася апаратна підтримка запобігання виконання даних. Атака повернення в бібліотеку Запобігання виконання даних не дозволяє провести атаку методом, описаним вище. Атакуючий обмежений кодом, вже наявними в атакуючій програмі і подключених бібліотеках. Проте колективні бібліотеки, зокрема libc, часто містять функції для здійснення системних викликів та інші корисні для атакуючого функції, що дозволяє використовувати ці функції при атаці. При атаці повернення до бібліотеки також експлуатується переповнення буфера. Адреса повернення буде точкою входу потрібної бібліотечної функції. Також перезаписуються комірки над адресою повернення, щоб передати функції параметри або зв'язати в ланцюжок кілька викликів. Ця техніка була вперше представлена Олександром Песляком (відомим як Solar Designer) у 1997 році,Solar Designer, Return-into-lib(c) exploits , Bugtraq а потім була розширена, дозволяючи зробити необмежений ланцюжок викликів функцій.Nergal, Phrack 58 Article 4, return-into-lib(c) exploits Запозичення шматків коду З поширенням 64-розрядного обладнання і операційних систем стало складніше проводити атаку повернення в бібліотеку: у використовуваних в 64-розрядних системах угодах про виклик перші параметри передаються функції не в стеку, а в регістрах. Це ускладнює підготовку параметрів для виклику в процесі атаки. Крім того, розробники поділюваних бібліотек стали прибирати з бібліотек або обмежувати «небезпечні» функції, такі як обгортки системних викликів. Наступним витком розвитку атаки стало використання частин бібліотечних функцій замість функцій цілком.Sebastian Krahmer, x86-64 buffer overflow exploits and the borrowed code chunks exploitation technique , September 28, 2005 У цій техніці шукаються частини функцій, які передають дані з стека в регістри. Ретельний підбір цих частин дозволяє підготувати потрібні параметри в регістрах для виклику функції за новою угодою. Далі атака проводиться так само, як атака повернення до бібліотеки. Атака методом зворотно-орієнтованого програмування Зворотно-орієнтоване програмування розширює підхід запозичення шматків коду, надаючи атакувальнику повну за Тюрингом функціональність, включаючи цикли і розгалуження. Іншими словами, зворотно-орієнтоване програмування надає атакувальнику можливість виконати будь-яку операцію. Ховав Шахам опублікував опис методу у 2007 роціHovav Shacham. The geometry of innocent flesh on the bone: return-into-libc without function calls (on the x86). In Proceedings of the 14th ACM conference on Computer and communications security (CCS '07). ACM 2007 і продемонстрував його на програмі, що використовує стандартну бібліотеку мови Сі і містить вразливість переповнення буфера. Зворотно-орієнтоване програмування перевершує інші описані вище типи атак і з виразною потужністю, і по стійкості до захисних заходів. Жоден з вищеописаних методів протидії атакам, включаючи видалення небезпечних функцій з поділюваних бібліотек, не є ефективним проти зворотно-орієнтованого програмування. На відміну від атаки повернення в бібліотеку, в якій використовуються функції цілком, у зворотно-орієнтованому програмуванні використовуються невеликі послідовності інструкцій, що закінчуються інструкцією повернення, так звані «гаджети». Гаджетами є, наприклад, закінчення наявних функцій. Однак на деяких платформах, зокрема x86, гаджети можуть виникати «між рядків», тобто при декодуванні з середини наявної інструкції. Наприклад, наступна послідовність інструкцій: test edi, 7 ; f7 c7 07 00 00 00 setnz byte[ebp-61] ; 0f 95 45 c3 при початку декодування на один байт пізніше, дає mov dword[edi], 0f000000h ; c7 07 00 00 00 0f xchg ebp, eax ; 95 inc ebp ; 45 ret ; c3 Також гаджети можуть перебувати в даних, які з тих чи інших причин знаходяться в секції коду. Це пов'язано з тим, що набір інструкцій архітектури x86 досить щільний, тобто велика ймовірність того, що довільний потік байтів буде інтерпретований як потік дійсних інструкцій. З іншого боку, в архітектурі MIPS всі інструкції мають довжину 4 байти, а можна виконувати тільки інструкції, вирівняні за адресами, кратним 4-м байтам. Тому там не можна отримати нову послідовність «читанням між рядків». При атаці експлуатується вразливість переповнення буфера. Адреса повернення з поточної функції перезаписується адресою першого гаджета. На наступні позиції в стеку записуються адреси таких гаджетів і дані, використовувані гаджетами. Приклади Розширення У своєму первісному варіанті для платформи x86, гаджети являють собою ланцюжки послідовно розташованих інструкцій без переходів, які завершуються інструкцією близького повернення. В розширених варіантах атаки інструкції ланцюжки можуть не обов'язково бути послідовно розташовані, а пов'язані інструкціями прямого переходу. Також роль завершальної інструкції може виконувати інша інструкція повернення (x86 є ще інструкція далекого повернення, інструкції близького і далекого повернення з очищенням стека), інструкція непрямого переходу або навіть непрямого виклику. Це ускладнює боротьбу з даним методом атаки. Автоматична генерація Існують інструменти для автоматичного знаходження гаджетів і конструювання атаки. Прикладом такого інструменту може служити ROPgadget. Захист від зворотно-орієнтованого програмування Існує кілька методів захисту від зворотно-орієнтованого програмування.Richard Skowyra, Kelly Casteel, Hamed Okhravi and William Streilein; Systematic Analysis of Defenses Against Return-Oriented Programming , In Proceedings of RAID 2013, Lecture Notes in Computer Science (LNCS), Vol. 8145, pp. 82-102, 2013. Більшість покладаються на розташування коду програми і бібліотек за відносно безпідставного адресою, так що атакуючий не може точно передбачити розташування інструкцій, що можуть бути корисними в гаджетах, а значить не може побудувати ланцюжок гаджетів для атаки. Одна з реалізацій цього методу, ASLR, завантажує колективні бібліотеки за адресою, різною при кожному запуску програми. Однак, хоча ця технологія широко застосовується в сучасних операційних системах, вона є вразливою до атак витоку інформації та інших атак, що дозволяє визначити положення відомої бібліотечної функції. Якщо атакуючий може визначити розташування однієї функції, він може визначити розташування всіх інструкцій бібліотеки і провести атаку методом зворотно-орієнтованого програмування. Можна переставляти не лише бібліотеки цілком, а й окремі інструкції програм і бібліотек.Jason Hiser, Anh Nguyen-Tuong, Michele Co, Matthew Hall, JackW. Davidson, ILR: Where’d My Gadgets Go? Proceedings of the IEEE Symposium on Security and Privacy, May 2012, San Francisco, CA Однак це вимагає великої підтримки під час виконання, наприклад, динамічної трансляції, щоб повернути переставлені інструкції у правильний порядок для їх виконання. Цей метод ускладнює знаходження і використання гаджетів, однак має великі накладні витрати. Підхід, що застосовується в kBouncerVasilis Pappas. kBouncer: Efficient and Transparent ROP Mitigation . April 2012., полягає в перевірці того, що інструкція повернення передає управління на інструкцію, безпосередньо наступну за інструкцією виклику. Це сильно скорочує кількість можливих гаджетів, але також викликає значне зниження продуктивності. Крім того в розширеному варіанті зворотно-орієнтованого програмування гаджети можна пов'язувати не тільки інструкцією повернення, але і інструкцією непрямого переходу або виклику. Проти такої розширеної атаки kBouncer буде неефективний. Примітки Категорія:Програмування Категорія:Статті з прикладами коду мовою ассемблера"}
{"category": "Програмування", "title": "Ідентифікатор", "abstract": "Ідентифіка́тор (англ. identifier) — назва об'єкта програми (змінної, масиву, структури, функції тощо), що дозволяє звернутись до нього; ознака, яка цілком визначає сутність, в наперед визначеному просторі. Ідентифікатор завжди:\n\nєдиний — розглядається як неподільна (атомарна) лексема;\nтотожній — вказує тільки на одну сутність;\nдійсний лише в одному адресному просторі.\nПриродно, проблематика характерно відбилась в задачах мов програмування у визначення меж дії локальної зміної.", "content": "Ідентифіка́тор () — назва об'єкта програми (змінної, масиву, структури, функції тощо), що дозволяє звернутись до нього; ознака, яка цілком визначає сутність, в наперед визначеному просторі. Ідентифікатор завжди: єдиний — розглядається як неподільна (атомарна) лексема; тотожній — вказує тільки на одну сутність; дійсний лише в одному адресному просторі. Природно, проблематика характерно відбилась в задачах мов програмування у визначення меж дії локальної зміної. Див. також Визначник Система відліку Номер Джерела Категорія:Програмування Категорія:Ідентифікатори Категорія:Поняття мов програмування"}
{"category": "Програмування", "title": "Ініціалізація", "abstract": "Ініціалізація (initialization) — ряд дій, що передують виконанню програми, зокрема, встановлення програмних змінних в нуль, або надання їм інших початкових значень.\nІніціалізація об'єкта відбувається у методі, що називається конструктором.\nФорматування диска та запис на ньому керівної програми. Приклади: Ініціалізація пакета дисків. Ініціалізація ядра, ініціалізація запуску.\nТакож ініціалізація працює після оновлення программ.", "content": "Ініціалізація (initialization) — ряд дій, що передують виконанню програми, зокрема, встановлення програмних змінних в нуль, або надання їм інших початкових значень. Ініціалізація об'єкта відбувається у методі, що називається конструктором. Форматування диска та запис на ньому керівної програми. Приклади: Ініціалізація пакета дисків. Ініціалізація ядра, ініціалізація запуску. Також ініціалізація працює після оновлення программ. Див. також Автовівіфікація Джерела Категорія:Програмування"}
{"category": "Програмування", "title": "Інкапсуляція (програмування)", "abstract": "Інкапсуляція — один з трьох основних механізмів об'єктно-орієнтованого програмування. Йдеться про те, що об’єкт вміщує не тільки дані, але і правила їх обробки, оформлені в вигляді виконуваних фрагментів (методів). А також про те, що доступ до стану об'єкта напряму заборонено, і ззовні з ним можна взаємодіяти виключно через заданий інтерфейс (відкриті поля та методи), що дозволяє знизити зв'язність. Таким чином контролюються звернення до полів класів та їхня правильна ініціалізація, усуваються можливі помилки пов'язані з неправильним викликом методу. Оскільки користувачі працюють лише через відкриті елементи класів, то розробники класу можуть як завгодно змінювати всі закриті елементи і, навіть, перейменовувати та видаляти їх, не турбуючись, що десь хтось їх використовує у своїх програмах.", "content": "Інкапсуляція — один з трьох основних механізмів об'єктно-орієнтованого програмування. Йдеться про те, що об’єкт вміщує не тільки дані, але і правила їх обробки, оформлені в вигляді виконуваних фрагментів (методів). А також про те, що доступ до стану об'єкта напряму заборонено, і ззовні з ним можна взаємодіяти виключно через заданий інтерфейс (відкриті поля та методи), що дозволяє знизити зв'язність. Таким чином контролюються звернення до полів класів та їхня правильна ініціалізація, усуваються можливі помилки пов'язані з неправильним викликом методу. Оскільки користувачі працюють лише через відкриті елементи класів, то розробники класу можуть як завгодно змінювати всі закриті елементи і, навіть, перейменовувати та видаляти їх, не турбуючись, що десь хтось їх використовує у своїх програмах. Приклади На Java: class Point { //можливий доступ лише з методів даного класу private int x, y; //можливий доступ лише з методів даного класу private boolean visibility; void createPoint(int a, int b) { x = a; y = b; visibility = true; } void setVisibility(boolean visibility) { this.visibility = visibility; } int getX() { return x; } int getY() { return y; } } На С++: class Point { //можливий доступ лише з методів даного класу int x, y; bool visibility; public: void createPoint(int a, int b) { x = a; y = b; visibility = true; } void setVisibility(bool visibility) { this->visibility = visibility; } int getX() { return x; } int getY() { return y; } }; У цьому прикладі клас Point інкапсулює (приховує) координати точки. Доступ до них можливий лише за певними правилами, які реалізовуються через відповідні методи. Такими правилами можуть бути, наприклад, операція створення точки (установка значень координат), а також операції «увімкнення» і «вимкнення» видимості точки, отримання координат. Як видно з прикладу, для створення точки необхідно вказати координати точки і «увімкнути» дану точку (зробити її видимою). Якщо б клас був повністю відкритий, то можна б було вручну встановити відповідні поля класу х, y та встановити visible в true. Проте програміст може легко забути встановити якусь з координат або забути встановити видимість. Метод createPoint забезпечує виконання усіх необхідних дій, а закриття доступу до координат змушує діяти лише через використання даного методу. Інкапсульованими також можуть бути і методи класу. Інші особливості В ООП рекомендується з самого початку створювати закриті поля і лише в разі крайньої необхідності надавати ширший доступ до них. Для роботи із закритими полями класів краще використовувати відповідний метод доступу (getter) та метод-мутатор (setter). При збільшенні розмірів програм і комп'ютерних систем із використанням принципів ООП стає більш ясним їх огляд (у тому числі, тестування ПЗ і налагодження), написання документації щодо їх використання. Див. також Об'єктно-орієнтоване програмування Поліморфізм (програмування) Успадкування (програмування) Література Категорія:Програмування Категорія:Об'єктно-орієнтоване програмування Категорія:Статті з прикладами коду мовою Java Категорія:Статті з прикладами коду мовою C++"}
{"category": "Програмування", "title": "Інструкція перемикач", "abstract": "Інструкція перемикач (англ. Switch statement), також знана як інструкція вибору та оператор перемикач (switch, case, select або inspect) — це спеціального виду інструкція мови програмування, що забезпечує багатонаправлене (множинне) розгалуження в програмі. Назва інструкції в різних мовах може різнитися, переважно — це інструкції switch, case, select або inspect. Цей механізм вибору існує в більшості імперативних мовах програмування таких як Pascal, Ada, C/C++, C#, Java тощо. Інструкція перемикач дозволяє робити вибір однієї з множини альтернатив.", "content": "Інструкція перемикач (), також знана як інструкція вибору та оператор перемикач (switch, case, select або inspect) — це спеціального виду інструкція мови програмування, що забезпечує багатонаправлене (множинне) розгалуження в програмі. Назва інструкції в різних мовах може різнитися, переважно — це інструкції switch, case, select або inspect. Цей механізм вибору існує в більшості імперативних мовах програмування таких як Pascal, Ada, C/C++, C#, Java тощо. Інструкція перемикач дозволяє робити вибір однієї з множини альтернатив . Загальний принцип Вона працює наступним чином: Значення виразу послідовно порівнюється з константами із заданого списку. У разі виявлення збігу для однієї з умов порівняння виконується послідовність інструкцій, пов'язана з цією умовою. Хоча багатонаправлене тестування можна реалізувати з допомогою послідовності вкладених інструкцій if, для багатьох ситуацій інструкція switch виявляється ефективнішим рішенням. Приклади Далі наведені прості приклади написані на деяких мовах програмування, що використовують перемикач, які друкують рядок тексту, зміст якого залежить від значення введеного користувачем. C, C++, D, Java, PHP, ActionScript, JavaScript switch (n) { case 0: printf(\"Ви ввели нуль.\"); break; case 1: case 4: case 9: printf(\"n є повним квадратом.\"); break; case 2: printf(\"n парне число.\"); case 3: case 5: case 7: printf(\"n є простим числом.\"); break; case 6: case 8: printf(\"n парне число.\"); break; default: printf(\"Only single-digit numbers are allowed.\"); break; } C# switch (n) { case 0: Console.WriteLine(\"Ви ввели нуль.\"); break; case 1: case 4: case 9: Console.WriteLine(\"n є повним квадратом.\"); break; case 2: Console.WriteLine(\"n парне число.\"); goto case 3; case 3: case 5: case 7: Console.WriteLine(\"n є простим числом.\"); break; case 6: case 8: Console.WriteLine(\"n парне число.\"); break; default: Console.WriteLine(\"Only single-digit numbers are allowed.\"); break; } Fortran select case (n) case (:-1) write(*,*) \"ви ввели від'ємне число\" case (0) write(*,*) \"ви ввели нуль.\" case (1,4,9) write(*,*) \"n є повним квадратом.\" case (2) write(*,*) \"n парне число і дорівнює 2\" case (3,5,7) write(*,*) \"n є простим числом.\" case (6,8) write(*,*) \"n парне число.\" case (10:) write(*,*) \"тільки числа з [0:9]!\" case default write(*,*) \"яким чином ви сюди потрапили?\" end select Pascal case age of 0,1: writeln('baby'); 2,3,4: writeln('toddler'); 5..12: writeln('kid'); 13..19: writeln('teenager'); 20..25: writeln('young'); else writeln('old ;)'); end; Perl use feature 'switch'; given ($foo) { when (undef) { say '$foo is undefined'; } when (\"foo\") { say '$foo is the string \"foo\"'; } when ([1,3,5,7,9]) { say '$foo is an odd digit'; continue; # Fall through } when ($_ < 100) { say '$foo is numerically less than 100'; } when (\\&complicated_check) { say 'a complicated check for $foo is true'; } default { die \"I don't know what to do with $foo\"; } } Джерела Категорія:Програмування Категорія:Потік керування Категорія:Статті з прикладами коду мовою C Категорія:Статті з прикладами коду мовою Pascal Категорія:Статті з прикладами коду мовою Perl Категорія:Статті з прикладами коду мовою C Sharp Категорія:Статті з прикладами коду мовою Fortran"}
{"category": "Програмування", "title": "Інструкція повернення", "abstract": "Інструкція повернення, інструкція return (англ. return statement, також іноді помилково перекладають як оператор повернення та оператор return) — інструкція мов програмування, призначена для повернення з підпрограми (функції, методу, процедури) в точку після коду програми, де відбувся виклик цієї підпрограми. Водночас у низці мов інструкція дозволяє повертати з підпрограми певне значення (return value).\nУ низці мов може бути використано ще й для припинення виконання певних складених інструкцій, наприклад, для передчасного виходу з циклу. Щоправда, для цих цілей переважно застосовуються інструкції break та continue.", "content": "Інструкція повернення, інструкція return (, також іноді помилково перекладають як оператор повернення та оператор return) — інструкція мов програмування, призначена для повернення з підпрограми (функції, методу, процедури) в точку після коду програми, де відбувся виклик цієї підпрограми. Водночас у низці мов інструкція дозволяє повертати з підпрограми певне значення (return value). У низці мов може бути використано ще й для припинення виконання певних складених інструкцій, наприклад, для передчасного виходу з циклу. Щоправда, для цих цілей переважно застосовуються інструкції break та continue. Приклад Наведений приклад на мові програмування Java демонструє повернення результату сумування з методу sum(). public class ProgramSum { public static void main(String[] args) { int a = 2, b = 3, k = 4; int sum = sum(a, b, k); System.out.println(\"Сума трьох чисел дорівнює \" + sum); } public static int sum(int a, int b, int c) { return a + b + c; } } Посилання Інструкція повернення в мові С Категорія:Програмування Категорія:Потік керування Категорія:Статті з прикладами коду мовою Java"}
{"category": "Програмування", "title": "Інтернаціоналізація та локалізація", "abstract": "Інтернаціоналізація та локалізація (англ. internationalization and localization) відома також під абревіатурами i18n та L10n — процес мовної адаптації продукту, як-от програмне забезпечення, відеоігри, вебсайти, кінофільми тощо, до мови конкретної країни чи регіону.\nМіж інтернаціоналізацією і локалізацією є суттєва відмінність. Інтернаціоналізація — це адаптація продукту для потенційного використання практично в будь-якому місці, тоді як локалізація — це додавання спеціальних функцій для використання в певному регіоні. Інтернаціоналізація проводиться на початкових етапах розробки, а локалізація — для кожної цільової мови.\nВ англійській мові для слова «internationalization» існує скорочення «i18n». При цьому число 18 означає кількість пропущених між «i» та «n» букв. Для «Localization» застосовують скорочення «L10n» (L7d — Localized). Велика літера «L» використовується, щоб не плутати з «i» в «i18n», число 10 — кількість букв між «L» і «N».", "content": "Інтернаціоналізація та локалізація () відома також під абревіатурами i18n та L10n — процес мовної адаптації продукту, як-от програмне забезпечення, відеоігри, вебсайти, кінофільми тощо, до мови конкретної країни чи регіону. Між інтернаціоналізацією і локалізацією є суттєва відмінність. Інтернаціоналізація — це адаптація продукту для потенційного використання практично в будь-якому місці, тоді як локалізація — це додавання спеціальних функцій для використання в певному регіоні. Інтернаціоналізація проводиться на початкових етапах розробки, а локалізація — для кожної цільової мови. В англійській мові для слова «internationalization» існує скорочення «i18n». При цьому число 18 означає кількість пропущених між «i» та «n» букв. Для «Localization» застосовують скорочення «L10n» (L7d — Localized). Велика літера «L» використовується, щоб не плутати з «i» в «i18n», число 10 — кількість букв між «L» і «N». Параметри Важливими для інтернаціоналізації та локалізації об'єктами та параметрами є: Мова Текст Алфавіти та шрифти; напрям письма — зліва направо, справа наліво; системи нумерації. У більшості сучасних систем проблема безлічі кодувань вирішується використанням Юнікоду. Графічне представлення тексту (друкарські матеріали, зображення містять текст) Аудіотекст Субтитри у відеопотоках Формати дати і часу, включаючи різні календарі Часовий пояс Валюта Зображення та кольори Назви та заголовки Телефонні номери, регіональні та міжнародні поштові адреси та індекси Формати номерів, що призначаються федеральними відомствами (такі як ІНН) Одиниці міри та ваги Формати паперу Засоби інтернаціоналізації Спрощення перекладу Текстові рядки зберігаються в окремих файлах — мовних ресурсах. Інтенсивно використовується Unicode. Оскільки рядки в процесі перекладу можуть збільшуватися й зменшуватися, в діалогових вікнах вживають таких заходів: вікна спеціально компонують «із запасом». Плюс: простота. Мінус: на мовах з короткими фразами вікно буде виглядати неохайно, на мовах з довгими фразами — текст може не поміститись; або в мовні ресурси вносять компонування діалогових вікон. Плюс: універсальне рішення, дозволяє точно підігнати компонування вікон за довжиною рядків. Мінус: ускладнюється локалізація; потрібна підтримка з боку віконної бібліотеки, бажано — і з боку мови (інтроспекція); формат мовних ресурсів обмежується можливостями віконної бібліотеки (наприклад, у Delphi — тільки в ресурсах EXE- або DLL-файлу); локалізаторам може знадобитися недешевий редактор форм; або діалогові вікна самі встановлюють свій розмір, залежно від довжин рядків (так, наприклад, працюють Qt, WPF, GTK+ та wxWidgets). Плюс: локалізація зводиться до перекладу рядків; рутинну роботу з підгонки вікон буде виконано автоматично. Мінус: потрібна підтримка з боку віконної бібліотеки; утруднене або неможливе щільне компонування вікна. Робота з двонапрямленим письмом Намагаються використати стандартні і перевірені віконні компоненти, уникаючи «самописних». Підтримка стандартів Роблять конфігурованими всі параметри, які можна було б змінювати в іншій країні. Для виведення на екран чисел, дат, часу тощо використовують стандартні, а не «самописні» функції. Виробляється єдиний для всіх версій формат зв'язку — наприклад, в OpenOffice.org дата і час незалежно від країни зберігається у форматі ISO 8601 у вигляді 2008-12-31T15:16:17. Регіональні налаштування Регіональні налаштування () — набір параметрів, включно з набором символів, мовою користувача, країною, часовим поясом, а також іншими налаштуваннями, які користувач очікує бачити в інтерфейсі. Зазвичай ідентифікатор регіональних налаштувань містить, принаймні, позначення мови і позначення регіону. Наприклад, ідентифікатор виду uk-ua вказує, що ПЗ працює в режимі української мови з національними налаштуваннями, характерними для території України; fr-ch — французька мова / Швейцарія; sv-fi — шведська мова / Фінляндія тощо. На одному комп'ютері в рамках однієї операційної системи можуть одночасно використовуватися застосунки з різними регіональними налаштуваннями. Відкрите програмне забезпечення та інтернаціоналізація Відкрите програмне забезпечення, як правило, має більше можливостей інтернаціоналізації, аніж пропрієтарне. Річ у тім, що будь-хто, хто бажає бачити програму своєю мовою, може внести необхідні зміни; будь-хто, виявивши помилку, може надіслати її виправлення. До того ж розробникам відкритого ПЗ не потрібно в гонитві за прибутком «консервувати» старий, «небезпечний» або такий, що не піддається локалізації, код. Наприклад, KDE перекладено більш ніж на 100 мов, MediaWiki — понад 300. Див. також Локалізація програмного продукту Псевдолокалізація gettext Примітки Посилання Категорія:Програмування Категорія:Локалізація Категорія:Технічна комунікація Категорія:Літературознавство"}
{"category": "Програмування", "title": "Інтерпретація", "abstract": "Інтерпрета́ція (лат. interpretatio) — роз'яснення, тлумачення наукових і літературних текстів, творів образотворчого мистецтва; також — відтворення (наприклад, у музиці).\n\nІнтерпретація (літературознавство)\nІнтерпретація (музика)", "content": "Інтерпрета́ція () — роз'яснення, тлумачення наукових і літературних текстів, творів образотворчого мистецтва; також — відтворення (наприклад, у музиці). Інтерпретація (літературознавство) Інтерпретація (музика) Як термін машинних мов програмування Інтерпретація (interpretation) — трансляція та виконання кожного виразу вихідної мови машинної програми перед трансляцією та виконанням наступного виразу. На відміну від компіляції, при інтерпретації процес транслювання відбувається послідовно рядок за рядком під час прогону у середовищі інтерпретатора. Інтерпретатор Компіляція Категорія:Методологія науки Категорія:Програмування Категорія:Концептуальні моделі Категорія:Герменевтика"}
{"category": "Програмування", "title": "Інфраструктура як код", "abstract": "Інфраструктура як код (англ. Infrastructure as Code (IaC)) — це спосіб постачання та керування обчислювальними та мережевими ресурсами методом їх опису у вигляді програмного коду, на відміну від налаштовування необхідного обладнання власноруч чи з допомогою інтерактивних інструментів. ІТ інфраструктура, керована таким чином, охоплює як фізичні сервери, так і віртуальні машини, а також пов'язані з ними ресурси. У підході використовуються як виконувані скрипти, так і декларативні визначення, шаблони, які можуть перебувати в системі контролю версій. Термін найчастіше використовується для позначення декларативного опису ІТ інфраструктури.\nIaC подається в першу чергу як рішення для платформ хмарних обчислень, які, в свою чергу іноді позиціюються як IaaS рішення. Iac підтримує IaaS, але їх не слід плутати.", "content": "Інфраструктура як код () — це спосіб постачання та керування обчислювальними та мережевими ресурсами методом їх опису у вигляді програмного коду, на відміну від налаштовування необхідного обладнання власноруч чи з допомогою інтерактивних інструментів. ІТ інфраструктура, керована таким чином, охоплює як фізичні сервери, так і віртуальні машини, а також пов'язані з ними ресурси. У підході використовуються як виконувані скрипти, так і декларативні визначення, шаблони, які можуть перебувати в системі контролю версій. Термін найчастіше використовується для позначення декларативного опису ІТ інфраструктури. IaC подається в першу чергу як рішення для платформ хмарних обчислень, які, в свою чергу іноді позиціюються як IaaS рішення. Iac підтримує IaaS, але їх не слід плутати. Основні рішення AWS CloudFormation Terraform Ansible Puppet Vagrant Azure Resource Manager Google Cloud Resource Manager Категорія:Інформаційні технології Категорія:Програмування Категорія:Програмне забезпечення для оркестрації"}
{"category": "Програмування", "title": "Камінь спотикання (програмування)", "abstract": "Камінь спотикання (англ. gotcha) в програмуванні, позначає в мові програмування чи системі валідну конструкцію що працює як задокументовано, але є контрінтуїтивною і часто призводить до помилок, тому що її просто застосувати, а результат неочікуваний.", "content": "Камінь спотикання () в програмуванні, позначає в мові програмування чи системі валідну конструкцію що працює як задокументовано, але є контрінтуїтивною і часто призводить до помилок, тому що її просто застосувати, а результат неочікуваний. Приклади Класичним каменем спотикання в C/C++ є конструкціяif (a = b) code;Вона синтаксично правильна: записує значення змінної b в a а тоді виконує code якщо a ненульове. Іноді це навіть очікується. Щоправда, найчастіше це одруківка: програміст мав на увазіif (a == b) code;що виконує code якщо a дорівнювало b. Див. також Використовність Зноски Література Посилання C Traps and Pitfalls by Andrew Koenig C++ Gotchas A programmer's guide to avoiding and correcting ninety-nine of the most common, destructive, and interesting C++ design and programming errors, by Stephen C. Dewhurst Категорія:Програмування Категорія:Статті з прикладами коду мовою C"}
{"category": "Програмування", "title": "Квайн (програмування)", "abstract": "Квайн — комп'ютерна програма, яка не отримує ніяких вхідних даних та видає на виході копію свого власного початкового коду. Цей термін названо на честь американського логіка та філософа Квайна, який займався дослідженням автореференції.", "content": "Квайн — комп'ютерна програма, яка не отримує ніяких вхідних даних та видає на виході копію свого власного початкового коду. Цей термін названо на честь американського логіка та філософа Квайна, який займався дослідженням автореференції. Приклади простих квайнів в різних мовах програмування BASIC 10 LIST Brainfuck (Код слід писати в одному рядку, але для прочитності зроблено розриви рядків.) <nowiki> ->++>+++>+>+>+++>>>>>>>>>>>>>>>>>>>>>>+>+>++>+++>++>>+++>+>>>>>>>>>>>>>>>>>>>>>> >>>>>>>>>>>+>+>>+++>>>>+++>>>+++>+>>>>>>>++>+++>+++>+>+++>+>>+++>>>+++>+>++>+++> >>+>+>+>+>++>+++>+>+>>+++>>>>>>>+>+>>>+>+>++>+++>+++>+>>+++>+++>+>+++>+>++>+++>+ +>>+>+>++>+++>+>+>>+++>>>+++>+>>>++>+++>+++>+>>+++>>>+++>+>+++>+>>+++>>+++>>+[[> >+[>]+>+[<]<-]>>[>]<+<+++[<]<<+]>+[>>]+++>+[+[<++++++++++++++++>-]<++++++++++.<] </nowiki> C #include<stdio.h> char*i=\"\\\\#include<stdio.h>\",n='\\n',q='\"',*p= \"%s%cchar*i=%c%c%s%c,n='%cn',q='%c',*p=%c%c%s%c,*m=%c%c%s%c%c;%s%c\",*m= \"int main(){return!printf(p,i+1,n,q,*i,i,q,*i,q,n,q,p,q,n,q,m,q,n,m,n);}\" ;int main(){return!printf(p,i+1,n,q,*i,i,q,*i,q,n,q,p,q,n,q,m,q,n,m,n);} Або коротший приклад main(){char*a=\"main(){char*a=%c%s%c;printf(a,34,a,34);}\";printf(a,34,a,34);} Цей приклад використовує препроцесор #define T(a) main(){printf(a,#a);} T(\"#define T(a) main(){printf(a,#a);}\\nT(%s)\\n\") C++ #include <iostream> int main(){const char c=',',dq='\"',q[]=\"'\",*s[]={\"#include <iostream>\", \"int main(){const char c=',',dq='\",\"',q[]=\",\",*s[]={\",\"};std::cout<<s[0]<<std::endl<<s[1]<<dq<<s[2] <<dq<<q<<dq<<s[3]<<dq<<s[0]<<dq<<c<<dq<<s[1]<<dq<<c<<dq<<s[2]<<dq<<c<<dq<<s[3]<<dq<<c<<dq<<s[4]<<dq <<s[4]<<std::endl;}\"};std::cout<<s[0]<<std::endl<<s[1]<<dq<<s[2]<<dq<<q<<dq<<s[3]<<dq<<s[0]<<dq<<c <<dq<<s[1]<<dq<<c<<dq<<s[2]<<dq<<c<<dq<<s[3]<<dq<<c<<dq<<s[4]<<dq<<s[4]<<std::endl;} C# using System; namespace quine { class Program { [STAThread] static void Main(string[] args) { string s = \"using System;{0}namespace quine{0}{2}{0}{1}class Program{0} {1}{2}{0}{1}{1}[STAThread]{0}{1}{1}static void Main(string[] args){0}{1}{1}{2}{0}{1}{1}{1} string s = {4}{6}{4};{0}{1}{1}{1}Console.Write(s, Environment.NewLine, {4}{5}t{4}, {4}{2} {4}, {4}{3}{4}, {4}{5}{4}{4}, {4}{5}{5}{4}, s);{0}{1}{1}{3}{0}{1}{3}{0}{3}\"; Console.Write(s, Environment.NewLine, \"\\t\", \"{\", \"}\", \"\\\"\", \"\\\\\", s); } } } Легший варіант class Q { static void Main() { string s = @\"class Q {0} static void Main() {0} string s = @{2}{3}{2}; System.Console.Write(s, '{0}', '{1}', '{2}', s); {1} {1}\"; System.Console.Write(s, '{', '}', '\"', s); } } HQ9+ Q Java class Q{public static void main(String[]a){char q=34;String t=\"class Q{public static void main(String[]a){char q=34;String t=;System.out.println(t.substring(0,62)+q+t+q+t.substring(62));}}\";System.out.println(t.substring (0,62)+q+t+q+t.substring(62));}} JavaScript unescape(q=\"unescape(q=%220%22).replace(0,q)\").replace(0,q) або function quine() { return quine.toString(); } LISP (funcall (lambda (x) (append x (list (list 'quote x)))) '(funcall (lambda (x) (append x (list (list 'quote x)))))) Або так: :X MATLAB a='a=%c%s%c;a=sprintf(a,39,a,39);disp(a);';a=sprintf(a,39,a,39);disp(a); Python Python 2: a='a=%s;print a%%`a`';print a%`a` Python 3: c='c=%r;print(c%%c)';print(c%c) VBScript a=\"a=\"\":b=left(a,3):c=mid(a,3):msgbox(b+b+c+c)\":b=left(a,3):c=mid(a,3):msgbox(b+b+c+c) Див. також Формула Таппера HQ9+ Категорія:Програмування Категорія:Статті з прикладами коду мовою C++ Категорія:Статті з прикладами коду мовою Visual Basic Категорія:Статті з прикладами коду мовою Lisp Категорія:Статті з прикладами коду мовою Python Категорія:Статті з прикладами коду мовою Java Категорія:Статті з прикладами коду мовою Matlab Категорія:Статті з прикладами коду мовою C Sharp Категорія:Статті з прикладами коду мовою BASIC Категорія:Статті з прикладами коду мовою JavaScript"}
{"category": "Програмування", "title": "Керувальна послідовність", "abstract": "Керувальні си́мволи (англ. Control characters) — елементи кодування символів, які не відображаються графічно, але використовуються для керування пристроями, організації пересилання даних й інших цілей.", "content": "Керувальні си́мволи () — елементи кодування символів, які не відображаються графічно, але використовуються для керування пристроями, організації пересилання даних й інших цілей. Керувальні символи ASCII Десятк. номерШістнадцятк. номер Англійська назва Українська назваКла-вішіEscape-послі-довністьПризначення000 NULLпорожній символ\\0Цей символ не виконує дій. Деякі термінали зображують його як пробіл, але це неправильно. Часто NULL використовують для позначення кінця ланцюжка символів (наприклад, в мові C).101 START OF HEADINGпочаток заголовка^AПерший символ заголовка.202 START OF TEXTпочаток тексту^B303 END OF TEXTкінець тексту^CПри введенні з терміналу зазвичай інтерпретується як сигнал переривання.404 END OF TRANSMISSIONкінець передачі^DПри введенні з терміналу зазвичай інтерпретується як кінець вводу даних. Якщо поточна програма брала дані з терміналу, то вона завершується, як тільки обробить усе, що було до символу ^D.505 ENQUIRYзапит^EВикористовувався в телетайпному зв'язку. У відповідь передбачалося одержати ідентифікаційний рядок віддаленого апарата.606ACKNOWLEDGEпідтвердження^F У телетайпному зв'язку — позитивна відповідь (ACK) на запит (ENQ)707BELLзвуковий сигнал^G\\aЯкщо цей символ послати на принтер або на термінал, то нічого не надрукується, але прозвучить сигнал808BACKSPACEповернення на крок^H\\bПереміщає позицію курсора на один символ назад та стирає попередній символ якщо він існував909CHARACTER TABULATIONгоризонтальна табуляція^I\\tПереміщає позицію курсора до наступної позиції горизонтальної табуляції100ALINE FEEDзміна рядка^J\\nПереміщає позицію курсора на один рядок униз. В юніксовських текстових файлах розділяє рядки110BLINE TABULATIONвертикальна табуляція^K\\vПереміщає позицію курсора до наступної позиції вертикальної табуляції. На терміналах цей символ звичайно еквівалентний зміні рядка120CFORM FEEDзміна сторінки^L\\fЯкщо терміналом є принтер, цей символ примусово завершує друк на поточній сторінці (іншими словами, після цього символа друк розпочинається на новій сторінці). Якщо це екран, він очищується.130DCARRIAGE RETURNповернення каретки^M\\rПереміщує позицію друку в крайнє ліве положення.В текстових файлах комп’ютерів Macintosh розділяє рядки.В CP/M, MS-DOS Microsoft Windows для розділення рядків у текстових файлах використовується сполучення символів \\r\\n140ESHIFT OUTрежим національних символів^N В KOI-7 включає національний режим. На деяких принтерах включає режим символів подвійної ширини.150FSHIFT INрежим звичайного ASCII^0 В KOI-7 включає латинський режим. На деяких принтерах включає режим вузьких символів1610DATA LINK ESCAPE???^P Означає, що певна кількість наступних за ним символів мають якесь інше значення, відмінне від того, котре визначено в ASCII (див. також 1B).Наприклад, послідовність байтів 01 10 01 04 може означати заголовок, що містить лише одну команду «1»; тобто 10 використовується для позначення, що другий символ 01 не є початком заголовка.1711DEVICE CONTROL ONE, XON1-й код керування пристроєм^Q Символ XON, що застосовується при програмному керуванні потоком передачі даних1812DEVICE CONTROL TWO2-й код керування пристроєм^R 1913DEVICE CONTROL THREE, XOFF3-й код керування пристроєм^S Символ XOFF, що застосовується при програмному керуванні потоком передачі даних2014DEVICE CONTROL FOUR4-й код керування пристроєм^T 2115NEGATIVE ACKNOWLEDGEнегативне підтвердження^U У телетайпному зв'язку — негативна відповідь (NACK) на запит (ENQ)2216SYNCHRONOUS IDLEпорожній символ для синхронного режиму передачі^V Деякі лінії зв'язку влаштовані так, що вимагають безперервної передачі даних. Якщо передавати нема чого, то передають цей символ2317END TRANSMISSION BLOCKкінець блоку даних^W 2418CANCELскасування^X Дані, які йдуть перед ним, некоректні. (Звичайно мова йде про один рядок)2519END OF MEDIUMкінець носія^Y 261ASUBSTITUTEсимвол заміни^Z Ставиться на місці символів, значення яких були загублені при передачі. В CP/M MS-DOS використався для позначення кінця текстових файлів і кінця введення із консолі даних(хоча логічніше було б використати символ ^C або ^D).Багато текстових редакторів для MS-DOS автоматично ставили наприкінці файлу ^Z271BESCAPE???^[ Означає, що наступні за ним символи мають якесь інше значення, відмінне від визначеного в ASCII. Зазвичай починає керувальні послідовності281CINFORMATION SEPARATOR FOUR (file separator)роздільник даних № 4 (роздільник файлів) ^\\ 291DINFORMATION SEPARATOR THREE (group separator)роздільник даних № 3 (роздільник груп)^] 301EINFORMATION SEPARATOR TWO (record separator)роздільник даних № 2 (роздільник записів)^^ Вочевидь, призначався для поділу записів в базах даних, але практично ніколи ніде не використовується для цього311FINFORMATION SEPARATOR ONE (unit separator)роздільник даних № 1 (роздільник полів)^_ Вочевидь, призначався для поділу полів у базах даних, але практично ніколи не використовується для цього1277FDELETEвидалення^? Призначений для забивання помилково пробитих символів на семидоріжкових перфострічках (оскільки позначається пробиттям дірочок у всіх доріжках). За змістом еквівалентний порожньому символу (\\0). На терміналах може генеруватися натисканням або кнопки Backspace, або кнопки Delete. Керувальні символи ISO 8859 НомерНазваПризначення80PADDING CHARACTERСимвол-заповнювач81HIGH OCTET PRESET???82BREAK PERMITTED HEREТут дозволено розрив рядка83NO BREAK HEREТут не дозволено розрив рядка84INDEX???85NEXT LINEПереводить на наступний рядок і одночасно повертає позицію каретки до початку рядка (еквівалентно \\r\\n)86START OF SELECTED AREAПочаток виділеної ділянки87END OF SELECTED AREAКінець виділеної ділянки88CHARACTER TABULATION SETВстановлення позицій горизонтальної табуляції89CHARACTER TABULATION WITH JUSTIFICATIONВстановлення позицій і вирівнювання горизонтальної табуляції8ALINE TABULATION SETУстановка позицій вертикальної табуляції8BPARTIAL LINE FORWARDЧасткове перенесення рядка вперед8CPARTIAL LINE BACKWARDЧасткове перенесення рядка назад8DREVERSE LINE FEEDЗворотне перенесення рядка8ESINGLE SHIFT TWOдруге значення для наступного символу8FSINGLE SHIFT THREEтретє значення для наступного символу90DEVICE CONTROL STRINGРядок керування пристроєм91PRIVATE USE ONEКористувацький символ № 192PRIVATE USE TWOКористувацький символ № 293SET TRANSMIT STATEУстановка режиму передачі94CANCEL CHARACTERСимвол скасування95MESSAGE WAITINGЄ повідомлення96START OF GUARDED AREAПочаток захищеної ділянки97END OF GUARDED AREAКінець захищеної ділянки98START OF STRINGПочаток рядка99SINGLE GRAPHIC CHARACTER INTRODUCERНаступний символ інтерпретується як спеціальний графічний9ASINGLE CHARACTER INTRODUCERНаступний символ інтерпретується як керувальний9BCONTROL SEQUENCE INTRODUCERПочаток керувальної послідовності. Звичайно цей символ є еквівалентним Escape+[9CSTRING TERMINATORЗакінчення рядка9DOPERATING SYSTEM COMMANDКоманда операційної системи9EPRIVACY MESSAGEСекретне повідомлення9FAPPLICATION PROGRAM COMMANDКоманда прикладної програми Керувальні символи Unicode НомерНазваПризначення034FCOMBINING GRAPHEME JOINERОб'єднати символи, що стоять ліворуч і праворуч (створити лігатуру)200BZERO-WIDTH SPACEПропуск нульової ширини. При вирівнюванні по ширині може розширюватися200CZERO WIDTH NON-JOINERЗабороняє утворення лігатур200DZERO WIDTH JOINERДозволяє утворення лігатур200ELEFT-TO-RIGHT MARKПисати зліва направо200FRIGHT-TO-LEFT MARKПисати справа наліво2028LINE SEPARATORРоздільник рядків. Розділяє рядки тексту, але не абзаци2029PARAGRAPH SEPARATORРоздільник абзаців. Розділяє абзаци тексту202ALEFT-TO-RIGHT EMBEDDINGПочаток тексту, написаного зліва направо, який знаходиться усередині тексту, написаного справа наліво202BRIGHT-TO-LEFT EMBEDDINGПочаток тексту, написаного справа наліво, який знаходиться усередині тексту, написаного зліва направо202CPOP DIRECTIONAL FORMATTINGКінець вставленого тексту з іншим напрямком202DLEFT-TO-RIGHT OVERRIDE 202ERIGHT-TO-LEFT OVERRIDE 2060WORD JOINERЗ'єднувач слівFE01 … FE0FVARIATION SELECTOR -1…-16Вибір варіанта накреслення № 1 … № 16FEFFZERO WIDTH NO-BREAK SPACE / BYTE ORDER MARKНерозривний пропуск нульової ширини / індикатор порядку байтів. Цей символ використовується для вказівки на те, що даний файл записаний в UTF-16 або UTF-32 з певним порядком байтів (оскільки символу FFFE немає, а в UTF-8 байти FE й FF не використаються). Використання цього символу як нерозривний пропуск нульової ширини не рекомендується; для цього є символ U+2060 (word joiner).FFFDREPLACEMENT CHARACTERСимвол заміни. Використовується, коли значення символу невідоме або не може бути виражене в стандарті Unicode (див. також символ 1A)E0100 … E01EFVARIATION SELECTOR-17 … −256Вибір варіанту шрифта № 17 … № 256 Див. також Керувальні символи ANSI Посилання console_codes(4) — екрановані та керувальні послідовності консолі Linux Категорія:Кодування символів Категорія:Програмування"}
{"category": "Програмування", "title": "Кількість рядків коду", "abstract": "Кількість рядків коду (англ. Source Lines of Code — SLOC) — метрика програмного забезпечення, що використовується, щоб виміряти розмір комп'ютерної програми, рахуючи число рядків в тексті вихідного коду програми. Дана метрика від початку розроблена для оцінки зусиль, докладених при розробці програмного забезпечення. Однак через те, що одна й та сама функціональність може бути розбита на декілька рядків або записана в один рядок, дана метрика стала неефективною з появою нових мов програмування, у яких в одному рядку можна записати більше однієї команди.\nРозрізняють фізичні і логічні рядки коду. Логічні рядки коду — кількість команд програми. Фізичні рядки — кількість всіх рядків програми.", "content": "Кількість рядків коду (англ. Source Lines of Code — SLOC) — метрика програмного забезпечення, що використовується, щоб виміряти розмір комп'ютерної програми, рахуючи число рядків в тексті вихідного коду програми. Дана метрика від початку розроблена для оцінки зусиль, докладених при розробці програмного забезпечення. Однак через те, що одна й та сама функціональність може бути розбита на декілька рядків або записана в один рядок, дана метрика стала неефективною з появою нових мов програмування, у яких в одному рядку можна записати більше однієї команди. Розрізняють фізичні і логічні рядки коду. Логічні рядки коду — кількість команд програми. Фізичні рядки — кількість всіх рядків програми. Приклади Операційні системи Microsoft's Windows NT мають до кількох мільйонів рядків коду: Рік Операційна система мільйонів рядків 1993 Windows NT 3.1 4–5За інформацією Vincent Maraia's The Build Master. 1994 Windows NT 3.5 7–8 1996 Windows NT 4.0 11–12 2000 Windows 2000 понад 29 2001 Windows XP 45 2003 Windows Server 2003 50 Кількість рядків коду операційної системи Debian: Рік Операційна система мільйонів рядків 2000 Debian 2.2 55–59 2002 Debian 3.0 104 2005 Debian 3.1 215 2007 Debian 4.0 283 2009 Debian 5.0 324 2012 Debian 7.0 419Debian 7.0 був випущений в травні 2013 року. Це приблизне значення, опубліковане 13 лютого 2012 року, з використанням кодової бази, яка мала стати Debian 7.0, з використанням того самого методу програмного забезпечення, що й для даних, опублікованих Девідом А. Вілером. 2009 OpenSolaris 9,7 FreeBSD 8,8 2005 Mac OS X 10.4 86 Кількість рядків коду операційної системи Linux: Рік Операційна система мільйонів рядків 1991 Linux kernel 0.01 0.010239 2001 Linux kernel 2.4.2 2,4 2003 Linux kernel 2.6.0 5,2 2009 Linux kernel 2.6.29 11,0 2009 Linux kernel 2.6.32 12,6 2010 Linux kernel 2.6.35 13,5 2012 Linux kernel 3.6 15,9 2015-06-30 Linux kernel pre-4.2 20,2 2017 Ядро Linux 4.11.7 18 373 471 Примітки Категорія:Програмування"}
{"category": "Програмування", "title": "Кодування (програмування)", "abstract": "Кодування — процес написання початкового коду обраною або обраними мовами програмування з метою реалізації певного алгоритму або алгоритмів. В більш точному сенсі — процес перетворення моделей проектування в моделі реалізації обраною мовою програмування.\nНе слід плутати програмування і безпосередньо кодування. Кодування є лише частиною програмування, поряд з аналізом, проектуванням, компіляцією, тестуванням, зневадженням і супроводом.", "content": "Кодування — процес написання початкового коду обраною або обраними мовами програмування з метою реалізації певного алгоритму або алгоритмів. В більш точному сенсі — процес перетворення моделей проектування в моделі реалізації обраною мовою програмування. Не слід плутати програмування і безпосередньо кодування. Кодування є лише частиною програмування, поряд з аналізом, проектуванням, компіляцією, тестуванням, зневадженням і супроводом. Дивись також Програмування Посилання Кодування автомобілів BMW Категорія:Кодування Категорія:Програмування"}
{"category": "Програмування", "title": "Кодування символів", "abstract": "Набі́р си́мволів, кодува́ння си́мволів, табли́ця си́мволів (англ. character set, character encoding) — певна таблиця кодування скінченної множини символів. Така таблиця зіставляє кожному символу послідовність довжиною в один або більше байт.\nНерідко замість терміна набір символів неправильно вживають термін кодова сторінка, що означає насправді окремий випадок набору символів з однобайтовим кодуванням. Термін кодування (в комп'ютерному контексті) є синонімом терміна «набір символів».\nЗараз в основному використовуються кодування двох типів: сумісні з ASCII і сумісні з EBCDIC. Переважна більшість кодувань, в тому числі UTF-8 Юнікода, — сумісні з ASCII. Кодування на базі EBCDIC (наприклад, ЄС ЕОМ ДКОІ-8) використовуються тільки на деяких мейнфреймах.\nСпочатку в кожній операційній системі використовувався один набір символів. Тепер використовувані набори символів стандартизовані та залежать від типу операційної системи лише за традицією й установлюються відповідно до локалі.\nУ Вікіпедії й інших проєктах фонду Вікімедія використовується Юнікод (UTF-8).", "content": "Набі́р си́мволів, кодува́ння си́мволів, табли́ця си́мволів () — певна таблиця кодування скінченної множини символів. Така таблиця зіставляє кожному символу послідовність довжиною в один або більше байт. Нерідко замість терміна набір символів неправильно вживають термін кодова сторінка, що означає насправді окремий випадок набору символів з однобайтовим кодуванням. Термін кодування (в комп'ютерному контексті) є синонімом терміна «набір символів». Зараз в основному використовуються кодування двох типів: сумісні з ASCII і сумісні з EBCDIC. Переважна більшість кодувань, в тому числі UTF-8 Юнікода, — сумісні з ASCII. Кодування на базі EBCDIC (наприклад, ЄС ЕОМ ДКОІ-8) використовуються тільки на деяких мейнфреймах. Спочатку в кожній операційній системі використовувався один набір символів. Тепер використовувані набори символів стандартизовані та залежать від типу операційної системи лише за традицією й установлюються відповідно до локалі. У Вікіпедії й інших проєктах фонду Вікімедія використовується Юнікод (UTF-8). Див. також Кодова сторінка Юнікод Розкладка клавіатури Кодування символів у HTML Джерела Жураковський Ю.П., Полторак В.П.. «Теорія інформації і кодування: підручник». - 2001. Иванов Г. Г., Красносельский Б. М. Радиооператор. — М.: ДОСААФ, 1976. Красовский М. М. Азбука Морзе. Приём на слух и работа на ключе // Дешёвая библиотека журнала «Радио всем», вып. 19. — М.: Государственное издательство, 1927. Лоусон Б. Шарп Р. Издательство: Питер; Год: 2011. Прохоренок Н. HTML, JavaScript, PHP и MySQL. 3-е изд. — СПб.: БХВ-Петербург, 2010. — 912 с. — (Профессиональное программирование). Суэринг С., Конверс Т., Парк Д. PHP и MySQL. Библия программиста. 2-е изд. — М.: ООО \"И.Д. Вильямс\", 2010. — 912 с. * Категорія:Цифрові обчислення Категорія:Програмування"}
{"category": "Програмування", "title": "Команда (програмування)", "abstract": "У програмуванні, команда — це наказ комп'ютерній програмі діяти як деякий інтерпретатор для вирішення задачі. У загальнішому випадку, команда — це зазначення деякому інтерфейсу (наприклад командній оболонці) командного рядка.\nЗокрема, термін команда використовується в мовах імперативного програмування. Ці мови названі так, тому що їх оператори, як правило, пишуться на зразок наказового дієслова що використовується у багатьох природних мовах. Якщо дивитися на оператор імперативної мови як речення природної мови, то команда, в загальному, подібна до дієслова.\nБагато програм допускають використання спеціально відформатованих аргументів, відомих як операнди, які змінюють стандартну поведінку команди, в той час як додаткові аргументи описують дії команди. Порівняємо з природою мовою: операнди відповідають прислівникам, в той час як інші аргументи — додатками.", "content": "У програмуванні, команда — це наказ комп'ютерній програмі діяти як деякий інтерпретатор для вирішення задачі. У загальнішому випадку, команда — це зазначення деякому інтерфейсу (наприклад командній оболонці) командного рядка. Зокрема, термін команда використовується в мовах імперативного програмування. Ці мови названі так, тому що їх оператори, як правило, пишуться на зразок наказового дієслова що використовується у багатьох природних мовах. Якщо дивитися на оператор імперативної мови як речення природної мови, то команда, в загальному, подібна до дієслова. Багато програм допускають використання спеціально відформатованих аргументів, відомих як операнди, які змінюють стандартну поведінку команди, в той час як додаткові аргументи описують дії команди. Порівняємо з природою мовою: операнди відповідають прислівникам, в той час як інші аргументи — додатками. Команди для інтерпретатора командного рядка Все те що подається на вхід командної оболонки для інтерпретації називається командами. Частина з них команди вбудовані в командну оболонку, частина команди які виконуються ядром операційної системи (наприклад виклик exec() тощо), частина програми утиліти. Нижче наводяться кілька команд для інтерпретатора командного рядка: cd /home/pete Команда cd змінює розташування користувача в дереві каталогів з поточного на каталог /home/pete. echo «hello» Команда echo виводить текст hello в потік стандартного виходу, — в цьому випадку, надрукує цей текст на екрані. Команди процесора Команди процесора — команди на самому низькому рівні програмування (Див. Асемблер). Їх можна розділити на 5 груп: команди переносу даних, які виконують перенесення даних між регістрами чи між регістрами та пам'яттю; арифметичні команди, які включають в себе команди додавання, віднімання чи зменшення на одиницю (декрементування) даних у реєстрах чи пам'яті; логічні команди, які дозволяють виконувати такі логічні операції як порівняння, зсув чи взяття додаткового числа у реєстрах чи пам'яті; команди переходу які забезпечують безумовну чи умовну передачу керування, а також виклик та повернення з підпрограм; команди керування та команди роботи зі стеком, які організують введення — виведення даних, доступ до стека та внутрішнього Регістра ознак процесора. Категорія:Програмування Категорія:Інтерфейс користувача Категорія:Команди Windows"}
{"category": "Програмування", "title": "Команди переходу", "abstract": "Кома́нди перехо́ду або Кома́нди переда́чі керування (англ. branch instructions) — команди процесора, які змінюють послідовний порядок виконання програми (тобто перезавантажують лічильник команд вказаною адресою, а не збільшуючи його значення на довжину поточної команди). Команди переходу можуть бути умовними (англ. conditional branch) та безумовними (англ. unconditional branch).", "content": "Кома́нди перехо́ду або Кома́нди переда́чі керування () — команди процесора, які змінюють послідовний порядок виконання програми (тобто перезавантажують лічильник команд вказаною адресою, а не збільшуючи його значення на довжину поточної команди). Команди переходу можуть бути умовними () та безумовними (). Команди умовного переходу В командах умовного переходу рішення про примусовий перехід до іншої адреси (шляхом перезавантаження лічильника команд) або продовження звичайного режиму виконання програми приймається в залежності від виконання або невиконання певної умови. Реалізація команд умовних переходів в різних комп'ютерних архітектурах може відрізнятись. В деяких архітектурах обчислення умови для прийняття рішення про подальший перехід та безпосередньо команда переходу відокремлені. Такою умовою може бути, наприклад, рівність певних значень, або їхня нерівність (в той чи інший бік). Для обчислення цього факту часто використовують арифметичні команди (тоді якщо операнди рівні, результат буде нульовим і т. ін.). В більшості CISC-архітектур арифметичні команди встановлюють спеціалізовані біти окремого регістра стану процесора (такі, наприклад, як біт рівності результатів, біт нульового результату тощо), а команди умовного переходу можуть відповідно аналізувати ці біти. +---------+---------+-------+----------------------------+ | BEQ | R1 | R2 | адреса переходу | BEQ R1,R2 +---------+---------+-------+----------------------------+ Формат RISC-команди умовного переходу за рівністю значень двох регістрів (PC:=адреса переходу ЯКЩО R1=R2) В RISC-архітектурах команди умовного переходу, як правило, здатні аналізувати результат в одному з регістрів загального призначення (нульовий/ненульовий) або порівнювати результати в двох різних регістрах (більше/менше) і на основі цього перезавантажувати лічильник команди чи ні. Як правило, повного перезавантаження адреси лічильника команд не відбувається. Поле адреси переходу у відповідних командах менше розрядності лічильника, тому перезавантажуються лише молодші розряди адреси. Таким чином, діапазон можливих адрес скорочується, але формат команди залишається фіксованим. Команди безумовного переходу +---------+---------------------------------------------+ | JMP | адреса переходу | +---------+---------------------------------------------+ Безумовний перехід примусово перезавантажує лічильник команд адресою (повністю або лише молодшу частину адреси), яка міститься у відповідному полі команди. Діапазон можливих адрес для переходу визначається розрядністю поля команди. Команди виклику підпрограм і повернення з підпрограм команди виклику підпрограм і повернення з підпрограм — передають керування підпрограмі, зберігаючи адресу повернення й, можливо, (інформації про стан системи), а також організують коректне відновлення після виходу з підпрограми. команди виклику оброблювачів переривань — передають керування оброблювачу переривань. Іноді ці команди розглядаються як особливий випадок команд виклику підпрограм. Проблеми в конвеєрі В конвеєрі при виконанні команди переходу (насамперед умовного) факт того, чи відбудеться перехід, чи ні, стає відомим на пізніх етапах конвеєра. За цей час в конвеєр на ранні етапи завантажуються наступні за цією команди. У випадку, якщо перехід відбувається, то зрозуміло, що потрібно повністю замінити послідовність інструкцій, які слідують за командою переходу. Такі конфлікти в конвеєрі призводять до істотного падіння швидкодії процесора. В сучасних процесорах для зниження негативу від цих конфліктів використовують різні методики передбачення переходів та спекулятивне виконання. Див. також Оператор — команда або інструкція в програмуванні. Цикл програми Блок Мова програмування Рекурсія Умовний перехід Категорія:Програмування Категорія:Архітектура комп'ютера Категорія:Машинний код"}
{"category": "Програмування", "title": "Командна оболонка Unix", "abstract": "Командна оболонка в UNIX є інтерфейсом командного рядка в Unix-подібних операційних системах, тобто виконує команди, які подає користувач, або які читаються з файлів. Такі файли з командами оболонки називаються сценаріями (скриптами, програмами) оболонки. Ці сценарії не компілюються, а інтерпретуються оболонкою. Це означає, що оболонка прочитує сценарій від початку до кінця, рядок за рядком, шукаючи зазначені там команди й виконуючи їх; на відміну від цього підходу, компілятор перетворює цілу програму до вигляду, придатного до виконання машиною — потім файл з таким кодом можна використати в сценарії оболонки. Характерна особливість мови оболонки — багато операцій, які в традиційних мовах програмування є вбудованими, виконуються з допомогою виклику зовнішніх програм.\nОдним з завдань оболонки є забезпечення користувацького середовища, яке можна налаштувати за допомогою конфігураційних файлів.", "content": "thumb|300px|Знімок екрану bash Командна оболонка в UNIX є інтерфейсом командного рядка в Unix-подібних операційних системах, тобто виконує команди, які подає користувач, або які читаються з файлів. Такі файли з командами оболонки називаються сценаріями (скриптами, програмами) оболонки. Ці сценарії не компілюються, а інтерпретуються оболонкою. Це означає, що оболонка прочитує сценарій від початку до кінця, рядок за рядком, шукаючи зазначені там команди й виконуючи їх; на відміну від цього підходу, компілятор перетворює цілу програму до вигляду, придатного до виконання машиною — потім файл з таким кодом можна використати в сценарії оболонки. Характерна особливість мови оболонки — багато операцій, які в традиційних мовах програмування є вбудованими, виконуються з допомогою виклику зовнішніх програм. Одним з завдань оболонки є забезпечення користувацького середовища, яке можна налаштувати за допомогою конфігураційних файлів. Види оболонок thumb UNIX надає на вибір декілька різних оболонок: sh, або оболонка Борна (Bourne Shell) одна з перших оболонок, яка була використана у UNIX-подібних середовищах. Це базова оболонка, маленька та з невеликим набором можливостей. Вона є де-факто стандартною оболонкою, та присутня на кожній системі із UNIX. На Лінукс /bin/sh може бути символьним лінком на bash. Це зроблено для того, щоб забезпечити сумісність з програмами UNIX. bash, або нова оболонка Борна (Bourne Again Shell) стандартна оболонка Лінукс. У більшості користувачів Лінукс стандартною оболонкою встановлено саме bash. У деякому сенсі bash — це надбудова над sh, набір доповнень та додаткових модулів. Таким чином, нова оболонка Борна сумісна зі звичайною оболонкою Борна: команди, що працюють у sh, будуть працювати і у bash, але не обов'язково навпаки. csh, або C-орієнтована оболонка (C Shell) синтаксис цієї оболонки схожий із мовою програмування C. Зазвичай, цією оболонкою користуються програмісти. tcsh, або покращена C-орієнтована оболонка (Turbo C Shell) надбудова над csh. ksh, або оболонка Корна (Korn Shell) Була написана у початку 1980-х років та отримала найкращі на той час можливості оболонки Борна та csh. Є надбудовою над оболонкою Борна та гарантує виконання скриптів написаних для оболонки Борна. Стандартом POSIX є оболонка Корна з обмеженими можливостями. zsh сучасна оболонка, зворотно сумісна із bash. У файлі /etc/shells знаходиться інформація про оболонки, присутні у системі: mia:~> cat /etc/shells /bin/bash /bin/sh /bin/tcsh /bin/csh Оболонка користувача встановлюється у файлі /etc/passwd. Наприклад, рядок користувача mia, який має встановлену оболонку bash: mia:L2NOfqdlPrHwE:504:504:Mia Maya:/home/mia:/bin/bash Перемикання між оболонками Користувач може в будь-який момент запустити іншу оболонку. Наприклад, якщо він за дефолтом працює під управліннями bash, а йому зручніше виконати якісь дії під оболонкою csh, він запускає цю оболонку mia:~>csh Для повернення під управління bash потрібно набрати команду exit. Див. також DEV Challenge Джерела Посібник з Bash для початківців Softpanorama: Nikolai Bezroukov. Introduction to the Unix shell history Категорія:UNIX Категорія:Програмування Категорія:Командні оболонки Категорія:Скриптові мови Категорія:POSIX Категорія:Системне адміністрування"}
{"category": "Програмування", "title": "Коментар", "abstract": "Комент́ар (від лат. commentārium — записки, тлумачення) —\n\nТлумачення певного тексту або книги.\nДодаток у кінці книги, примітки по тексту в підрядкових виносках з поясненням окремих місць, термінів та виразів.\nРоз'яснювальний або критичний коментар з приводу яких-небудь подій, явищ (використовується переважно у ЗМІ).\nЗапис користувача вебсайту, що висловлює його ставлення до інформації, розміщеної на певній сторінці. Розміщується, як правило, за допомогою вебзнарядь знизу коментованої інформації.\nВ загальному сенсі коментар — усна або письмова ремарка, переважно пов'язана з додатковою інформацією, зауваженням або твердженням. Коментар може позначатися абревіатурами: латинською N.B. (nota bene — поміть добре, зверни увагу) або англійською obs.: від observation — в значенні анотація або від obsolete — застарілий. Термін коментар може мати різні значення в залежності від конкретних галузей застосування.", "content": "Комент́ар (від — записки, тлумачення) — Тлумачення певного тексту або книги.Словник іншомовних слів Мельничука Додаток у кінці книги, примітки по тексту в підрядкових виносках з поясненням окремих місць, термінів та виразів. Роз'яснювальний або критичний коментар з приводу яких-небудь подій, явищ (використовується переважно у ЗМІ). Запис користувача вебсайту, що висловлює його ставлення до інформації, розміщеної на певній сторінці. Розміщується, як правило, за допомогою вебзнарядь знизу коментованої інформації. В загальному сенсі коментар — усна або письмова ремарка, переважно пов'язана з додатковою інформацією, зауваженням або твердженням. Коментар може позначатися абревіатурами: латинською N.B. (nota bene — поміть добре, зверни увагу) або англійською obs.: від observation — в значенні анотація або від obsolete — застарілий. Термін коментар може мати різні значення в залежності від конкретних галузей застосування. Етимологія Коментар — від — записна книжка; записки; протокол; тлумачення пов'язане з commentāri — ретельно продумувати, вивчати; викладати, писати; тлумачити, яке є інтенсивним дієсловом до comminīscī — пригадувати; видумувати; винаходити, утвореного за допомогою префікса com- — з- від дієслова memenī — пам'ятати, думати; згадувати, яке є перфектом з подвоєнням кореня men- представленого також у mēns — розум; думка, з праслов'янських mьněti — думати, pamętь — пам'ять (мнити)http://litopys.org.ua/ Ізборник (історія, мовознавство, літературознавство)] — там Етимологічний словник української мови: В 7 т., т. 2 / АН УРСР. Інститут мовознавства ім. О. О. Потебні; Редкол. О. С. Мельничук (головний ред.) та ін. — К.: Наук. думка, 1983 — … Комп'ютерні інформаційні технології Наприклад, коментар при редагуванні тексту в Вікіпедії додається таким чином: <!-- Власне тут іде коментар, який видно лише при редагуванні тексту ;) --> Див. також Авторський коментар Disqus Примітки Посилання Коментар // Категорія:Редагування Категорія:Програмування Категорія:Методологія науки"}
{"category": "Програмування", "title": "Компілятор", "abstract": "Компіля́тор (англ. Compiler від англ. to compile — збирати в ціле) — комп'ютерна програма (або їх набір), що перетворює (компілює) початковий код, написаний певною мовою програмування (вихідна мова, англ. source language), на семантично еквівалентний код в іншій мові програмування (цільова мова, англ. target language), який зазвичай необхідний для виконання програми машиною, наприклад, комп'ютером. В СРСР, зокрема в УРСР, з 1952 року до середини 1960-х років використовувався термін програмувальна програма (ПП).\nКоротко компілятор можна визначити як програму або технічний засіб, що виконує компіляцію.\nІсторично компілятором називалась програма, що зв'язувала підпрограми, чим і зумовлено походження слова. Сьогодні це завдання виконує компонувальник.\nДля виконання програма не завжди повинна бути перекладена компілятором, існує також інший принцип: покрокове виконання програмних інструкцій інтерпретатором.", "content": "Компіля́тор ( від — збирати в ціле) — комп'ютерна програма (або їх набір), що перетворює (компілює) початковий код, написаний певною мовою програмування (вихідна мова, ), на семантично еквівалентний код в іншій мові програмування (цільова мова, ), який зазвичай необхідний для виконання програми машиною, наприклад, комп'ютером. В СРСР, зокрема в УРСР, з 1952 року до середини 1960-х років використовувався термін програмувальна програма (ПП). Коротко компілятор можна визначити як програму або технічний засіб, що виконує компіляцію. Історично компілятором називалась програма, що зв'язувала підпрограми, чим і зумовлено походження слова. Сьогодні це завдання виконує компонувальник. Для виконання програма не завжди повинна бути перекладена компілятором, існує також інший принцип: покрокове виконання програмних інструкцій інтерпретатором. Історія розвитку Термін «компілятор» вперше з'явився на початку 50-х років, коли почала формуватися потреба підвищення продуктивності програмістів шляхом запровадження високорівневих мов програмування. Від початку комп'ютерні програми писали на асемблері — низькорівневій, апаратно-залежній мові. Зі збільшенням розміру пам'яті первісних комп'ютерів виникали нові можливості для оптимізації процесу створення програм і переходу на сутності вищого рівня. Автором першого компілятора вважається Ґрейс Гопер, яка у 1952 році створила компілятор для мови А-0 СистемаHopper, Grace. «The Education of a Computer». Proceedings of the Association for Computing Machinery Conference 1952, reprinted Vol. 9, No. 3-4, 1952, pp. 271—281.. Цей компілятор являв собою окремий пристрій, який при завантаженні програм до оперативної пам'яті комп'ютера, без використання процесора, перекодовував програму у мнемонічних кодах (асемблері) у двійкові програмні коди. Тому цей перший компілятор функціонував як завантажувач та компонувальник, та його складно віднести до компілятора у сучасному розумінні цього терміна. Першими компіляторами були програмувальні програми ПП-1 (1954 рік) та ПП-2 (1955 рік), які були реалізовані на ЕОМ «Стріла» в Москві. Перший в світі компілятор універсальної мови програмування високого рівня — Адресної мови програмування (1955 р.) з опосередкованою адресацією (вказівниками) є Програмуюча Програма Адресної мови для ЕОМ \"Київ\" (ПП-АК) та ПП-2 (1955). Адресної мови програмування була реалізована під різними платформами, зокрема: комп'ютери М-20 (БЕСМ-3, БЕСМ-4), Урал, Дніпро, Мінськ тощо. Компілятори Адресної мови програмування писались на так званій ідеальній адресній обчислювальній машині (ІАОМ), яка є базовою частиною (підмножиною) Адресної мови програмування. Оскільки Адресна мова програмування (1955 р.) мало відома закордоном, то часто помилково вважають авторами першого в світі повноцінного компілятора команду розробки мови програмування Фортран на чолі з Джоном Бакусом, яка представила винахід у 1957 році. У 1960 році був представлений компілятор мови програмування Кобол, який теж мав можливість компілювати програми під різні платформи. Помилково вважають, що компілятор мови програмування Лісп 1962 року був першим компілятором, написаним мовою джерела компіляції, оскільки про технологію розробки компіляторів Адресної мови програмування мало кому відомо. Відтоді написання компілятора на мові, яку він компілює, стало поширеною практикою, відомими прикладами якої стали мови програмування С і Паскаль. Процес компіляції Процес, у якому компілятор читає записану початковою мовою програму та записує цільовою мовою, називають компіляцією (трансляцією, перекладом). Залежно від типу компілятора та налаштувань, цей процес може бути як простим однопрохідним зчитуванням і записом результату, так і розгалуженою багатокроковою ресурсомісткою обробкою й аналізом вхідного коду для численних оптимізацій та налаштувань. Загалом компіляцію поділяють на такі послідовні та залежні кроки: Аналіз (front-end) — зчитування та розбиття початкової програми на складові частини для створення проміжного представлення. Лексичний аналіз — на цьому етапі послідовність символів сирцевого файлу перетворюється в послідовність лексем. Синтаксичний аналіз, під час якого послідовність лексем перетворюється в дерево розбору. Семантичний аналіз — перевірка відповідності правилам вхідної мови та побудова таблиці символів. Генератор проміжного коду будує проміжне представлення для подальших оптимізацій. Синтез (back-end) — побудова цільової програми на базі проміжного представлення. Попередній аналіз проміжного представлення на залежності, потік даних та інші контекстні властивості, важливі для оптимізації. Оптимізація — покращення для швидкодії, розміру, паралелізму тощо. Генератор цільового коду створює кінцевий результат роботи компілятора — цільову програму. У конкретних реалізаціях компіляторів ці етапи можуть бути розділені або, навпаки, поєднані в тому чи іншому вигляді. Початкова мова визначається її синтаксисом — описом того, з яких конструкцій складається мова, та семантикою — набором правил, що визначають суть цих конструкцій. Аналіз (front-end) Протягом аналізу, або початкової стадії (front-end), програму розбивають на частини, на які накладається граматична структура. Наступним кроком на базі цієї структури створюють проміжне представлення програми. Важливими елементами аналізу є виявлення синтаксичних помилок та семантичних невідповідностей, які відображає компілятор. Також протягом фази аналізу збирається інформація до таблиці символів, ключової для фази компонування. До фази аналізу зачислюють лексичний, синтаксичний та семантичний аналізи та фазу генерації проміжного коду. Лексичний розбір Лексичний розбір виділяють для спрощення побудови компілятора. Це лінійне сканування вхідної програми, при якому символи групують в токени — послідовності символів, що мають певне сукупне значення. Наступний рядок мовою Паскаль len := 3.14 * r; складається з таких токенів: Ідентифікатор len Символ присвоєння := Числова стала 3,14 Знак множення * Ідентифікатор r Роздільник операторів ; Синтаксичний аналіз Послідовність машинних символів, які утворюють токен, називають лексемою токена. Токени мають тип (наприклад, ідентифікатор, числова стала — це типи токенів). Деякі токени мають лексичне значення (наприклад, значення числової чи рядкової константи, утвореної з лексеми токена). Завдання лексичного аналізатора — виокремити лексеми токенів і повідомити синтаксичний аналізатор про тип токена та його лексичне значення. Ієрархічний аналіз називають розбором () чи синтаксичним аналізом, у ході якого відбувається групування токенів програми. В синтаксичному аналізі символом називають токени (термінали) та групи токенів, об'єднаних у логічне ціле в процесі аналізу (нетермінали). Синтаксис звичайно визначається контекстно-незалежною граматикою, що складається з символів — терміналів і нетерміналів, стартового символу що належить множині нетерміналів, та контесктно-незалежних продукцій. Програма є послідовністю терміналів, яку можна вивести зі стартового символу, послідовно застосовуючи правила виводу (продукції). Продукція — це заміна послідовності символів S1 на послідовність символів S2 (Позначається. S1 : S2 або S1 -> S2). Продукція називається контекстно-незалежною, якщо S1 — один символ. Зазвичай розглядають лише контекстно-незалежні продукції. Задача синтаксичного аналізатора — встановити шлях, яким вхідна програма виводиться зі стартового символу. Наприклад, наступна граматика із трьох продукцій описує вирази (expression), що можуть складатись з ідентифікаторів (identifier), чисел (number) і знаку додавання + expression : identifier expression : number expression : expression + expression Перший рядок означає, що будь-який ідентифікатор є виразом. Другий рядок означає що будь-яке число є виразом. Третій рядок означає, що будь-яка послідовність з двох виразів, розділених знаком додавання, теж є виразом. В цій граматиці символами є expression, number, identifier та +. Expression є стартовим символом і нетерміналом, решта символів є терміналами. Семантичний аналіз На базі синтаксичного дерева семантичний аналізатор перевіряє вхідну програму на відповідність правилам і визначенням мови програмування. Важливою частиною цієї фази є перевірка відповідності типів даних. Саме протягом семантичного аналізу виявляють помилки приведення типів, використання неініційованих змінних, відкладеного визначення типів. У ході аналізу будується таблиця символів — ключове джерело посилань для подальшого компонування програми. Генератор проміжного коду Протягом своєї роботи компілятор може мати одне, або навіть декілька проміжних представлень коду, як вхідні параметри для різних фаз компіляції. Так, синтаксичне дерево побудоване протягом синтаксичного аналізу є прикладом такої проміжної структури. Проте типовим принципом побудови компіляторів є генерація проміжного коду у кінці фази аналізу для подальшої оптимізації та трансляції у вихідну мову. Цей проміжний код ще не є вихідним кодом, але має важливі властивості: він має досить легко генеруватися та легко транслюватися у цільову мову. Синтез (back-end) На базі проміжного представлення та наповненої таблиці функції конструюється вихідна програма. Оскільки початковий вхідний код (а відповідно і проміжне представлення) може бути оптимізований як на базі високорівневих покращень, так і беручи до уваги детальне знання конкретної архітектури виходного коду, він підлягає декільком фазам аналізу. Аналізується час життя даних та їх проміжне переміщення за час роботи програми, деякі блоки коду ідентифікуються, як можливі кандидати до підстановки низькорівневим кодом. Після аналізу відбувається оптимізація та результат покращень транслюється у вихідну мову. На цій фазі компіляції деякі фази вже є необов'язковими (аналіз, оптимізація) і можуть бути пропущені. Попередній аналіз проміжного коду З часів первинних компіляторів, коли проміжний код безпосередньо транслювався у вихідну мову, було розроблено велику кількість покращень, уточнень та оптимізацій в залежності від змісту вхідної програми. Сучасні компілятори можуть виконувати великий набір досліджень вхідного коду, щоб досягти переваги у продуктивності, використовуваній пам'яті, розмірі вихідного файла тощо. Приклад розповсюджених видів аналізу: Аналіз потоку даних () — побудова ланцюга використання-визначення () на базі якого у подальшого виконуються численні оптимізації. Аналіз залежностей — пошук інструкцій та блоків коду, які не залежать від послідовності виконання в певному контексті. Пошук псевдонімів () — в залежності від того, чи вказують певні змінні у певний момент часу на один і той самий об'єкт у пам'яті (є псевдонімами), можна робити припущення щодо взаємної їх підстановки та оптимізації. Аналіз області видимості () — динамічний аналіз часу життя та області видимості вказівників для ефективнішого використання пам'яті. На цьому етапі також будується граф викликів — структура послідовності викликів функцій у вхідному коді, та граф потоку керування. Оптимізація проміжного коду Оптимізація є проміжним етапом перед кінцевою побудовою вихідного коду, під час якого код може бути покращений задля швидкодії, розміру результуючого файлу, ефективних обчислень на паралельних потоках виконання, об'єму використовуваній пам'яті тощо. За масштабом дії оптимізацію можна поділити на локальну, та глобальну. Локальна оптимізація відбувається у межах базового блоку (групи послідовних команд без розґалуджень і переходів) і полягає у локальних поліпшеннях: видалення коду, який не використовується, пошук тотожних підвиразів, зниження складності підрахунків шляхом заміни на більш дешеві операції (як приклад, степінь замінити множенням), згорання констант () — підрахунок і заміна констант їх значеннями, поліпшення повернення значення локальне розподілення регістрів () Більш просунутою та розширеною є глобальна оптимізація на рівні сутностей суцільної програми. Під час глобальних оптимізацій інтенсивно використовуються результати попередніх аналізів — потоку даних, залежностей та інших. Серед численних оптимізацій можна виділити: Глобальне розподілення регістрів () Розмотування циклів Усунення загальних підвиразів Автоматичне розпаралелення Оптимізація циклів для розпаралелення Генерація цільового коду програми Останньою фазою компіляції є саме створення вихідного коду програми. За створення відповідає генератор цільового коду, який на базі проміжного представлення та з урахуванням оптимізацій виводить еквівалентну вихідну програму. Основними вимогами до генератора є збереження семантичного змісту вхідного коду та ефективне використання ресурсів у вихідному коді цілі. Виділяють такі задачі, притаманні фазі генерації: Вибір команд — саме трансляція команд входу у код цілі. Впорядкування команд — визначення порядку слідування команд, місце для останніх можливих оптимізацій. Розподіл та призначення регістрів — вибір змінних, які будуть знаходитися у пам'яті в у кожен момент часу програми, та їх розміщення у конкретних регістрах. Налагоджувальна інформація () додається саме на цій фінальній стадії. Види компіляторів За принципом роботи можна виділити такі види компіляторів: Однопрохідні — компіляція здійснюється в один прохід пропускаючи багато проміжних кроків оптимізацій і перевірок. Перші компілятори мови Pascal. Компілятори у зшитий код () — код, який повністю складається з підпрограм. По суті компілятор просто замінює кожну інструкцію вхідного коду на підпрограму вихідного — зшиває з заготівок. Такий компілятор має мова програмування Forth. Інкрементальні компілятори — деякі функції можуть бути скомпільовані під час виконання інкрементально, наприклад у поєднанні з інтерпретованим виконанням. Такий тип компіляторів поширений у сімействі LISP. Передфінальний компілятор (), який компілює у вихідну мову теоретичної машини. Такий компілятор реалізований для мови програмування Prolog; він генерує вихідний код для абстрактної машини Уоррена (). Динамічний компілятор () — компіляція на льоту. Див. нижче. Компілятор зі змінними цілями (), який відносно просто можна змінити для генерації цільового коду під іншу архітектуру процесору. Загалом така властивість досягається шляхом зниження якості вихідного коду (у порівнянні з цільовими компіляторами під конкретний процесор). Представником такого типу компіляторів є набір GCC. Компілятор розпаралелення, який генерує вихідних код для запуску на паралельній архітектурі. — транслятор, що сприймає формальний опис мови програмування й генерує компілятор для цієї мови. Векторизувальний. Транслює вихідний код в машинний код комп'ютерів оснащених векторним процесором. . Види компіляторів C Borland International Вихід компілятора Turbo C являє собою розумний, але не дуже оптимізований код. Крім згортки констант, видалення зайвих завантажень регістрів і алгебраїчних спрощень, компілятор виконує тільки зниження потужності, видалення недосяжного коду і розміщення змінних у регістрах. Він не підтримує інші загальні методи оптимізації, такі як видалення зайвих збережень, загальних підвиразів і змінні індукції циклу, а також винесення інваріантного коду. Turbo C розумно керує прологом і епілогом функцій і використанням регістрів, засилаючи в стек і витягаючи тільки ті регістри, що явно використовуються усередині тіла функції. Computer Innovation Inc Компілятор C86Plus виробляє чудовий код із середнім рівнем оптимізації. Він виконує базові прийоми оптимізації, такі як згортка констант і розмноження копій. Однак він не виконує розмноження констант для видалення зайвих збережень. Хоча компілятор успішно виконує алгебраїчні спрощення, він породжує зайві інструкції через те, що розміщає результати в регістрах, замість того, щоб поміщати їх у змінні. Цей ефект виявляється в том, що при розміщенні змінних у регістрах починаються спроби перерозміщення, тому що при виконанні декількох операторів результати в дійсності повинні бути привласнені відповідним змінним. Хоча C86Plus успішно справляється зі згорткою явних присвоювань, що дублюються, в одне присвоювання, видалення зайвих збережень він виконує хитливо. Він не виконує істотну оптимізацію циклів. Datalight Inc З появою Optimum-C Datalight стала одним з перших постачальників, що запропонували оптимізований компілятор. Хоча набір тестів не підтвердив наочно претензії Datalight на глобальну оптимізацію, Optimum-C спрацював так добре в деяких фрагментах тесту, що продемонстрував слабкі фрагменти набору, які вимагають змін для удосконалення бажаної перевірки. Наприклад, у першій версії функції jump-compression не поверталося значення, що робило всі обчислення і присвоювання у функції зайвими. Optimum-C виявив це і видалив велику частину коду функції, включаючи ланцюжок переходів. У тесті розмноження констант і копій Optimum-C визначив, що присвоювання i5 в обох умовних операторах є зайвим стосовно наступних присвоювань. Компілятор видалив не тільки ці присвоювання, але й умовні оператори. Незадовільним виявилося видалення зайвих збережень значень регістрів. Optimum-C — єдиний компілятор, що намагався виконати глибоке видалення загальних виражень. Перевірка згенерованого коду показала, що загальне вираження i5+i2 було переміщено вище першого базового блоку умовного оператора, але не було вилучено з другого. Поза обмеженнями на стандартне використання регістрів, що накладаються сімейством мікропроцесорів 80x86, Optimum-C розумно використовує регістри. У функції jump-compression кожен переданий параметр був поміщений у регістр. Усередині тіла функції не було посилань у пам'ять, крім початкового засилання в регістри. Однією важливою областю, у якій компілятор Optimum-C вимагає поліпшень, є оптимізація циклів. Компілятор не намагається виконувати винесення інваріантного коду і видалення змінних індукції циклу. Тест виконання показав, що компілятор Datalight дуже ефективно керує введенням/висновком getc/putc, а інші тести виконуються в прийнятний час. Lattice Inc Компілятор, що має велику історію, Lattice MS-DOS C послідовно удосконалювався з кожною новою версією. Він відомий як генератор стабільного, передбачуваного коду і виконує помірну оптимізацію. Lattice С виконує зниження потужності, стиск ланцюжка переходів і видалення загальних підвиразів. Він не видаляє присвоювання, що дублюються після тесту вбудованих функцій і зайві присвоювання у функції dead-code. Lattice C не виконує оптимізацію циклів. Manx Software Systems Inc Компілятор Aztec C86 згенерував чудовий код з досить гарним рівнем оптимізації. Крім згортки констант і алгебраїчних спрощень, Aztec C86 виконав зниження потужності і видалення загальних підвиразів. Однак, він не виконав видалення зайвих присвоювань і не видаляв недосяжний код. Aztec C86 згенерував код для недосяжного оператора printf разом з безумовним переходом через нього. Оскільки будь-яка програма на Сі має значну кількість викликів функцій, заголовок кожного виклику необхідно мінімізувати. Aztec C86 використовує незвичайний, але ефективний підхід до рішення цієї проблеми. На виході компілятора виходить текст у мові асемблера, що обробляється окремим асемблером. Компілятор вставляє в текст директиви умовного асемблювання навколо коду, що встановлює стековий кадр і зберігає регістри. Після генерації коду функції, компілятор визначає символи для керування установкою стекового кадру і збереження тільки тих регістрів, що використовуються у функції. Aztec C86 не зміг вирішити задачу перетворення ланцюжка переходів в один перехід до кінцевої мети. Він також не виконував оптимізацію циклів. Metaware Inc High C виробляє чудовий код із середнім рівнем оптимізації. Компілятор виконує всі базові види оптимізації, включаючи згортку констант і алгебраїчні спрощення, видалення зайвих операцій завантаження регістрів, зниження потужності і видалення загальних підвиразів. Компілятор Metaware видаляє недосяжний код, але не видаляє зайві присвоювання. High C розумно використовує машинно-залежні інструкції. Компілятор удосконалить завантаження констант із крапкою, що плаває, використовуючи команду копіювання рядків MOVS процесорів 80x86 для запису значень із крапкою, що плаває, обчислених під час компіляції. Він також генерує інструкцію LEAVE процесорів 80x86 для епілогу функцій, але встановлює адресацію стекового кадру в пролозі функції за допомогою окремих інструкцій, а не використовуючи більш тривалу інструкцію ENTER. Компілятор High C не виконує винесення інваріантного коду, важливий метод оптимізації циклів. Він також не зміг застосувати успішне видалення змінних індукції циклів. Вбудовані функції підтримуються для декількох цілочисленних і строкових операцій, таких як strlen. Microsoft C У версії 5.0 свого компілятора Сі корпорація Microsoft вивела на ринок PC високий рівень оптимізації коду. Microsoft приділяє багато уваги аналізу циклів. C 5.0 — єдиний з розглянутих компіляторів, що виконує винесення інваріантного коду і сьогоденне видалення змінних індукції циклів. Компілятор Microsoft C 5.0 чудово використовує регістри, намагаючись мінімізувати звертання до пам'яті в тілі циклу . Простий приклад циклу в коді тесту демонструє ступінь оптимізації циклів, який виконує Microsoft C 5.0. Компілятор застосовує зниження потужності і цілком видаляє константне множення, виявляє кінцевий стан змінних, і поміщає в регістри всі змінні всередині циклу. C 5.0 видаляє цикл for і генерує код тільки з метою установки кінцевого стану змінної — індексу циклу й оператора, включеного в цикл. Компілятор також добре використовує регістри. Увага фірми Microsoft до оптимізації винагороджується при роботі тесту виконання. Він виконується за час, що є кращим чи близько до кращого по кожній категорії. WATCOM Новітній суперник, що завойовує позиції на ринку компіляторів C — WATCOM C 6.0 (див. Product Watch, Philip N. Hisley, за цей місяць). C 6.0 виробляє компактний код, що чудово використовує трохи обмежений комплект регістрів сімейства 80x86. Крім виконання базових прийомів оптимізації, він підтримує зниження потужності і видалення недосяжного коду і загальних підвиразів. У той час, як Microsoft досягає поліпшення коду завдяки оптимізації циклів, WATCOM збільшує швидкість шляхом зменшення керуючих заголовків викликів функцій до їхнього абсолютно мінімального розміру. Він досягає цього, шляхом переважної передачі параметрів через регістри, а не через стек. WATCOM дуже добре видаляє недосяжний код. C 6.0 не тільки видалив непотрібні присвоювання і недосяжний код усередині функції, але він також видалив пролог і епілог функції і згорнув усю функцію до простого повернення, приписавши ім'я функції до інструкції повернення основної функції. На завершення всього, компілятор видалив локальний виклик функції. Наскільки C 6.0 витончений у знищенні марної функції, настільки ж він безпомічний при видаленні марного присвоювання, що дублюється. Найбільш важлива область, за яку WATCOM C 6.0, як і Optimum-C, не зміг узятися, була оптимізація циклів. Він не підтримує винесення інваріантного коду і видалення змінної індукції циклів. Хоча C 6.0 не виконує розгортання циклів в окремі команди, він (також як Datalight Optimum-C і Computer Innovations C86Plus) використовує команду REP/STOSW процесорів 80x86 для ініціалізації тестового масиву, завдяки чому видаляє цикл. Прекрасна генерація коду в WATCOM, зокрема, розумне використання регістрів, дає йому дуже важливу перевагу. Він переміг у більшості тестів, що інтенсивно використовують процесор, і при цьому виконувався для великої моделі в кращий час, ніж більшість інших компіляторів для малої моделі. До слабких сторін WATCOM можна віднести введення/виведення файлів, використання getc і putc. Тут він близький до найгірших компіляторів. Стратегії компіляції Компілятори слугують своїм цілям у різний спосіб для різних мов програмування та парадигм. Так, якщо історично первинні компілятори транслювали код мови у апаратно залежний асемблер, то з часом виникла потреба у додаткових методах та шарах абстракції — компіляції на льоту, транслювання більш високорівневого коду в менший за рівнем, оптимізації по використанню вже скомпільованого коду тощо. Поширені стратегії компіляції: Компіляція перед виконанням (). Класичний принцип, коли компіляція проводиться окремо від виконання, зазвичай у відмінному від місця виконання середовищі. Компілятори мов програмування Pascal, C, C++, BASIC, Fortran, COBOL використовують стратегію такої попередньої компіляції. +Переваги Швидке завантаження в браузері. Витрачається менше часу за рахунок того, що застосунок компілюється до завантаження в браузер та кінцеві файли мають менший розмір. Виявлення помилок під час збірки. Мається можливість виправити всі помилки до запуску застосунку в режимі експлуатації. Підвищена безпека. Компіляція під час виконання (), відома також як динамічна компіляція. Суть полягає у компіляції часу виконання (), коли текст вхідної мови перетворюється у машинний код на льоту й тут же виконується. Ця техніка поєднує у собі методи як попередньої компіляції у проміжний код так і інтерпретації цього проміжного коду під час виконання. Будучи більш продвинутою технікою, компіляція на льоту має досить суворі вимоги до простоти компіляції, і не є доцільною для певних мов програмування. Принциповим представником JIT компіляції є середовище виконання мови Java, піонером же вважається Smalltalk. Транскомпіляція, або компіляція з однієї високорівневої мови в іншу (). Принциповою відмінністю даної стратегії є те, що як вхідний так і вихідний код є мовами програмування високого рівня. Типовими прикладами використання є підготовка коду для паралельної оптимізації, перекомпіляція старішого коду для нової версії стандарту мови програмування, компіляція мов-надбудов у базову мову. Представниками таких мов програмування є CoffeeScript, Dart, Haxe, Coccinelle. Перекомпіляція — динамічна компіляція частин програми під час виконання (). Особливість деяких серед виконання — емуляторів та віртуальних машин, перекомпільовувати деяку частину програми під час її роботи. Ця техніка використовується для переносу коду на іншу архітектуру під час його виконання, зокрема для запуску застарілих програм на сучасних операційних системах. Широко використовується Java run time та .Net Common Language Runtime, а також багатьма віртуальними машинами. Основними завданнями, які повинен виконувати динамічний рекомпілятор, є: Читання машинного коду з вихідної платформи Видає машинний код для цільової платформи Відомі компілятори Amsterdam Compiler Kit — набір засобів для написання компіляторів для системи Minix авторства Ендрю Таненбаума та Серіла Якобса. GCC — відомий набір компіляторів C та пізніше C++, створений Річардом Столменом; широко поширений у світі Linux. Clang — компілятор сімейства C/C++, який використовує технологію LLVM — віртуальної машини на базі проміжного представлення коду. Turbo Pascal — видатний компілятор створений Андерсом Гейлсбергом у 1983 році. Turbo C — компілятор мови C розроблений компанією Borland у 1987 році. Mono — багатоплатформовий набір засобів та компілятор мови C#, у вільному доступі. PyPy — JIT-компілятор мови Python написаний на мові Python. Генератори аналізаторів Побудовані алгоритми, що перетворюють опис вхідної мови у програму, що виконує аналіз і є велика кількість реалізацій цих алгоритмів. Є також утиліти, що автоматизують решту фаз компіляції та системи створення компіляторів у цілому В Unix поширені генератор лексичних аналізаторів (F)Lex, та генератори синтаксичних аналізаторів Bison та Yacc. Література Compilers: Principles, Techniques, and Tools (English) (вид. 2nd edition). Addison Wesley. 2006-09-10. ISBN 9780321486813. Engineering a Compiler, Second Edition(English) (вид. 2 edition). Morgan Kaufmann. 2011-02-21. ISBN 9780120884780. Advanced Compiler Design and Implementation (English) (вид. 1 edition). Morgan Kaufmann. 1997-08-15. ISBN 9781558603202. Compiler Design in C (English). Prentice-Hall. 1990-01-01. ISBN 9780131550452. Modern Compiler Implementation in Java (English) (вид. 2nd edition). Cambridge University Press. 2002-10-21. ISBN 9780521820608. Understanding and Writing Compilers: A do-it-yourself guide (English) (вид. 3rd ed. edition). Palgrave. 1979-10-01. ISBN 9780333217320. Let's Build a Compiler . compilers.iecc.com. Процитовано 2016-03-27. Посилання Категорія:Засоби розробки Категорія:Компілятори Категорія:Програмування"}
{"category": "Програмування", "title": "Концепція каркасно-компонентного програмування", "abstract": "Концепція каркасно-компонентного програмування (К3П) — це певний погляд на набір засобів для створення каркасу проєкту в цілому та розробки каркасів окремих компонентів, наповнення таких каркасів необхідним функціоналом та їх впровадження до самого проєкту чи інших компонентів.", "content": "Концепція каркасно-компонентного програмування (К3П) — це певний погляд на набір засобів для створення каркасу проєкту в цілому та розробки каркасів окремих компонентів, наповнення таких каркасів необхідним функціоналом та їх впровадження до самого проєкту чи інших компонентів. Основна термінологія Каркас проєкту — набір певним чином структурованих файлів та каталогів, що містять початкові відомості для створення програмного засобу (інсталяційного пакету, сайту, веб-застосунку, інше), але не містять конкретного змістовного наповнення (кодів, що визначають функціонал проєкту). Проєкт — це каркас проєкту, що принаймні частково містить змістовне наповнення у якому реалізований певний функціонал відповідно до технічних завдань. К3П передбачає можливість створення каркасу проєкту на етапі аналізу предметної області і відповідних технічних завдань, поділ між розробниками ділянок роботи (у разі потреби, із використанням принципів мережевого планування). У найбільш загальному випадку допускається розробка у повному обсязі каркасу проєкту та лише після цього наповнення його предметним змістом. З іншого боку К3П цілком допускає подальше масштабування та редагування проєкту з мінімальною витратою часу на аналіз вже виконаних робіт за рахунок строго визначених принципів його побудови. Клас — структура опису даних та функціоналу їх опрацювання згідно концепції ООП. Об'єкт — змінна типу даних «клас» в концепції ООП. Функціонал - набір функцій (методів) класу. Під компонентом будемо розуміти логічно та функціонально завершений блок кодів програми, який у загальному випадку містить засоби для опрацювання та відображення певних даних у залежності від його призначення. Структура компонента описується наперед визначеною ієрархією класів. Твердження. Будь-який компонент є об'єктом, але не будь-який об'єкт є компонентом. Каркас кодів — набір певним чином структурованих каталогів та файлів у цих каталогах. Каркас компонента — це каркас кодів, що містить файли-заготовки з початковими кодами створеними певною мовою програмування, які мають наперед визначену структуру. Після наповнення каркасу предметним вмістом він набуває ознак компоненту. СЕ — структурний елемент або елемент структури на певній схемі, що описує загальні принципи функціонування компоненту. Базовий компонент — компонент, що не містить у своїй структурі інших компонентів. Асоціаційний компонент — компонент, що містить у своїй структурі інші компоненти (композиція) або зв'язки з іншими компонентами (агрегація). Із вище зазначеного можна зробити висновок, що проєкт є блоком кодів та асоціаційним компонентом, компонент є міні-проєктом. Для чого потрібна К3П? Як відомо, основна причина використання кожної концепції програмування — систематизувати та узагальнити методи написання кодів, структуризувати певним чином елементи проєкту так, щоб він був масштабованим та зручним для читання/редагування не лише розробниками, які починали проект, а й залученими до розробки працівниками (програмістами, дизайнерами, тестувальниками) у майбутньому. З цієї причини з'явилась концепція ООП, паттерни програмування, парадигма MVC, бібліотеки шаблонів, фреймворки та інше. Метою даної статті є демонстрація можливостей організації кодів проєкту у вигляді набору компонентів, які створюються на основі строго визначеного каркасу. У свою чергу така організація кодів проєкту має сприяти підвищенню ефективності його редагування та масштабування. Як реалізувати К3П? У цілому, кожен може самостійно розвинути подібну ідею для власної практичної діяльності та у залежності від того, з чим розробник працює (Java, Pyton, C++ і т. д.). Перше з чого варто почати — ретельна розробка загальної структури компонента. Подальша зміна цієї складової вкрай небажана, особливо при наявності вже створених на її основі компонентів чи проєктів. Друге — створення шаблонів, що моделюють елементи попередньо розробленої структури. Розроблені шаблони цілком допускається редагувати у майбутньому, але з врахуванням принципу «не нашкодь!», тобто внесені зміни не повинні впливати на вже працюючі раніше створені компоненти. Третє — створення засобу для автоматичного генерування каркасу компонента. Подальший матеріал стосовно реалізації вищеперерахованих кроків буде демонструватися на прикладах з використанням JavaScript. MVC та К3П Перш ніж перейти до JavaScript коротко згадаємо загальновідомий архітектурний шаблон MVC. Особисто автору даної статті у схемі «Model View Controller» завжди чогось не вистачало… Виникає думка, що не вистачає такої компоненти, як події (Event). Можна зазначити, що Event це частина View або частина іншого СЕ. Але якщо це все ж частина, то чому б цю частину не винести окремо? Загальні уявлення про MMVCE Вище було згадано про події, але з'явилося певне подвоєне «MM» в абревіатурі «MMVCE». Перша «M» — це «Main», ще один СЕ, який є точкою запуску та стикування компонента. Нижче наведено схему MMVCE. ліворуч|міні|Загальна схема компонента У цілому, СЕ схеми майже такі, як на типових схемах MVC. Але є певні зауваження. Про них йде мова далі. Коротко про головне і загально відоме: принцип роботи будь-чого у всесвіті взагалі та в програмуванні зокрема, у загальному, зводиться до трьох кроків. 1-й крок — сприймання даних (отримання даних, у програмуванні це передавання даних на опрацювання до певного алгоритму). 2-й крок — опрацювання даних (певні обчислювальні процеси у залежності від поставленої задачі, власне, пропускання цих даних через деякий алгоритм). 3-й крок — зворотна реакція (повернення результату опрацювання даних). Таким чином на схемі жовті стрілки — це (механізми, потоки, процеси) передавання даних. Сині стрілки — це (механізми, потоки, процеси) отримання результату. Блоки на схемі — це СЕ, що позначають відповідний функціонал з реалізацією певних алгоритмів опрацювання даних. Тут СЕ «модель», «вигляд», та «контролер» мають приблизно той самий зміст, що і у концепції MVC. Кожен СЕ реалізується у вигляді окремого класу. Коротко про суть кожного СЕ в схемі MMVCE. Модель (Model). Містить дані, закриті для безпосереднього доступу користувача та функції опрацювання цих даних. Структура таких даних залежить від призначення компонента. Наприклад, для компонента \"Меню\" СЕ \"Модель\" може містити структуру, що моделює дерево меню та функції опрацювання вузлів такого дерева. Контролер (Controller). Ні, він нічим не керує, як про це вказують у парадигмі MVC, це лише місток, що пов'язує СЕ моделі, вигляду та подій. Ще одне важливе значення контролера — це точка підключення інших компонентів (нижче буде наведена відповідна схема та деякі приклади). Вигляд (View). СЕ з функціоналом, що відповідає за інтерпретацію та відображення даних. Події (Event). СЕ у якому описані усі події, що можуть відбуватися над компонентом. BEC (bus for external connection — шина для зовнішнього підключення). Це лише позначення можливості використовувати одні компоненти, як елементи у інших компонентах (така собі агрегація). На схемі СЕ прямокутники Main та View зображені, відповідно, червоним та зеленим кольором і з певним виходом за межі прямокутника, який позначає компонент. Це зроблено для того, щоб підкреслити, що такі СЕ застосовуються для безпосереднього використання користувачем-програмістом (Main) та користувачем вашого програмного засобу (View). Main — це «точка» створення/запуску компонента (такий собі ключ запалювання). View — це «площина» взаємодії користувача програмного засобу з компонентом (така собі консоль). Прямокутники СЕ Controller, Model, Event та BEC позначені сірим кольором, що демонструє обмежений доступ до цих елементів для користувача-програміста та закритий доступ для користувачів програмного засобу. Загальна структура проєкту у концепції каркасно-компонентного програмування Кожен завершений додаток (програма), готовий до кінцевого використання сторонніми користувачами — це компонент. Деякі компоненти можуть містити у своїй структурі інші компоненти (асоціаційні компоненти). Отже кожен завершений додаток — це ієрархічна структура, що складається з компонентів. Існують компоненти, що не містять у своїй структурі інших компонентів (базові компоненти). Компоненти поєднуються у певну ієрархію через точку виходу на СЕ Main та точку входу на СЕ Controller. Інші способи поєднання компонентів теоретично можливі, але вважаються недоцільними, оскільки це порушує загальну структуру побудови проєкту і, таким чином, його подальше, у разі потреби, масштабування та редагування. Усі компоненти мають строго визначену структуру, каркас компонента формується за єдиним алгоритмом. Усе вище описане демонструється на наступній схемі: ліворуч|міні|Загальна схема mmvce-проєкту На схемі у крайньому лівому положенні розташовано блок, що позначає проєкт (Main Prj), праворуч від нього показано розгортання усіх компонентів, які входять до його складу. Так, наприклад, компоненти 'C 01' , 'C 02' та 'C 04' - базові компоненти. Компонент 'C 03' - асоціаційний. Проєкт 'Main Prj' , фактично, є асоціаційним компонентом, який включає в себе компоненти 'C 03' та 'C 04' . Загальний опис реалізації парадигми MMVCE мовою JavaScript thumb|праворуч|міні|Загальна структура компоненту \"Меню\" На малюнку зображено структуру файлів та каталогів компонента \"Menu\". Файл \"Menu.css\" містить опис css-стилів для відображення компонента. Якщо компонент не візуальний - вміст цього файлу залишається порожнім. Якщо передбачається, що компонент міститиме додаткові ресурси, притаманні лише йому, то допускається у каталозі \"css\" або у кореневому каталозі компонента створення вкладених каталогів, наприклад, \"fonts\", \"images\", \"sounds\", інше. Спільні ресурси доцільно розміщувати у каталогах проєкту чи каталогах асоціаційних компонентів. Кожен *.js файл містить опис відповідного класу та отримує назву відповідно до шаблону C[NameComponent][NameFile]. Так, наприклад, якщо компонент має назву Menu, то клас у файлі controller.js матиме назву CMenuController. Кожен клас компонента допускає успадкування від відповідного базового класу. Так, наприклад, похідний клас CMenuView може бути успадкованим від базового класу CView. Таким чином для опису компонента можна використати п'ять базових класів CMain, CModel, CView, CController, CEvent, які у свою чергу можуть бути успадковані від базового класу CObject. Подібна ієрархія класів використовується, зокрема, такими мовами програмування, як Object Pascal, MFC C++, NET Framework, Java, інше. Файл «test.php» слугує для тестування можливостей використання компонента. Які саме коди мають бути створені у відповідних класах, у цілому, питання творче і має бути вирішене програмістом чи групою програмістів у залежності від поставлених завдань. Нижче будуть наведені деякі зразки подібних кодів, які є лише зразками, але вони, можливо, спонукають читачів даної статті до покращення розуміння К3П та розробки власних підходів в організації кодів, як невеликих так і масштабних проєктів. Про можливості використання сторонніх бібліотек та фреймворків Одне із основних завдань К3П - створення \"чистого коду на чистій архітектурі\" (див. \" Роберт Мартін. \"Чистий код\"). У свою чергу один із постулатів створення \"чистого коду\" - обережне використання сторонніх бібліотек та фреймфорків. Сторонні інструменти не повинні визначати та керувати логікою проєкту, їх задача спростити розробку, а не підпорядкувати її. Саме з цієї причини, у ідеальному варіанті, класи з описами компонентів мають містити лише коди, створені розробником цього компоненту, усі сторонні бібліотеки мають бути винесені у п'ять вищезазначені базові класи. Приклад компонента Menu мовою JavaScript Нижче наведений лістинг кодів тестування компонента Menu (файл test.php). <?php $p = \"?p=\".time(); $path_to_js = \"../../js/\"; $path_to_base_class = \"../../js/bc/\"; $use_jquery = true; extract($_GET); ?> <!DOCTYPE html> <html> <head> <title>Testing the \"Menu\" component</title> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <link rel='stylesheet' type='text/css' href='css/Menu.css<?php echo $p; ?>'> </head> <body> <div id=\"container\"></div> <?php if ($use_jquery){ ?> <script src=\"<?php echo $path_to_js; ?>jquery/jquery.js\"></script> <?php }?> <script src=\"<?php echo $path_to_base_class; ?>object.js<?php echo $p; ?>\"></script> <script src=\"<?php echo $path_to_base_class; ?>controller.js<?php echo $p; ?>\"></script> <script src=\"<?php echo $path_to_base_class; ?>model.js<?php echo $p; ?>\"></script> <script src=\"<?php echo $path_to_base_class; ?>view.js<?php echo $p; ?>\"></script> <script src=\"<?php echo $path_to_base_class; ?>event.js<?php echo $p; ?>\"></script> <script src=\"<?php echo $path_to_base_class; ?>main.js<?php echo $p; ?>\"></script> <script src=\"js/controller.js<?php echo $p; ?>\"></script> <script src=\"js/model.js<?php echo $p; ?>\"></script> <script src=\"js/view.js<?php echo $p; ?>\"></script> <script src=\"js/event.js<?php echo $p; ?>\"></script> <script src=\"js/main.js<?php echo $p; ?>\"></script> <script> let data = { \"Main\" : { title : \"Головна\" }, \"News\" : { title : \"Новини\", submenu : { \"Culture\" : { title : \"Культура\" }, \"Science\" : { title : \"Наука\", submenu : { \"Math\" : { title : \"Математика\" }, \"Physics\" : { title : \"Фізика\", submenu : { \"Mechanics\" : { title : \"Механіка\" }, \"Molecular\" : { title : \"Молекулярна фізика\" }, \"Electrodynamics\" : { title : \"Електродинаміка\" }, \"Optics\" : { title : \"Оптика\" }, \"Quantum\" : { title : \"Квантова фізика\" } } }, \"Inforamatica\" : { title : \"Інформатика\" } } }, \"Art\" : { title : \"Мистецтво\" } } }, \"Contacts\" : { title : \"Контакти\" } }; let objMenu = new CMenu({ id_container : \"container\", type : \"h\", menu: data, Click : function(id_pm){ console.log(\"User event 'Click'. Id of the clicked menu item: \", id_pm); } }); objMenu.Render(); </script> </body> </html> У цьому лістингу повністю відсутні коментарі, що відповідає одному з правил написання кодів, вже згадуваного тут Роберта Мартіна - коментарі, зайві, той, хто читає ваш код має розуміти його сутність. У іншому випадку варто переписати код так, щоб він читався без коментарів. Тут все очевидно (принаймні, автор на це щиро сподівається). У разі потреби, підключається зовнішня бібліотека (jQuery). Вказується HTML-об'єкт, як контейнер для відображення меню (шар <div id=\"container\"></div>) Додаються базові класи. Додаються класи самого компонента \"Меню\" Описується структура меню (об'єкт data) Створюється об'єкт \"Меню\" (об'єкт objMenu) Об'єкт \"Меню\" відображається у потрібному контейнері (шар з айді \"container\") Зазначу про деякі особливості використання компонента \"Меню\" зокрема та будь-яких компонентів в цілому. Структура меню (як і певні дані будь-якого компонента) може бути, у залежності від поставлених завдань, статично прописана в моделі компонента (файл model.js) або винесена в окремий файл, або завантажуватися із зовнішніх ресурсів (бази даних, тощо). Компонент не відображається у контейнері автоматично. Для цього використовується функція \"Render\". Це зроблено з метою більш гнучкого використання асоціаційних компонентів. Так, наприклад, об'єкти компонентів можуть бути створені заздалегідь, але їх відображення здійснюватиметься за мірою необхідності. За цим посиланням можна ознайомитися з текстами кодів, що демонструють можливості використання концепції каркасно-компонентного програмування. Звичайно, ці коди не претендують на \"повноту\", \"глибину\" та \"довершеність\". Це лише приклади для унаочнення вищезазначених міркувань. Але у подальшому планується доповнити ці приклади іншими частозатребуваними компонентами (\"Навігатор\", \"Таймер\", \"Календар\" і т. д. ), які мають більш розширений функціонал, ніж той, що пропонується поширеними бібліотеками та, що не менш важливо, з можливістю власного швидкого та ефективного доопрацювання їх функціоналу відповідно до поставлених завдань. Категорія:Інформаційні технології Категорія:Програмування"}
{"category": "Програмування", "title": "Користувацьке програмування", "abstract": "Термін користувацька розробка (End-User Developement — EUD) або користувацьке програмування (End-User Programming — EUP) позначають набір методик та інструментів, які дозволяють програмувати кінцевим користувачам — людям, які не є професійними розробниками ПЗ. Вони можуть використовувати такі інструменти для створення або модифікації програмних артефактів (описів автоматичних дій) і складних об'єктів даних без знання мов програмування.\nІснують різні підходи до проблеми користувацького програмування — ця тема активно досліджується в інформатиці й науці про взаємодію людини та комп'ютера. Серед прикладів можна відзначити системи програмування природною мовою, електронні таблиці, скриптові мови (особливо в офісних пакунках або застосунках для художників), візуальне програмування, програмування тригерних дій і програмування за прикладом.\nНайпопулярніший інструмент для користувацького програмування — це електронні таблиці. В силу своєї необмежувальної природи вони дозволяють недосвідченим користувачам писати програми, що реалізують складні моделі даних, разом з тим, захищаючи їх від потреби вивчати мови програмування нижчого рівня. Навички роботи з електронними таблицями відносять до найкорисніших для випускників зво через широке використання електронних таблиць для розв'язування задач у бізнесі. Станом на 2005 рік у США кількість користувачів, що використовують електронні таблиці оцінювалася в 13 млн осіб.\nВикористання програмування за прикладом знижує необхідність вивчення користувачем абстракцій класичних мов програмування. Замість цього користувач вказує приклади бажаних результатів або операцій, які слід виконати над даними, а система програмування за прикладом сама виводить з цього абстракції, відповідні програмі, що генерує потрібні вихідні дані. В автоматично створену таким способом програму можна вводити нові дані, а користувач, для корекції програми, може виправляти помилки на виході. Платформи розробки з мінімумом коду також є варіантом засобів користувацького програмування.\nОдним із напрямків розвитку в цій галузі є використання мобільних пристроїв для підтримки користувацької розробки ПЗ. Специфіка мобільних пристроїв не дозволяє застосовувати ті ж самі підходи, які працювали для настільних застосунків. Настільні середовища користувацької розробки позбавлені переваг, які дозволяють кінцевим користувачам створювати застосунки «на ходу».\nОстаннім часом також зріс інтерес до використання цієї техніки для розробки застосунків інтернету речей. У цій галузі перспективним підходом вважають програмування тригерних дій.\nРішення користувацької розробки можуть істотно вплинути на такі сфери, як життєвий цикл програмного забезпечення для комерційних програмних продуктів, домашні розробки через мережу і розгортання корпоративних застосунків.", "content": "Термін користувацька розробка (End-User Developement — EUD) або користувацьке програмування (End-User Programming — EUP) позначають набір методик та інструментів, які дозволяють програмувати кінцевим користувачам — людям, які не є професійними розробниками ПЗ. Вони можуть використовувати такі інструменти для створення або модифікації програмних артефактів (описів автоматичних дій) і складних об'єктів даних без знання мов програмування. Існують різні підходи до проблеми користувацького програмування — ця тема активно досліджується в інформатиці й науці про взаємодію людини та комп'ютера. Серед прикладів можна відзначити системи Емі Брюкман і Елізабет Едардс (Bruckman, Amy, and Elizabeth Edwards). «Поощрять ли естественные языки? Анализ ошибок в языках программирования основанных на естественном языке (Should we leverage natural-language knowledge? An analysis of user errors in a natural-language-style programming language) » / Матеріали конференції з людського фактору в обчислювальних системах. ACM, 1999. APA, електронні таблиці в «Енциклопедії взаємодії людини й комп'ютера»., скриптові мови (особливо в офісних пакунках або застосунках для художників), візуальне програмування, програмування тригерних дій і . Найпопулярніший інструмент для користувацького програмування — це електронні таблиці. В силу своєї необмежувальної природи вони дозволяють недосвідченим користувачам писати програми, що реалізують складні моделі даних, разом з тим, захищаючи їх від потреби вивчати мови програмування нижчого рівня. Навички роботи з електронними таблицями відносять до найкорисніших для випускників зво через широке використання електронних таблиць для розв'язування задач у бізнесіС. Крюк і С. Шитц (Kruck, S. & Sheetz, S.), 2001. Теорія точності в електронних таблицях (Spreadsheet accuracy theory) . Журнал з педагогіки в інформаційних системах (Journal of Information Systems Education).. Станом на 2005 рік у США кількість користувачів, що використовують електронні таблиці оцінювалася в 13 млн осібК. Скаффіді, М. Шоу і Б. Маєрс (Scaffidi, C., Shaw, M. & Myers, B.), 2005. Оцінка кількості кінцевих користувачів та користувачів-програмістів (Estimating the Numbers of End Users and End User Programmers) . 2005 Симпозіум IEEE і візуальних мов і орієнтованих на користувача обчислювальних систем (IEEE Symposium on Visual Languages and Human-Centric Computing) (VL/HCC'05), стр.207–214.. Використання знижує необхідність вивчення користувачем абстракцій класичних мов програмування. Замість цього користувач вказує приклади бажаних результатів або операцій, які слід виконати над даними, а система програмування за прикладом сама виводить з цього абстракції, відповідні програмі, що генерує потрібні вихідні дані. В автоматично створену таким способом програму можна вводити нові дані, а користувач, для корекції програми, може виправляти помилки на виході. також є варіантом засобів користувацького програмування. Одним із напрямків розвитку в цій галузі є використання мобільних пристроїв для підтримки користувацької розробки ПЗ. Специфіка мобільних пристроїв не дозволяє застосовувати ті ж самі підходи, які працювали для настільних застосунків. Настільні середовища користувацької розробки позбавлені переваг, які дозволяють кінцевим користувачам створювати застосунки «на ходу». Останнім часом також зріс інтерес до використання цієї техніки для розробки застосунків інтернету речей. У цій галузі перспективним підходом вважають програмування тригерних дійГ. Джиані, М. Манка, Ф. Патерно, С. Санторо (Ghiani, G., Manca, M., Paternò, F., Santoro, C.): Персоналізація програм, що залежать від контексту, за допомогою тригерних дій (Personalization of Context-dependent Applications through Trigger-Action Rules). ACM Transactions on Computer-Human Interaction, том.24, Выпуск 2, Статья N.14, Апрель 2017.. Рішення користувацької розробки можуть істотно вплинути на такі сфери, як життєвий цикл програмного забезпечення для комерційних програмних продуктів, домашні розробки через мережу і розгортання корпоративних застосунків. Платформи для розробки з мінімумом коду Нині існує приблизно 40 виробників, які пропонують кінцевим користувачам рішення для скорочення зусиль із програмування. Створення програм у них не вимагає знань традиційного програмування, проте вони призначені для створення досить спеціалізованих систем, таких як системи керування контрактами, системи керування відносинами з клієнтами, системи відстеження багів і помилок. Подібні системи розробки часто називають . Як правило така платформа являє собою інтерактивний гід, що дозволяє користувачу розробити застосунок всього за 40—80 годин (1,7—3,3 доби). Визначення Ліберман та інші пропонують таке визначення:Lieberman, H., Paternò, F., Klann, M., and Wulf, V. (2006). Користувацька розробка: нова парадигма. П: Користувацька розробка ПЗ, Lieberman, H., Paternò, F., and Wulf, V. (eds.), Springer Нідерланди, 2006, сер. Взаємодія людини та комп'ютера, том 9, Глава 1, стр. 1-7, Користувацьку розробку можна визначити як набір методів, технік та інструментів, що дозволяють користувачам ПЗ, які не є професійними розробниками ПЗ, якоюсь мірою створювати, модифікувати або розширювати програмні артефакти.Ко та інші пропонують таке визначення:Користувацьке програмування — це програмування для досягнення результату програми перш за все для особистого, а не для громадського користування.Програмні артефакти, створені кінцевими користувачами, можуть являти собою описи автоматизованої поведінки або керувальні послідовності, такі як запити до бази даних або правила граматикиH. Lieberman, B. A. Nardi, and D. Wright. Grammex: Визначення граматик за прикладом(Grammex: Defining grammars by example). Конференція ACM з людського фактора в комп'ютерних системах (Зведення та демонстрації) (CHI ’98), Лос-Анджелес, Каліфорнія, США, стр. 11–12. ACM Press, квітень 1998. (ACM conference on Human Factors in Computing Systems) , які можуть створюватися за допомогою таких парадигм програмування як , , візуальне програмування або створення макрокомандMaria Francesca Costabile, Daniela Fogli, Piero Mussio, Antonio Piccinno. Користувацьке програмування: підхід до розробки за допомогою інструментарію формування ПЗ (End-user development: the software shaping workshop approach) . In Lieberman, H., Paternò, F., Wulf, V. (Eds) (2004) Користувацьке програмування — Надання людям можливості гнучко використовувати передові інформаційні та комунікаційні технології (End User Development — Empowering People to Flexibly Employ Advanced Information and Communication Technology), © 2004 Kluwer Academic Publishers, Dordrecht, The Netherlands.. Вони (артефакти) також можуть являти собою набір параметрів, що вказують на один із зумовлених способів дії програмиCostabile, M.F., Fogli, D., Letondal, C., Mussio, P., Piccinno, A., Користувачі — експерти в предметній галузі та їх потреби в розробці ПЗ (Domain-Expert Users and their Needs of Software Development) \", Конференція UAHCI, Крит, 22–27 червня, 2003, 232—236.. Інші артефакти, створені кінцевим користувачем, є формами користувацького контенту, наприклад анотації, які можуть бути або не бути програмно інтерпретованими (т. е. можуть бути оброблені відповідними автоматизованими функціями).Gerhard Fischer Користувацька розробка та мета-дизайн: основи для культури участі (End-User Development and Meta-Design: Foundations for Cultures of Participation) . Лекційні записи з користувацького програмування в інформатиці, 2009, том 5435/2009, 3-14, Приклади Серед прикладів призначених для користувацьких розробок можна виділити такі: Анімаційні скрипти, які використовують художники-мультиплікатори для опису руху персонажів або змін навколишнього середовища в системах комп'ютерної анімації. Конфігураційні файли, які розмивають межу між програмами і даними (наприклад фільтри електронної пошти є наборами умов і дій, які має виконати програма). Інструменти для Модифікації ігор, призначені для створення користувацьких персонажів, оточення тощо — багато сучасних ігор надають такі можливості. Інтерактивні автоматичні скрипти, використовувані в кол-центрах. Інструменти розробки мобільних застосунків, такі як App Inventor. Моделі процесів, що використовуються в . і предметно-орієнтовані програми, написані бізнесменами, інженерами та вченими для демонстрації або перевірки конкретних теорій. Програми роботів. Наукові моделі, використовувані в комп'ютерному моделюванні. Скрипти та макрокоманди, використовувані для розширення можливостей офісних пакунків і графічних застосунків. Симуляції, створені застосунками для опису програм. даних з використанням заданої користувачем пакетної обробки або ж , такої як у текстових редакторах або multi-edit . Моделі даних в електронних таблицях, використовувані для фінансових розрахунків, аналізу ризиків, інтерактивного машинного навчання і проєктування електронна схема Візуальне програмування у вигляді візуальних мов, таких як , LabVIEW, Скретч або Mindstorms (серія LEGO). Вебсторінки — HTML і скрипти. Вікі — результат спільної розробки кінцевими користувачами. Вебмешапи (вебсуміші) — як форма візуальних мов програмування. 3D-моделі, створені за допомогою призначеного для кінцевих користувачів ПЗ, такого як Sketchup. Моделювання витрат і вигод На думку , користувацьке програмування є, по суті, аутсорсингом розробки кінцевому користувачу. Для вивчення інструментів користувацької розробки завжди потрібні деякі зусилля, тому мотивація користувачів залежить від їх упевненості в тому, що це допоможе полегшити роботу, заощадити час або підвищать продуктивність. У цій моделі переваги для користувачів засновані на маркетингу, демонстраціях і «маркетингу із уст в уста». Як тільки технологія починає активно використовуватися, ключовим мотиватором стає реальний досвід і вигоди. Згадане вище дослідження визначає витрати як суму таких: технічні витрати: ціна технології і зусилля з її встановлення; вартість навчання: час, необхідний для розуміння технології; витрати на розробку: зусилля з розробки застосунків з використанням цієї технології; вартість тестування та налагодження: час, витрачений на перевірку системи. Витрати з першого і другого пункту є одноразовими, а витрати з третього і четвертого виникають щоразу під час розробки. Вигоди (реальні або відчутні) в цьому разі такі: функціональність, забезпечувана технологією; можливість гнучко реагувати на нові вимоги; зручність використання створюваних застосунків; загальна якість створюваних застосунків. Співпраця під час користувацької розробки Більшість діяльності з користувацької розробки за своєю природою вимагає співпраці або серед самих користувачів-розробників, або між ними і розробниками-фахівцями. Взаємна розробка — це методика, за якої розробники-фахівці й користувачі спільно намагаються створити програмний продукт. Професійні розробники як правило створюють основу системи і надають інструменти, якими, за необхідності, «власники завдань» можуть користуватися для створення відповідних рішень, які враховують цілі та контексти конкретного завдання. Внаслідок комунікації між розробниками-фахівцями й розробниками-користувачами специфічні модифікації останніх можуть перетворитися на програмні артефакти і стати повноцінним комерційним функціоналом, який глобально впливає на продукт. Для подолання комунікаційного розриву між розробниками-фахівцями й розробниками-користувачами пропонуються різні підходи, наприклад семінари з формування ПЗ. Ці підходи намагаються забезпечити прозорість (за моделлю соціальної прозорості), щоб кожен учасник процесу був інформованим про зміни, внесені іншими учасниками, і міг нести відповідальність за свої дії в силу цієї обізнаності. У той час, як професійні розробники використовують для спільної роботи спеціалізовані платформи (такі як GitHub), розробники-користувачі воліють використовувати вікі-системи, де діляться між собою створеними програмними артефактами. Користувацьку розробку також часто застосовують для створення скриптів автоматизації або інтерактивних посібників для обміну практичними знаннями. Прикладами є програми CoScripter і HILC. У таких застосунках користувач може створювати скрипти за допомогою напівприродної мови або ж програмуючи демонстрацією. При цьому користувачі можуть поділитися створеним скриптом, завантаживши його в спеціальне онлайн-сховище, організоване в стилі вікі. На цій вікісторінці користувачі можуть не тільки шукати доступні скрипти, але й покращувати їх, додаючи параметри, щоб пристосувати їх до інших умов або до роботи з іншими об'єктами. Крім того, існують онлайн і офлайн-спільноти розробників-користувачів, де вони можуть на взаємовигідній основі спільно вирішувати завдання розробки. У таких спільнотах місцеві експерти поширюють свої знання і дають поради. Члени спільноти часто соціально підтримують один одного, що допомагає суспільній розробці програмного забезпечення. Критика Дослідники стурбовані тим, що кінцеві користувачі часто не розуміють, як тестувати або захищати свої програми. Воррен Гаррісон, професор інформатики Портлендського університету, писав:Не вкладається в голові, що ми намагаємося очікувати якоїсь безпеки… від переважної більшості застосунків, написаних із мінімальними або ніякими знаннями про загальноприйняті хороші практики (такі як чітка постановка задачі перед написанням коду, систематичне тестування тощо)… Скільки існує книг \"X для чайників \"(де «X» — ваша улюблена мова програмування)? Спочатку мене бавила ця тенденція, але останнім часом мені стає моторошно думати про те, де ці дилетанти можуть застосовувати свої новонабуті знання.З цієї точки зору вважається, що всі кінцеві користувачі однаково погано розбираються в питаннях розробки ПЗ, але Пліскін і Шовал стверджують, що це не так, що просунуті користувачі здатні до якісної розробки. Однак, на відміну від фахівців, у програмістів-користувачів рідко є час або мотивація до систематичного і дисциплінованого освоєння майстерності розробки, що дуже ускладнює завдання забезпечення якості програмних продуктів користувачів. Реакцією на це стали систематичні дослідження користувацької розробки ПЗ. Вони стосуються питань, що виходять за рамки власне розробки, зокрема розглядається мотивація користувачів-розробників до того, щоб їхні продукти були безпечними, перевірними або повторно використовуваними. Альтернативне рішення полягає в тому, щоб кінцеві користувачі або їхні консультанти використовували декларативні інструменти, які забезпечують безпеку і суторгі бізнес-правила на шкоду продуктивності і масштабованості; як правило продукти розробників-користувацької, мають меншу ефективність, ніж створені за допомогою фахових середовищ програмування. Див. також Автоматичне програмування Програмна інженерія Посилання Література Фабіо Патерно (F. Paternò, 2013) Користувальницька розробка: огляд новітніх можливостей для всіх (End User Development: Survey of an Emerging Field for Empowering People), ISRN Software Engineering, том 2013, ID статті 532659, 11 сторінок, 2013. , 2013 Б. Гуо, Д. Жанг, М. Імай (B. Guo, D. Zhang, M. Imai). Орієнтоване на користувача управлінь для повсюдних обчислень: підхід заснований на мета-проектуванні (Enabling User-Oriented Management for Ubiquitous Computing: The Meta-Design Approach), Computer Networks, Elsevier, том. 54, нр. 16, 2010. Маргарет М. Бюрнетт і Крістофер Скаффіді (Burnett, Margaret M. and Scaffidi, Christopher, 2011): Користувальницька розробка . В: Soegaard, Mads and Dam, Rikke Friis (eds.). «Енциклопедія взаємодії людини і комп'ютера». Патрік Кіркегаард (Patrick Kierkegaard, 2011) Посилання Другий міжнародний симпозіум з користувацької розробки Консорціум EUSES, колективні дослідження користувацьких розробок Користувацька розробка (The End User Development book) Мережа Комісії ЄС із досягнення досконалості в користувацькій розробці (the European Commission Network of Excellence on End-User Development) Серія конференцій Міжнародного симпозіуму з користувацької розробки Категорія:Людино-машинний інтерфейс Категорія:Проєктування програмного забезпечення Категорія:Інформатика Категорія:Програмування"}
{"category": "Програмування", "title": "Креативне програмування", "abstract": "Креативне кодування — це тип комп'ютерного програмування, метою якого є створення чогось експресивного замість чогось функціонального. Застосовується для створення візуалізацій вживу, віджеїнгу, а також до візуальному мистецтва, дизайну, розваг (наприклад відео-ігор), арт-інсталяцій, проекцій та накладання проекцій, звукового мистецтва, реклами, прототипів продуктів та багато іншого.", "content": "thumb|upright|Модифікована версія класичної відеоігри 1980-х Breakout Креативне кодування — це тип комп'ютерного програмування, метою якого є створення чогось експресивного замість чогось функціонального. Застосовується для створення візуалізацій вживу, у, а також до візуальному мистецтва, дизайну, розваг (наприклад відео-ігор), арт-інсталяцій, проекцій та , звукового мистецтва, реклами, прототипів продуктів та багато іншого. Історія Практика використання програмування для створення мистецтва розпочалася в 1960-х. У наступні десятиліття групи, такі як Compos 68, успішно відкрили програмування для мистецьких цілей, виставляючи свої роботи на міжнародних виставках. Починаючи з 80-х років, експерти-програмісти приєднувались до демосцени і текстували свої навички один проти одного, створюючи «демо»: високотехнологічні візуальні твори. Нещодавні виставки та книги, в тому числі книга Домініка Лопеса «Філософія комп'ютерного мистецтва» (2009), намагалися вивчити роль кодування в сучасному мистецтві понад рівнем Human Computer Interface(HCI).. Список програмного забезпечення для творчого кодування Хоча будь-яка технологія чи мова програмування потенційно можуть бути використані для творчих цілей, певні бібліотеки та фреймворки були спеціально розроблені для сприяння швидкого програмування та розвитку творчих робіт. Набори програмних засобів, які часто використовуються в цьому контексті, включають: НазваОписОпераційна системаМова програмуванняЛіцензіяCinderБібліотека для програмування з естетичними нахилами, включаючи такі домени, як графіка, аудіо, відео та обчислювальна геометрія.БагатоплатформністьC++2-Clause BSD LicensegenerativepyБібліотека для створення візуального генеративного мистецтва та математичних діаграм, як зображення та відео.БагатоплатформністьPythonMIT LicenseMax MSPМова візуального програмування для музикантів та мультимедіа.Windows, Mac OSМова візуального програмуванняProprietaryNannou Бібліотека, яка має мету полегшення художникам самовираження за допомогою простого, швидкого і надійного коду.БагатоплатформністьRustMIT LicenseopenFrameworksНабір інструментів, який призначений для сприяння творчому процесу, надаючи просту та інтуїтивно зрозумілу основу для експериментування.БагатоплатформністьC++MIT LicenseOPENRNDR Творча система кодування, розроблена для створення прототипів надійних візуальних та інтерактивних програм.БагатоплатформністьKotlin2-Clause BSD Licensep5.jsПлатформа, яка дає можливість художникам, дизайнерам, студентам та будь-кому з користувачів навчитися кодувати та творчо виражатися в Інтернеті. Заснований на основних принципах Processing.Any with a web browserJavaScriptLGPLProcessingГнучке програмне середовище та мова програмування для вивчення кодування в контексті візуального мистецтва.БагатоплатформністьJava,Python,RGPL, LGPLPure DataPd дає можливість музикантам, художникам, виконавцям, дослідникам та розробникам створювати програмне забезпечення графічно, не пишучи рядків коду.БагатоплатформністьМова візуального програмуванняModified BSDSuperColliderСередовище мова програмування для обчислень в режимі реального часу аудіосинтезу та алгоритмічної композиції.БагатоплатформністьSuperColliderGPLv3VvvvГібридне візуальне/текстове середовище програмування в реальному часі для зручного створення прототипів та розробки. Воно призначене для полегшення роботи з великими медіа середовищами з фізичними інтерфейсами, графікою руху в реальному часі, аудіо та відео.WindowsМова візуального програмуванняProprietaryZIMJavaScript Canvas Framework має багато компонентів і елементів для кодування з наголосом на спрощення коду.БагатоплатформністьJavaScriptMIT Розширення Творче кодування іноді включає апаратні компоненти для введення даних із навколишнього середовища, отримання результатів або взаємодії з учасниками. Приклади часто використовуваного обладнання включають мікрофони, вебкамери, контролери руху, одноплатні мікроконтролери, MIDI-контролери, проєктори, світлодіодні стрічки, принтери та плотери. Див.також Комп'ютерне мистецтво Демосцена Мистецтво з кодуванням, проєкт Dev Art (Google) Посилання An introduction to Shader Art Coding Зноски Категорія:Програмування Категорія:Методики творчості"}
{"category": "Програмування", "title": "Креш", "abstract": "Креш (англ. crash) або відмова системи (також аварійна відмова, фатальний збій, аварія, розм. крах, падіння) — серйозний баг, помилка у програмі, що викликає аварійне завершення програми або операційної системи, коли вона перестає функціонувати належним чином.\nЧасто помилка такого роду призводить до виходу з ураженої програми. Програма може не відповідати, доки служба звітності аварії не повідомить подробиці відмови. Якщо програма є критичною частиною операційної системи, вся система може аварійно завершити роботу або зависнути, що часто призводить до поломки ядра або фатальної системної помилки.\nБільшість відмов з'являється внаслідок виконання недопустимих машинних інструкцій. Наприклад, коли певний об'єкт був видалений (або переміщений), а значення вказівника не було змінено на нульове, тому він все ще вказує на область пам'яті, де знаходився цей об'єкт і може мати до нього доступ; або в результаті переповнення буфера перезаписуються інші дані що знаходяться поруч з буфером, які може бути пошкоджено а інтерпретація інформації як виконуючого коду порушена. Подібні помилки призводять до порушення безпеки доступу до пам'яті, та виконання обробки винятків.\nПочаткова помилка програмного забезпечення, що викликала події, що привели до відмови системи, вважається причиною збою та виявляється в процесі налагодження програми. Загалом, знайти початкову помилку буває досить важко, вона може здаватися нічим не пов'язаною зі збоєм, впливаючи на місце крашу не безпосередньо а через серію взаємопов'язаних подій.", "content": "альт=Відмова системи у iMac|міні|231x231пкс|Відмова системи у iMacthumb|Відмова системи у Windows, так званий синій екран смерті Креш () або відмова системи (також аварійна відмова, фатальний збій, аварія, розм. крах, падіння) — серйозний баг, помилка у програмі, що викликає аварійне завершення програми або операційної системи, коли вона перестає функціонувати належним чином. Часто помилка такого роду призводить до виходу з ураженої програми. Програма може не відповідати, доки служба звітності аварії не повідомить подробиці відмови. Якщо програма є критичною частиною операційної системи, вся система може аварійно завершити роботу або зависнути, що часто призводить до поломки ядра або фатальної системної помилки. Більшість відмов з'являється внаслідок виконання недопустимих машинних інструкцій. Наприклад, коли певний об'єкт був видалений (або переміщений), а значення вказівника не було змінено на нульове, тому він все ще вказує на область пам'яті, де знаходився цей об'єкт і може мати до нього доступ; або в результаті переповнення буфера перезаписуються інші дані що знаходяться поруч з буфером, які може бути пошкоджено а інтерпретація інформації як виконуючого коду порушена. Подібні помилки призводять до порушення безпеки доступу до пам'яті, та виконання обробки винятків. Початкова помилка програмного забезпечення, що викликала події, що привели до відмови системи, вважається причиною збою та виявляється в процесі налагодження програми. Загалом, знайти початкову помилку буває досить важко, вона може здаватися нічим не пов'язаною зі збоєм, впливаючи на місце крашу не безпосередньо а через серію взаємопов'язаних подій. Відмова програми thumb|270px|Крах програми в аеропорті у результаті помилки сегментації Програмний додаток зазвичай завершує свою роботу у випадку виконання операції, що не дозволена операційною системою. Тому після такої спроби система запускає в додатку обробку винятків або сигнал. Unix додатки традиційно відповідають на сигнал за допомогою . Більшість Windows та Unix додатків з графічним інтерфейсом користувача відповідають відображаючи діалогове вікно з можливістю підключення налагоджувача, якщо він встановлений. Деякі додатки намагаються відновитись після помилки та продовжити роботу замість повного завершення. Типові помилки, що призводять до збою в додатках, містять: спробу зчитувати або записувати в пам'ять, що не призначена для читання або запису цим додатком (помилка сегментації або помилка захисту); спробу виконати привілегійовані або недієві команди; спробу виконати операції вводу-виводу на пристроях, до яких у нього немає дозволу на доступ; передачу недопустимих аргументів системним викликам; спробу отримати доступ до інших системних ресурсів, до яких у додатка немає дозволу на доступ; спробу виконати машинні команди з «поганими» аргументами (в залежності від процесорної архітектури): ділення на нуль, операції зі значеннями денормалізованих чисел або NaN, доступ до пам'яті в неприєднаних адресах і т. ін. Відмова Web-сервера Додаток, запущений у вебсервері, може відмовити, що викличе повну недієздатність сайту або роботу в режимі сповіщення повідомлення про помилку. Наприклад, якщо сайт, що використовує базу даних SQL (наприклад MySQL) використає скрипт (наприклад на PHP), і цей сервер бази даних відмовить, то PHP видасть повідомлення про помилку підключення. Наслідки аварій в безпеці даних Багато програмних помилок, що спричинюють відмову системи, також використовуються як експлойти для виконання довільного коду та інших видів підвищення привілеїв. Наприклад, переповнення стекового буфера може перезаписати адресу повернення підпрограми з недійсним значенням, що призводить до помилки сегментації, коли підпрограма поверне значення. Однак, якщо експлойт перезаписує адресу повернення дійсним значенням, то код у цій адресі буде виконано. Див. також Безпека доступу до пам'яті Помилка сегментації Переповнення буфера Витік пам'яті Захист пам'яті Синій екран смерті Примітки Література Посилання Analyze Crashes to Find Security Vulnerabilities in Your Apps Crash Computing | www.infopackets.com Computer Crash Picking Up The Pieces After A Computer Crash Why do computers crash? — Scientific American PCGuide — TSX — Troubleshooting System Instablity, Reboots and Crashes Категорія:Програмування Категорія:Якість програмного забезпечення Категорія:Помилки програмування Категорія:Сленг програмістів Категорія:Комп'ютерні помилки"}
{"category": "Програмування", "title": "Купа (пам'ять)", "abstract": "Купа (англ. heap) в інформатиці та програмуванні — назва структури даних, за допомогою якої реалізовано динамічно розподілювану пам'ять програми.\nРозмір купи — розмір пам'яті, виділеної операційною системою (ОС) для зберігання купи (під купу).", "content": "Купа () в інформатиці та програмуванні — назва структури даних, за допомогою якої реалізовано динамічно розподілювану пам'ять програми. Розмір купи — розмір пам'яті, виділеної операційною системою (ОС) для зберігання купи (під купу). Принцип роботи При запуску процесу ОС виділяє пам'ять для розміщення купи. Надалі пам'ять для купи (під купу) може виділятися динамічно. Програма користувача, використовуючи функції, подібні може отримувати покажчики на області пам'яті, що належать купі. Програми використовують купу для розміщення динамічно створюваних структур даних. Програма може звільнити пам'ять з допомогою функцій, подібних . Пам'ять купи можна розділити на зайняту (виділену програмі за допомогою функцій, подібних ) і вільну (зайняту або вже звільнену з допомогою функцій, подібних ). Для зберігання даних про те, яка ділянка купи є зайнятою, а яка — вільною, зазвичай використовується додаткова область пам'яті. Перед початком роботи програми виконується ініціалізація купи, в ході якої пам'ять, виділена під купу, позначається як вільна. Функція, подібна виконує приблизно такі дії: переглядає список зайнятих/вільних областей пам'яті, розміщених в купі, в пошуках вільної області відповідного розміру; у разі нестачі вільної пам'яті може запитати додаткову пам'ять у ОС; додає знайдену область в список зайнятих областей (або позначає область як зайняту); повертає покажчик на початок області пам'яті; якщо з тих чи інших причин виділити пам'ять не вдалося, повідомляє про помилку (наприклад, повертає ). Функція, подібна виконує приблизно такі дії: переглядає список зайнятих/вільних областей пам'яті, розміщених в купі, в пошуках зазначеної області; видаляє зі списку зайнятих областей пам'яті знайдену область додає знайдену область в список вільних областей (або позначає область як вільну). Програма може бути впевнена в тому, що між викликами функцій, подібних і область пам'яті, позначена як зайнята, не буде виділена повторно. Після виклику функції, подібної область пам'яті буде звільнена і надалі може використовуватися повторно або може бути віддана ОС. Використання вказівника на звільнену область пам'яті буде приводити до збоїв або непередбачуваної роботи програми. Алгоритми і продуктивність Купа являє собою безперервну область пам'яті, поділену на зайняті і вільні області (блоки) різного розміру. Інформація про вільні і зайняті області купи може зберігатися в списках різних форматів. Від обраного формату списку безпосередньо залежить продуктивність функцій, подібних і , так як більшу частину часу ці функції витрачають на пошук за списком відповідних областей. Для збільшення розміру купи функція, подібна використовує системний виклик (викликає функцію ОС). При цьому відбувається перемикання контексту з простору користувача в простір ядра ОС і назад. Пошук за списком зайнятих/вільних областей купи виконується швидше, ніж перемикання контекстів, тому вигідніше один раз використовувати системний виклик для виділення великої області пам'яті під купу, а надалі виділяти програмі області меншого розміру з наявної великої області з веденням списку зайнятих/вільних областей. Кількість елементів, що входять в список зайнятих/вільних областей купи, може бути зменшено шляхом злиття елементів, що містять інформацію про наступні одну за іншою областях. Це дозволить зменшити час обходу списку. Кожен елемент списку може зберігати адресу області пам'яті, її розмір, інформацію про наступну (для пошуку в прямому напрямку) і/або попередньої (для пошуку в зворотному напрямку) області. Приклад реалізації Створення декількох списків для зберігання інформації про областях однакових або близьких розмірів. Вибір списку в залежності від розміру області. Дивись також Динамічна пам'ять NULL Функції стандартної бібліотеки мови C malloc() free() Категорія:Програмування Категорія:Структури даних Категорія:Керування пам'яттю"}
{"category": "Програмування", "title": "Лексема", "abstract": "Лексе́ма (від грец. λέξις — «слово», «мовний зворот») — слово як самостійна значеннєва одиниця, яку в мовознавстві розглядають у сукупності всіх своїх форм і значень.", "content": "Лексе́ма (від — «слово», «мовний зворот») — слово як самостійна значеннєва одиниця, яку в мовознавстві розглядають у сукупності всіх своїх форм і значень. У лінгвістиці В одну лексему поєднуються різні парадигматичні форми (словоформи) одного слова. Наприклад, словник, словником, словнику — це форми однієї і тієї ж лексеми, за згодою пишеться як СЛОВНИКСЛОВНИК тут пишеться капітелем (малими прописними). Дещо обмежене в можливостях програмне забезпечення може показувати це або повнорозмірними великими (СЛОВНИК), або великими трохи меншого кеглю; обидва варіанти вважаються прийнятною заміною для капітелі.. У ряді концепцій у лексему включаються різні сенсові варіанти слова, що залежать від контексту, в якому воно вживається (наприклад, сіль у сенсі назви речовини та у значенні того, що надає гостроти або інтересу будь-якому висловлюванню, думці). Застаріле значення лексеми — це група асоційованих слів.Пешковський О. М. Лексема // Литературная энциклопедия: Словарь литературных терминов: В 2-х т. — М.; Л.: Изд-во Л. Д. Френкель, 1925. Т. 1. А—П. — Стб. 399—402.. Зараз у цьому значенні використовують термін семантичне поле. Лексема — дуже важливе поняття морфології, тож багато інших понять можна висловити через нього. Наприклад, відмінність між правилами словозміни та словоутворення можна пояснити так: Правила словозміни пов'язують лексему з її формами. Правила словоутворення пов'язують лексему з іншими лексемами. У програмуванні Лексема — послідовність машинних символів вихідного коду програми, що мають певне сукупне значення. Класи лексем Для більшості мов програмування актуальні такі класи лексем: зарезервовані слова ідентифікатори числові константи (цілі та дійсні числа) літерні константи рядкові константи коди операторів коментарі, які безпосередньо не несуть інформації щодо структури програми; транслятором не сприймаються, синтаксичному аналізатору не передаються дужки й інші елементи програми. Див. також Токен Лексичне значення Лексичний аналіз Лексика Примітки Посилання Тараненко О. О. Лексема // — С. 293—294. Категорія:Лексичні одиниці Категорія:Програмування Категорія:Теорія компіляторів"}
{"category": "Програмування", "title": "Локалізація програмного продукту", "abstract": "Локаліза́ція програ́много проду́кту — приведення програмного продукту у відповідність із законами та іншими нормативно-правовими актами, стандартами, нормами і правилами, що діють в країні для якої проводиться локалізація.\nЛокалізація (англ. localization) — переклад і адаптація елементів інтерфейсу, допоміжних\nфайлів та документації. У англійській мові для слова «localization» іноді застосовують скорочення l10n або L10N, де число 10 означає кількість пропущених між «l» та «n» літер.\nЗавдання локалізації не вичерпується тільки перекладом, більш того, переклад як такий зазвичай займає скромне місце в процесі локалізації програмного забезпечення. Типовими завданнями адаптації є використання національних символів валюти, застосування прийнятих форматів представлення дати і часу, а також правил алфавітного сортування текстів. Для програмного забезпечення з графічним користувацьким інтерфейсом локалізація також має на увазі коректне вирівнювання і розміщення елементів інтерфейсу з урахуванням того, що повідомлення-рядки можуть мати істотно різні розміри у різних\nмовах (наприклад, типове повідомлення англійською, бувши перекладено на німецьку мову, як правило, стає довшим на 30—50%), а також з урахуванням правил написання тексту (наприклад, зліва направо для\nбільшості західних мов, справа наліво для арабської\nта івриту, зверху вниз для японської).\nТаким чином дизайн та розробка програмного забезпечення повинні враховувати міркування локалізації найсерйознішим чином.\nДеякі інструменти для візуального програмування надають можливості та інструменти для полегшення локалізації. Наприклад, у GTK+ найчастіше немає необхідності спеціально піклуватися про різну довжину рядків в різних мовах, оскільки віджети автоматично запрошують необхідний для себе розмір.\nПроте здебільшого ці можливості значно обмежені, що сильно відбивається на підсумковій вартості локалізації. У цих інструментах немає засобів для роботи з перекладачем, немає автоматизованих перевірок перекладу, та й контролювати переклад програмного забезпечення середнього розміру стає неможливо. Тому приступаючи до локалізації варто задуматися про спеціалізовані засоби, заточені саме на завдання перекладу програмного забезпечення.\nПри локалізації програмного забезпечення часто використовуються спеціалізовані інструменти, наприклад, Passolo, що дозволяють перекладати меню та повідомлення в самих програмних ресурсах та безпосередньо в компільованих програмах, а також тестувати коректність локалізації. При перекладі аудіо- та відеоматеріалів (головним чином, фільмів) також використовуються спеціалізовані засоби, наприклад, Swift, котрі поєднують у собі деякі аспекти пам'яті перекладів, але додатково забезпечують можливість появи субтитрів залежно від часу, їх форматування на екрані, відповідність відеостандартам та інше.", "content": "Локаліза́ція програ́много проду́кту — приведення програмного продукту у відповідність із законами та іншими нормативно-правовими актами, стандартами, нормами і правилами, що діють в країні для якої проводиться локалізація. Локалізація () — переклад і адаптація елементів інтерфейсу, допоміжних файлів та документації. У англійській мові для слова «localization» іноді застосовують скорочення l10n або L10N, де число 10 означає кількість пропущених між «l» та «n» літер. Завдання локалізації не вичерпується тільки перекладом, більш того, переклад як такий зазвичай займає скромне місце в процесі локалізації програмного забезпечення. Типовими завданнями адаптації є використання національних символів валюти, застосування прийнятих форматів представлення дати і часу, а також правил алфавітного сортування текстів. Для програмного забезпечення з графічним користувацьким інтерфейсом локалізація також має на увазі коректне вирівнювання і розміщення елементів інтерфейсу з урахуванням того, що повідомлення-рядки можуть мати істотно різні розміри у різних мовах (наприклад, типове повідомлення англійською, бувши перекладено на німецьку мову, як правило, стає довшим на 30—50%), а також з урахуванням правил написання тексту (наприклад, зліва направо для більшості західних мов, справа наліво для арабської та івриту, зверху вниз для японської). Таким чином дизайн та розробка програмного забезпечення повинні враховувати міркування локалізації найсерйознішим чином. Деякі інструменти для візуального програмування надають можливості та інструменти для полегшення локалізації. Наприклад, у GTK+ найчастіше немає необхідності спеціально піклуватися про різну довжину рядків в різних мовах, оскільки віджети автоматично запрошують необхідний для себе розмір. Проте здебільшого ці можливості значно обмежені, що сильно відбивається на підсумковій вартості локалізації. У цих інструментах немає засобів для роботи з перекладачем, немає автоматизованих перевірок перекладу, та й контролювати переклад програмного забезпечення середнього розміру стає неможливо. Тому приступаючи до локалізації варто задуматися про спеціалізовані засоби, заточені саме на завдання перекладу програмного забезпечення. При локалізації програмного забезпечення часто використовуються спеціалізовані інструменти, наприклад, Passolo, що дозволяють перекладати меню та повідомлення в самих програмних ресурсах та безпосередньо в компільованих програмах, а також тестувати коректність локалізації. При перекладі аудіо- та відеоматеріалів (головним чином, фільмів) також використовуються спеціалізовані засоби, наприклад, Swift, котрі поєднують у собі деякі аспекти пам'яті перекладів, але додатково забезпечують можливість появи субтитрів залежно від часу, їх форматування на екрані, відповідність відеостандартам та інше. Мовні теги та коди Мовні теги можуть використовуватися для позначення регіональних особливостей тієї чи іншої мови. Є основний тег для ідентифікації мови (наприклад, «en» для англійської), а також факультативний додатковий тег для уточнення регіону використання (наприклад, «GB» — Great Britain, Велика Британія). Між субтегами зазвичай ставиться дефіс, у окремих випадках — риска знизу. Приклади мовних тегів: Англійська мова: en-GB (Британська англійська), en-US (Американська англійська), en-CA (Канадська англійська). Іспанська мова: es-ES (Кастильський іспанський, письмова та розмовна мова Іспанії), es-MX (Мексиканська іспанська), es-AR (Аргентинська іспанська), es-CO (Колумбійська іспанська). Португальська мова: pt-PT (Європейська португальська, письмова та розмовна мова Португалії), pt-BR (Бразильська португальська). Китайська мова: zh-CN (Материковий Китай, спрощенні ієрогліфи), zh-TW (Тайвань, традиційні ієрогліфи), zh-HK (Гонконг, традиційні ієрогліфи). Мовні коди визначаються стандартом ISO 639-2 у вигляді трилітерного терміна для ідентифікації кожної мови, наприклад, «eng» для англійської мови або «tvl» для мови Тувалу. Проте ці коди не можуть використовуватися як теги, якщо відповідна мова має дволітерний код відповідно до стандарту ISO 639-1. Див. також Інтернаціоналізація Українізація програмного забезпечення XLIFF Посилання Технологія локалізації Стаття про локалізацію застосувань Інструменти локалізації для Mac Інструмент для локалізації VC++, .NET та застосувань на Java Статистика: 10 найпоширеніших мов Інтернету Інструменти локалізації — програми що допомагають в створенні русифікаторів Категорія:Програмне забезпечення Категорія:Програмування Категорія:Локалізація Категорія:Переклад"}
{"category": "Програмування", "title": "Локаль", "abstract": "Локаль (англ. locale) — у програмуванні набір параметрів, що визначають мову користувача, країну, а також усі особисті налаштування, котрі користувач хоче бачити в інтерфейсі.\nІдентифікатор локалі може визначатися такими засобами:\n\nУ Win32 API ідентифікатор називається LCID і є числом — наприклад, 1033 для англійської мови (США), 1049 для російської мови або 1058 для української.\nУ XML, Microsoft .NET та Java, а також в інших середовищах, котрі підтримують Unicode, локаль позначається згідно з RFC 3066 та його наступниками. Зазвичай використовуються коди ISO 639 і ISO 3166-1 alpha-2. Зокрема, в .NET використовується рядок «en-US» для США і т. п.\nВ Unix, GNU/Linux та інших платформах POSIX локаль визначається так само як RFC 3066, але варіанти локалі позначаються по-іншому — набір символів також включається в ідентифікатор. Отже, він має такий вигляд:\n[language[_territory][.codeset][@modifier]].", "content": "Локаль () — у програмуванні набір параметрів, що визначають мову користувача, країну, а також усі особисті налаштування, котрі користувач хоче бачити в інтерфейсі. Ідентифікатор локалі може визначатися такими засобами: У Win32 API ідентифікатор називається LCID і є числом — наприклад, 1033 для англійської мови (США), 1049 для російської мови або 1058 для української. У XML, Microsoft .NET та Java, а також в інших середовищах, котрі підтримують Unicode, локаль позначається згідно з RFC 3066 та його наступниками. Зазвичай використовуються коди ISO 639 і ISO 3166-1 alpha-2. Зокрема, в .NET використовується рядок «en-US» для США і т. п. В Unix, GNU/Linux та інших платформах POSIX локаль визначається так само як RFC 3066, але варіанти локалі позначаються по-іншому — набір символів також включається в ідентифікатор. Отже, він має такий вигляд: [language[_territory][.codeset][@modifier]]. Загальні параметри, що входять до поняття Локаль Налаштування «Локаль» охоплюють такі установлення формату (вивід даних) дисплея: Мова дисплея Формат чисел Формати дати/часу Часовий пояс Перехід на зимовий/літній час (Daylight Saving Time — DST) Грошовий формат Вказані формати можуть також охоплювати (або не охоплювати) вхідні налаштування формату, що залежить від кожної програми окремо. Налаштування переходу на зимовий/літній час базуються на налаштуваннях часового поясу. Винятком є розкладка клавіатури, де визначаються тільки налаштування вводу, але не налаштування виводу, бо більшість клавіатур не вважаються пристроями виводу. Див. також Локалізація Українізація Українізація програмного забезпечення Інтернаціоналізація ISO 639 Посилання Common Locale Data Repository Категорія:Програмування Категорія:Програмне забезпечення Категорія:Локалізація"}
{"category": "Програмування", "title": "Магія (програмування)", "abstract": "В контексті програмування, магія є неофіційним терміном для абстракції; він використовується для опису коду, який виконує складні завдання, але ховає цю складність за простим інтерфейсом. Це дещо жартівливий термін, але з негативним відтінком, який має на увазі те, що справжня поведінка коду не відразу очевидна. Наприклад, поліморфізм типів і механізм замикання в Perl часто називають магічними. Термін передбачає, що приховану складність можна зрозуміти в принципі, на відміну від чорної магії та глибокої магії — термінів, якими називають заплутані методи, які навмисне приховані, або надзвичайно складні для зрозуміння. Дія таких абстракцій описується словом «автомагічно», телескопія слів «автоматично» та «магічно».", "content": "В контексті програмування, магія є неофіційним терміном для абстракції; він використовується для опису коду, який виконує складні завдання, але ховає цю складність за простим інтерфейсом. Це дещо жартівливий термін, але з негативним відтінком, який має на увазі те, що справжня поведінка коду не відразу очевидна. Наприклад, поліморфізм типів і механізм замикання в Perl часто називають магічними. Термін передбачає, що приховану складність можна зрозуміти в принципі, на відміну від чорної магії та глибокої магії — термінів, якими називають заплутані методи, які навмисне приховані, або надзвичайно складні для зрозуміння. Дія таких абстракцій описується словом «автомагічно», телескопія слів «автоматично» та «магічно». Див. також Магічне число (програмування) Чорний ящик Карго-культ програмування Зноски Категорія:Програмування Категорія:Програмна інженерія"}
{"category": "Програмування", "title": "Макрокоманда", "abstract": "Макрокоманда, макро або макрос (множина від англ. macro) — програмний алгоритм дій, записаний користувачем.", "content": "Макрокоманда, макро або макрос (множина від ) — програмний алгоритм дій, записаний користувачем. Макрокоманди в програмуванні У програмуванні макрокомандою називають таку абстракцію, коли всі випадки появи в документі тексту, що підпадає під заданий шаблон, модифікуються за заданими правилами. Інтерпретатор або компілятор автоматично змінює такі частини тексту, коли на них натрапляє. У компільованих мовах така заміна завжди відбувається під час компіляції. Також назва «макро» може вживатися в багатьох інших контекстах, як то клавіатурні макрокоманди та мови макрокоманд тощо. Більшість з таких контекстів безпосередньо пов'язана з тією самою концепцією — одна подана коротка команда або дія під час виконання розгортається у велику кількість інструкцій нижчого рівня абстракції. Призначення макрокоманд полягає або в автоматизації часто вживаних послідовностей дій чи команд, або в сильнішому абстрагуванні дій/команд. Наприклад, у вікіпедії макрокоманда {{subst:PAGENAME}} розкривається інтерпретатором на цій сторінці в «Макрокоманда». Макропрограми Також макросами або макропрограмами часто називають спеціальні програми, які призначено для виконання всередині інших програм. Наприклад, текстовий редактор Microsoft Word дозволяє виконувати у своєму середовищі програми, що написані спеціальною мовою VBA (Visual Basic for Applications). Такі програми звичайно використовуються для виконання типових для макрокоманд задач: автоматизації часто вживаних або складних послідовностей дій користувача. Порівняно висока ефективність та розвинута функціональність VBA поєднані з можливістю за певних умов автоматичного (без прямої вказівки на те користувачем) виконання макрокоманд призвели до появи та поширення макровірусів. Інші значення Також в інтернет-культурі макрокомандою називають один із засобів спілкування — зображення з написом чи без, що вирізняється здатністю точно відображувати певні емоції. Часто таким зображенням підкріплюється висловлювання чи коментар. Див. також M4 (мова програмування) Примітки Категорія:Програмування Категорія:Початковий код"}
{"category": "Програмування", "title": "Маскування (програмування)", "abstract": "Маскувáння (англ. mask, masking) — в інформатиці — спосіб обробки даних на бітовому рівні, для одержання значення якогось біта або набору бітів з числа, слова або байта. Маскування виконують з використанням логічних операцій та потрібним набором бітів — маскою.\nМаска або бітова маска — дані, використовувані для побітових операцій, зокрема в бітовому полі. Використовуючи маску, кілька бітів у байті, півбайті, слові тощо можна ввімкнути або вимкнути, або інвертувати з увімкнення на вимкнення (або навпаки) за допомогою однієї побітової операції. Також маскування використовують для предикації в обробці векторів, де бітова маска забезпечує вибір того, виконується операція з елементами вектора (біт маски ввімкнено), чи ні (біт маски вимкнено).\nНазва походить від аналогії з простим шифруванням, коли маска з отворами, накладена на беззмістовний текст, відкриває лише потрібні букви.", "content": "Маскувáння () — в інформатиці — спосіб обробки даних на бітовому рівні, для одержання значення якогось біта або набору бітів з числа, слова або байта. Маскування виконують з використанням логічних операцій та потрібним набором бітів — маскою. Маска або бітова маска — дані, використовувані для побітових операцій, зокрема в бітовому полі. Використовуючи маску, кілька бітів у байті, півбайті, слові тощо можна ввімкнути або вимкнути, або інвертувати з увімкнення на вимкнення (або навпаки) за допомогою однієї побітової операції. Також маскування використовують для в обробці векторів, де бітова маска забезпечує вибір того, виконується операція з елементами вектора (біт маски ввімкнено), чи ні (біт маски вимкнено). Назва походить від аналогії з простим шифруванням, коли маска з отворами, накладена на беззмістовний текст, відкриває лише потрібні букви. Типові випадки маскування Встановлення бітів у 1 Щоб увімкнути певні біти, можна використати порозрядну операцію АБО (OR), завдяки тому, що для окремого біта Y Y OR 1 = 1 і Y OR 0 = Y. Тому, щоб забезпечити стан біта 1, слід виконати OR з 1. Щоб залишити біт без змін, OR виконуємо з 0. Приклад: вимкнення старшого нібла (біти 4, 5, 6, 7), але залишення молодшого нібла (біти 0, 1, 2, 3) без змін. 10010101 10100101 OR 11110000 11110000 = 11110101 11110101 Встановлення бітів у 0 Частіше на практиці біти «вимикають» (або маскують у 0). Якщо до біта застосувати операцію І (AND) з 0, результат завжди дорівнює 0, тобто Y AND 0 = 0. Щоб залишити інші біти незміненими, над ними слід виконати AND з 1, оскільки Y AND 1 = Y Приклад: маскування старшого нібла (біти 4, 5, 6, 7), залишаючи молодший нібл (біти 0, 1, 2, 3) без змін. 10010101 10100101 AND 00001111 00001111 = 00000101 00000101 Запит статусу біта За допомогою бітової маски легко перевірити стан окремого біта. Для цього всі інші біти вимикаємо за допомогою порозрядного AND як описано вище, і значення порівнюємо з 0. Якщо воно дорівнює 0, то біт був вимкнений, але якщо воно відмінне від 0, то біт був увімкненим. Зручно, що немає необхідності з'ясовувати, яке насправді значення отримано, достатньо того, що воно не дорівнює 0. Приклад: запит статусу 4-го біта 10011101 10010101 AND 00001000 00001000 = 00001000 00000000 Перемикання значень бітів Іноді, незалежно від значення біта, його потрібно зробити протилежним до поточного (інвертувати). Цього можна досягти за допомогою операції XOR (виключне АБО). XOR повертає 1 тоді й лише тоді, коли непарна кількість бітів-операндів дорівнює 1. Отже, якщо два відповідні біти дорівнюють 1, результатом буде 0, але якщо лише один із них дорівнює 1, результатом буде 1. Тому інверсію значень бітів виконують за допомогою XOR з 1. Якщо початковий біт був 1, отримаємо 1 XOR 1 = 0. Якщо початковий біт був 0, отримаємо 0 XOR 1 = 1. Також зауважте, що маскування за допомогою XOR безпечне для бітів, тобто воно не вплине на незамасковані біти, тому що Y XOR 0 = Y, як і OR. Приклад: перемикання значень бітів 10011101 10010101 XOR 00001111 11111111 = 10010010 01101010 Щоб записати довільні 1 і 0 до підмножини бітів, спочатку запишіть 0 до цієї підмножини, а потім встановіть старші біти: register = (register & ~bitmask) | value; Використання бітових масок link=|міні|У фокусі зі вгадуванням того, на яких картках надруковано число, використано біти двійкового подання числа. У файлі SVG клацніть на картці, щоб перемкнути її. Аргументи функцій У мовах програмування, таких як C, бітові поля — це корисний спосіб передавання набору іменованих булівських аргументів у функцію. Наприклад, у графічному API OpenGL є команда glClear() яка очищає екран або інші буфери. Вона може очистити до чотирьох буферів (буфер кольору, глибини, накопичення та шаблону), тому автори API могли мати чотири аргументи. Але тоді виклик функції виглядав би так що не дуже наочно. Натомість є чотири визначені біти поля: GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_ACCUM_BUFFER_BIT і GL_STENCIL_BUFFER_BIT, а glClear() оголошено як void glClear(GLbitfield bits);Тоді виклик функції виглядає так glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);Завдяки цьому, функція, яка приймає таке бітове поле, може використовувати побітове AND для доступу до окремих бітів. Наприклад, реалізація glClear() може бути такою:void glClear(GLbitfield bits) { if ((bits & GL_COLOR_BUFFER_BIT) != 0) { // Очистити буфер кольору. } if ((bits & GL_DEPTH_BUFFER_BIT) != 0) { // Очистити буфер глибини. } if ((bits & GL_ACCUM_BUFFER_BIT) != 0) { // Очистити буфер накопичення. } if ((bits & GL_STENCIL_BUFFER_BIT) != 0) { // Очистити буфер шаблону. } }Перевага цього підходу полягає в тому, що обсяг аргументів функції зменшується. Оскільки найменший обсяг даних становить один байт, розділення параметрів на окремі аргументи призвело б до втрати семи бітів на кожному значенні, а отже до збільшення обсягу даних у стеку. Натомість функції зазвичай приймають одне або кілька 32-розрядних цілих чисел, кожне з яких містить до 32 бітових параметрів. Попри елегантність, у найпростішій реалізації це рішення не є типобезпечним. GLbitfield просто визначено як unsigned int, тому компілятор дозволив би безглуздий виклик glClear(42) або навіть glClear(GL_POINTS). У C++ альтернативою було б створити бібліотечний клас для інкапсуляції набору аргументів, які може приймати glClear. Інверсні маски Маски використовують із IP-адресами в IP ACL (списках контролю доступу), щоб визначити, що має бути дозволено, а що заборонено. Маски для налаштування IP-адрес на інтерфейсах починаються з 255 і мають великі значення зліва: наприклад, IP-адреса 203.0.113.129 з маскою 255.255.255.224. Маски для IP ACL навпаки: наприклад, маска 0.0.0.255. Це іноді називають інверсною маскою або . Коли значення маски розглядається як двійкове (з 0 і 1), воно визначає, які біти адреси слід враховувати при обробці трафіку. 0 вказує на те, що необхідно враховувати біт адреси (точна відповідність); 1 в масці означає «байдуже». Для пояснення концепції розгляньмо приклад. Приклад маски: мережева адреса (трафік, який потрібно обробити): 192.0.2.0 маска: 0.0.0.255 мережева адреса (двійкова): 11000000.00000000.00000010.00000000 маска (двійкова): 00000000.00000000.00000000.11111111 Виходячи з двійкової маски, можна побачити, що перші три набори (октети) мають точно відповідати заданій двійковій мережевій адресі (11000000.00000000.00000010). Останній набір чисел складається з «байдуже» (.11111111). Отже, увесь трафік, який починається з «192.0.2.», збігається, оскільки останній октет — «байдуже». Тому з цією маскою обробляються мережеві адреси від 192.0.2.1 до 192.0.2.255 (192.0.2.x). Якщо звичайну маску відняти від 255.255.255.255, то отримаємо інверсну маску ACL. У цьому прикладі визначено інверсну маску для мережевої адреси 198.51.100.0 зі звичайною маскою 255.255.255.0: 255.255.255.255 — 255.255.255.0 (звичайна маска) = 0.0.0.255 (інверсна маска) Еквіваленти ACL: Джерело/підстановка джерела 0.0.0.0/255.255.255.255 означає «будь-яка». Джерело/підстановка 198.51.100.2/0.0.0.0 означає те саме, що й «хост 198.51.100.2». Маскування зображень міні| Растрові спрайти (ліворуч) і маски (праворуч) У комп'ютерній графіці для зображення, призначеного для розміщення на тлі, прозорі ділянки можна вказати за допомогою двійкової маски. В такому разі для кожного із зображень насправді існує два растрові зображення: фактичне зображення, у якому невикористані ділянки мають значення в пікселях із усіма бітами, встановленими на 0, і додаткова маска, в якій ділянкам зображення відповідають значення 0 усіх бітів у пікселях, а прозорим ділянкам — значення 1. На малюнку праворуч чорні пікселі мають усі нульові біти, а білі пікселі — всі одиничні біти. Під час , щоб розмістити зображення на екрані поверх тла, програма спочатку маскує біти пікселя екрана в потрібних координатах за допомогою маски зображення та бітової операції І. Це зберігає пікселі тла прозорих ділянок, а біти пікселів, які має закрити зображення, скидає на нуль. Потім програма візуалізує біти пікселя зображення, поєднуючи їх із бітами пікселя тла за допомогою операції побітового АБО. Завдяки цьому пікселі зображення розміщуються як належить, зберігаючи навколишні пікселі тла. Результат — точне поєднання зображення і тла. центр Ця техніка використовується для малювання курсорів вказівних пристроїв, у типових двовимірних відеоіграх для персонажів, куль тощо (спрайтів), для піктограм графічного інтерфейсу користувача, а також для створення заголовків відео та інших програм для змішування зображень. Швидший спосіб — просто перезаписати пікселі тла пікселями переднього плану, якщо їх альфа=1 Хоча прозорі кольори та альфа-канали використовують для тих самих цілей, ці методи не передбачають змішування пікселів зображень за допомогою двійкового маскування. Геш-таблиці Щоб створити функцію гешування для геш-таблиці, часто використовують функція, яка має велику область значень. Щоб створити індекс із вихідних даних функції, можна для зменшення розміру області значень відповідно до розміру масиву використати остачі; однак на багатьох процесорах часто швидше обмежити розмір хеш-таблиці розмірами, рівними степеням 2, та замість цього використовувати бітову маску. Приклад обох підходів на C:#include <stdint.h> #include <string.h> int main(void) { const uint32_t NUM_BUCKETS = 0xFFFFFFFF; // 2^32 - 1 const uint32_t MAX_RECORDS = 1<<10; // 2^10 const uint32_t HASH_BITMASK = 0x3FF; // (2^10)-1 char **token_array = NULL; // Опрацювання розміщення в пам'яті token_array… char token[] = \"some hashable value\"; uint32_t hashed_token = hash_function(token, strlen(token), NUM_BUCKETS); // Використовуємо остачу size_t index = hashed_token % MAX_RECORDS; // АБО // Використовуємо бітову маску size_t index = hashed_token & HASH_BITMASK; *(token_array+index) = token; // Вивільняємо пам'ять token_array … return 0; } Див. також Бітові операції Двійково-десятковий код Маска (значення) Регулярний вираз Примітки Категорія:Програмування Категорія:Статті з прикладами коду мовою C Категорія:Двійкова арифметика"}
{"category": "Програмування", "title": "Масштабовність", "abstract": "В галузі телекомунікацій і програмного забезпечення, масштабовність[джерело?] є бажаною властивістю системи, мережі, або процесу, яка свідчить про здатність системи обробити більший обсяг роботи або бути легко розширеною. Наприклад, масштабовність може позначати здатність системи до збільшення загальної пропускної спроможності відповідно до підвищеного навантаження, коли додано (здебільшого, апаратні) ресурси. Цей термін має аналогічне значення, коли його вживають в галузі комерції, наприклад, масштабовність компанії припускає, що основна бізнес-модель надає можливості для економічного зростання всередині компанії.\nВ архітектурі програмного забезпечення маштабовність — це здатність підтримувати великі кількості архітектурних компонентів та з'єднань між ними.\nМасштабовність, як властивість системи, як правило, важко визначити, і в кожному конкретному випадку потрібно визначити конкретні вимоги до параметрів, які вважаються важливими. Це є дуже важливим питанням у галузі електронних систем, баз даних, маршрутизаторів і мереж. Систему, що підвищує продуктивність роботи після додавання апаратних засобів пропорційно доданим ресурсам, називають масштабовною. Алгоритм, архітектура, мережевий протокол, програма або інша система називається масштабовними, якщо вони ефективні в застосуванні до великих задач (наприклад, великий набір вхідних даних або велика кількість вузлів у випадку розподіленої системи).", "content": "В галузі телекомунікацій і програмного забезпечення, масштабовність є бажаною властивістю системи, мережі, або процесу, яка свідчить про здатність системи обробити більший обсяг роботи або бути легко розширеною.André B. Bondi, 'Characteristics of scalability and their impact on performance', Proceedings of the 2nd international workshop on Software and performance, Ottawa, Ontario, Canada, 2000, ISBN 1-58113-195-X, pages 195—203 Наприклад, масштабовність може позначати здатність системи до збільшення загальної пропускної спроможності відповідно до підвищеного навантаження, коли додано (здебільшого, апаратні) ресурси. Цей термін має аналогічне значення, коли його вживають в галузі комерції, наприклад, масштабовність компанії припускає, що основна бізнес-модель надає можливості для економічного зростання всередині компанії. В архітектурі програмного забезпечення маштабовність — це здатність підтримувати великі кількості архітектурних компонентів та з'єднань між ними. Масштабовність, як властивість системи, як правило, важко визначитиSee for instance, Mark D. Hill, 'What is scalability?' in ACM SIGARCH Computer Architecture News, December 1990, Volume 18 Issue 4, pages 18-21, (ISSN 0163-5964) and Leticia Duboc, David S. Rosenblum, Tony Wicks, 'Doctoral symposium: presentations: A framework for modelling and analysis of software systems scalability' in Proceeding of the 28th international conference on Software engineering ICSE '06, May 2006. ISBN 1-59593-375-1, pages 949—952, і в кожному конкретному випадку потрібно визначити конкретні вимоги до параметрів, які вважаються важливими. Це є дуже важливим питанням у галузі електронних систем, баз даних, маршрутизаторів і мереж. Систему, що підвищує продуктивність роботи після додавання апаратних засобів пропорційно доданим ресурсам, називають масштабовною. Алгоритм, архітектура, мережевий протокол, програма або інша система називається масштабовними, якщо вони ефективні в застосуванні до великих задач (наприклад, великий набір вхідних даних або велика кількість вузлів у випадку розподіленої системи). Див. також Закон Амдала Примітки Категорія:Програмування Категорія:Комп'ютерні системи"}
{"category": "Програмування", "title": "Мережі Петрі", "abstract": "Мережі Петрі (МП) — математичний апарат для моделювання динамічних дискретних систем. Вперше описані Карлом Петрі у 1962 році.\nМП використовуються для моделювання асинхронних систем, що функціонують як сукупність паралельних взаємодіючих процесів. Аналіз МП дозволяє отримати інформацію про структуру та динамічну поведінку модельованої системи.\nПричинно-наслідковий зв'язок подій в асинхронних системах задається множиною відношень вигляду «умови-події». У МП умови — це позиції, а події — переходи. Відповідно до цього граф МП є двочастковим орієнтованим мультиграфом. Орієнтовані дуги можуть сполучати лише позиції і переходи в прямому і зворотному напрямі. МП є мультиграфом, оскільки допускається кратність дуг між позиціями і переходами.\nB графах МП кількісні характеристики умов (числа натурального ряду) прийнято задавати числом міток у відповідних позиціях.\nПослідовності подій відображуються спрацьовуваннями переходів. Виконання якої-небудь умови пов'язане з появою однієї або декількох міток у відповідній цій умові позиції. Угоди про правила спрацьовування переходів є способом представлення причинно-наслідкових зв'язків між умовами і подіями в системі (рис.1).", "content": "thumb|Рисунок 1 — Приклад мережі Петрі. Білими колами позначені позиції, смужками — переходи, чорними колами — мітки. |210x210px Мережі Петрі (МП) — математичний апарат для моделювання динамічних дискретних систем. Вперше описані Карлом Петрі у 1962 році. МП використовуються для моделювання асинхронних систем, що функціонують як сукупність паралельних взаємодіючих процесів. Аналіз МП дозволяє отримати інформацію про структуру та динамічну поведінку модельованої системи. Причинно-наслідковий зв'язок подій в асинхронних системах задається множиною відношень вигляду «умови-події». У МП умови — це позиції, а події — переходи. Відповідно до цього граф МП є двочастковим орієнтованим мультиграфом. Орієнтовані дуги можуть сполучати лише позиції і переходи в прямому і зворотному напрямі. МП є мультиграфом, оскільки допускається кратність дуг між позиціями і переходами. B графах МП кількісні характеристики умов (числа натурального ряду) прийнято задавати числом міток у відповідних позиціях. Послідовності подій відображуються спрацьовуваннями переходів. Виконання якої-небудь умови пов'язане з появою однієї або декількох міток у відповідній цій умові позиції. Угоди про правила спрацьовування переходів є способом представлення причинно-наслідкових зв'язків між умовами і подіями в системі (рис.1). Історія МП розроблялися спеціально для моделювання тих систем, які містять взаємодіючі паралельні компоненти. Вперше МП запропонував Карл Петрі у своїй докторській дисертації «Kommunikation mit Automaten» («Зв'язок автоматів»). Він сформулював основні поняття теорії зв'язку асинхронних компонент обчислювальної системи. Зокрема, детально розглянув опис причинних зв'язків між подіями. Його дисертація присвячена, головним чином, теоретичній розробці основних понять, з яких почали розвиток МП. Робота Петрі привернула увагу А. В. Хольта і співробітників з Information System Theory (Теорія інформаційних систем) фірми Applied Data Research (ADR). Ними була розвинена велика частина початків теорії, запропоновані позначення і представлення МП, опубліковані в окремому звіті, що має назву «Events and Conditions» («Події і умови»). У цій роботі показано, як МП можна застосувати до аналізу і моделювання систем, що включають паралельні компоненти. Робота Петрі привернула також увагу групи, що працює над проєктом MAC в Массачусетському технологічному інституті (МТІ). Керована професором Дж. Б. Деннісом група обчислювальних структур стала джерелом значних досліджень і публікацій по МП, було написано декілька дисертацій на ступень доктора філософії і безліч звітів і меморандумів. Групою обчислювальних структур були проведені дві великі конференції з МП: Конференція Проєкта MAC з паралельних систем і паралельних обчислень в 1970 р. у Вудс Холле і Конференції з МП і пов'язаних з ними методів в 1975 р. в МТІ. Обидві ці конференції внесли вклад до поширення результатів і методів теорії МП. Визначення МП задається у вигляді маркованого двочасткового орієнтованого графу. Розрізняють два типи вершин: позиції (позначаються колами) і переходи (позначаються смужками). МП може бути формально подана у вигляді як сукупність множин: , де — множина всіх позицій ( — кількість позицій); — множина переходів ( — кількість переходів); — множина дуг мережі: , — множини дуг, що ведуть відповідно від переходів до позицій і від позицій до переходів (дуг, що з'єднують однорідні вершини, не існує); — множина ваг дуг ( — кількість дуг). Кожна позиція може бути маркована, тобто містити певну кількість маркерів. Якщо позначити числа міток, які перебувають в i-й позиції , як , то маркування всієї мережі: . Тоді повне визначення МП, включаючи дані про початкове маркування, можна записати у вигляді , де — початкове маркування мережі. При моделюванні процесів прийняття рішень за допомогою МП її позиції інтерпретують собою деякі умови, стани, значення змінних тощо. Переходи інтерпретують собою логічні пропозиції (прийняття рішень), відповідні виконанню дій, при цьому вхідні позиції — умови виконання дій, вихідні позиції — результат виконання дій. Дія (перехід) пов'язана з прийняттям будь-якого рішення, яке ініційоване певними умовами і результатом якого є новий стан (умова). Правила спрацьовування переходів thumb|Рисунок 2 — Фрагмент мережі Петрі до а) і після б) спрацьовування переходу|304x304px Перехід спрацьовує, якщо для кожної з його вхідних позицій виконується умова , де — число маркерів в i-й вхідний позиції, - число дуг, що йдуть від i-й позиції до переходу; при спрацьовуванні переходу число маркерів в i-й вхідний позиції зменшується на , а в j-й вихідний позиції збільшується на , де — число дуг, що пов'язують перехід з j-ю позицією. На рисунку 2 показаний приклад розподілу маркерів по позиціях перед спрацьовуванням, це маркування записують у вигляді (2,2,3,1). Після спрацьовування переходу маркування стає іншим: (1,0,1,4). Граф досяжності У МП кожній вершині відповідає певне маркування, а кожній дузі — перехід, який спрацьовує при цьому маркуванні. Таким чином, граф досяжності представляється як де — множина вершин (маркувань, відповідних вершин): , — i-те маркування, — кількість маркувань; — множина дуг, що зв'язують вершини ( — кількість дуг). Кожна дуга представляється як сукупність , де и — номери початкової і кінцевої вершин графу; — множина переходів, відповідний дузі, — кількість переходів, що одночасно спрацьовують при переході від одного маркування до іншого. Алгоритм побудови графу для мереж Петрі thumb|Рисунок 3 — Граф досяжності мережі Петрі 1. За початкове береться маркування і йому привласнюється мітка «нове». 2. Для кожного «нового» маркування виконувати наступні операції: 2.1 Для «нового» маркування Мнов визначаються всі переходи, які можуть бути запущені, а також всі можливі комбінації цих переходів. 2.2 Для кожного дозволеного переходу або комбінації переходів здійснюються такі дії: 2.2.1 Визначається маркування, яке утворюється при спрацьовуванні даного переходу (комбінації переходів). 2.2.2 Переглядаються всі маркування на шляху від до початкової . Якщо на шляху знаходиться маркування , елементи якої більше або рівні відповідним елементам нової і яка не дорівнює , то замість елементів , які більше, ніж елементи маркування , записується символ\"\"(нескінченність). У масив записується дуга з відповідними , и . 2.2.3 Проглядаються всі маркування графу. Якщо знаходиться маркування, рівне новому, то в масив записується нова дуга, у якій = і рівні номера знайденого маркування. 2.2.4 Якщо в попередніх пунктах 2.2 і 2.3 маркування не знайдені, то створюється нова вершина графу, в яку записується нове маркування, в масив записується дуга, у якій дорівнює номеру початкового маркування, — номеру нового маркування, — набір переходів, спрацювання яких призвело до переходу від одного маркування до іншого. Далі визначається масив всіх дозволених переходів і розрахунок триває, починаючи з п. 2.2 Для розглянутого вище прикладу МП граф досяжності має вигляд (рисунок 3), список маркувань приведений у таблиці 1. Таблиця 1 — Список маркувань. (Р1 Р2 Р3 Р4 Р5 Р6 Р7 Р8)M1(11000000)M2(00100000)M3(00010000)M4(00000100)M5(00000001)M6(00001000)M7(00000010) Види мереж Петрі Види мереж Петрі: Часова МП — мережа характеризується введенням затримок при переміщенні маркера, затримка може бути зв'язана як з переходом так і з позицією. Стохастична МП — затримки є випадковими параметрами. Функціональна МП — затримки визначаються як функції деяких аргументів, наприклад, кількості міток в яких-небудь позиціях, стани деяких переходів. Кольорова МП — мітки можуть бути різних типів, що позначаються кольорами, тип мітки може бути використаний як аргумент у функціональних мережах. Інгібіторна МП — можливі інгібіторні дуги, що забороняють спрацьовування переходу, якщо у вхідній позиції, пов'язаної з переходом інгібіторною дугою, знаходиться мітка. Ієрархічна МП — містить не миттєві переходи, в які вкладені інші, можливо, також ієрархічні, мережі. Спрацьовування такого переходу характеризує виконання повного життєвого циклу вкладеної мережі. Потокова МП (Work Flow Petri Nets — WF) - називається мережею потоків робіт (WF-мережею), використовують для моделювання потоків робіт в WorkFlow системах. Мережі з пріоритетами — додають до дозволених переходів пріоритети і тим самим дозволяють понизити недетермінованість спрацьовувань, обмежуючи безліч дозволених переходів групою переходів з найвищим пріоритетом. Властивості мереж Петрі Для дослідження різних варіантів можливого розвитку обчислювального процесу на мережевій моделі вводяться поняття деяких властивостей мереж Петрі. Безпека позиції. Позиція називається безпечною в заданому початковому маркуванні , якщо в процесі роботи цієї мережі в даній позиції ніколи не з'явиться більш за один маркер, тобто . Мережа Петрі називається безпечною, якщо безпечні всі її позиції. Ця властивість важлива при моделюванні каналів передачі даних (за відсутності буфера). Обмеженість. Позиція називається обмеженою в заданому початковому маркуванні , якщо в процесі роботи цієї мережі в даній позиції ніколи не з'явиться більш за -маркерів, тобто . Стійкість. МП називається стійкою, якщо для будь-якого її переходу виконується наступна умова: стан збудження цього переходу не може бути зняте спрацьовуванням іншого будь-якого переходу. Якщо в мережі є альтернативні переходи, то вона є нестійкою. Досяжність. Маркування називається досяжним з деякого маркування , якщо для даної моделі МП можна вказати таку послідовність спрацьовування переходів, яка переводить маркування у маркування . Активність (жвавість). Перехід називається активним (живим) в заданому початковому маркуванні , якщо для будь-якого маркування , досяжного з можна вказати ланцюжок спрацьовувань переходів, який призводить до порушення переходу . Ця властивість має важливе значення при дослідженні проблем зависання, зациклення і блокування процесів і можливості завершення процесу. Мережа називається активною в заданому початковому маркуванні μ0, якщо активні (живі) всі її переходи. Процес функціонування мереж Петрі Процес функціонування мережі Петрі задається наступними двома правилами: Якщо в деякий момент часу в кожній вхідній позиції переходу є хоча б по одному маркеру, то перехід називається збудженим. , де — збудження переходу Збуджений перехід може спрацювати; момент спрацьовування збудженого переходу не задається і може бути цілковито випадковим. Якщо перехід спрацює, то відбувається зміна маркування позицій і з кожної вхідної позиції видаляються по одному маркеру, а в кожну вихідну позицію додаються по одному маркеру: , . За цими правилами МП функціонують, починаючи з початкового маркування , і процес буде тривати до тих пір, поки може бути збуджений хоча б один перехід. Маркування , при якому жоден перехід не збуджений, називається тупиковим. Після досягнення тупикового маркування робота мережі припиняється. Нечітке моделювання з використанням мереж Петрі В процесі моделювання за допомогою МП інколи доводиться описувати стан, настання якого не прогнозоване. У класичних МП спрацьовування переходу залежить від того, чи вірна умова чи ні. Але інколи необхідна МП, здатна працювати з невизначеними величинами («малий», «великий», …), — нечітка МП. Нечітка мережа Петрі задається 6-ма змінними: НМП = , де — кінцевий набір нечітких позицій, і з'єднання між позиціями можуть набувати будь-яких ненегативних натуральних значень. - кінцевий набір нечітких переходів. – нечітке відношення з маркуванням на або , зване ваговою функцією, яка показує вхідну величину на дузі від позиції до переходу або вихідну величину на дузі від переходу до позиції. і — невід'ємні речові функції від , які показують пріоритет з'єднання і поріг спрацьовування переходу відповідно. — невід'ємна речова функція від , що показує початкове маркування і також звана початковим розподілом ресурсів. Нехай мітка буде носієм нечіткої величини, з'єднання будуть визначатися лінгвістичними висловлюваннями правил ЯКЩО-ТО і переходи будуть представляти базове нечітке відношення виходячи з правил ЯКЩО-ТО. Нечіткі правила ЯКЩО-ТО — принцип, який використовується для опису логічної залежності між змінними в такій формі: ЯКЩО належить І належить ТО належить , де і — певні вирази, що характеризують змінні і . Вони найчастіше задаються лінгвістично. Частина перед ТО називається антецедент, частина після ТО називається сукцедент. Змінні називаються вхідними або незалежними змінними. Мінлива називається вихідною або залежною змінною. Нечіткі правила ЯКЩО-ТО зазвичай об'єднуються разом, утворюючи лінгвістичний опис. Примітки Література Ачасова С. М., Бандман О. Л. Корректность параллельных вычислительных процессов. — Н.: Наука, 1990. — 253 с. Котов В. Е. Сети Петри. — М.: Наука, 1984. — 160 с. Мараховский В. Б., Розенблюм Л. Я., Яковлев А. В. Моделирование параллельных процессов. Сети Петри. Курс для системных архитекторов, программистов, системных аналитиков, проектировщиков сложных систем управления. — Санкт-Петербург: Профессиональная литература, АйТи-Подготовка, 2014. — 400 с. Норенков И. П., Кузьмик П. К. Информационная поддержка наукоемких изделий. М.: МГТУ им. Н. Э. Баумана. 2002. — 347с. Питерсон Дж. Теория сетей Петри и моделирование систем. — М: Мир, 1984. — 264 с. Слепцов А. И., Юрасов А. А. Автоматизация проектирования управляющих систем гибких автоматизированных производств /Под ред. Б. Н. Малиновского.– К.: Техніка, 1986.–160 с. Тэрано, Т.; Асаи, К.; Сугэно, М. Прикладные нечеткие системы. М.: Мир. 1993. — 368с. Див. також Система масового обслуговування Кінцевий автомат Теорія графів Джерела Категорія:Програмування Категорія:Теорія графів Категорія:Теорія автоматів Категорія:Моделі обчислень Категорія:Мови формальних специфікацій"}
{"category": "Програмування", "title": "Метапрограмування", "abstract": "Метапрограмування — вид програмування, пов'язаний із створенням програмного коду, який на основі описів (метаданих) деяких процесів, алгоритмів або даних породжує інші програми для автоматизації описаних процесів, виконання послідовностей операцій алгоритмів або обробки даних. Метапрограмування засноване на метаданих, які можуть визначати типи, структуру або правила обробки даних, але не обмежується лише цим. Генеруючі код програми часто називають метапрограмами, a написання цих програм називається метапрограмуванням.", "content": "Метапрограмування — вид програмування, пов'язаний із створенням програмного коду, який на основі описів (метаданих) деяких процесів, алгоритмів або даних породжує інші програми для автоматизації описаних процесів, виконання послідовностей операцій алгоритмів або обробки данихДжонатан Бартлетт. Мистецтво метапрограмування, Частина 1: Вступ до метапрограмування . Метапрограмування засноване на метаданих, які можуть визначати типи, структуру або правила обробки даних, але не обмежується лише цим. Генеруючі код програми часто називають метапрограмами, a написання цих програм називається метапрограмуванням. Див. також Узагальнене програмування Метаклас Скаффолдинг Примітки Посилання Мистецтво метапрограмування Категорія:Парадигми програмування Категорія:Програмування"}
{"category": "Програмування", "title": "Метод каченяти", "abstract": "Метод каченяти (англ. rubber ducking) — це метод розв'язання задачі через делегування її уявному помічнику. Метод описаний в книзі «Прагматичний програміст».\nСуть методу полягає в тому, що ви ставите (чи уявляєте) на робочому столі іграшкове каченятко, і коли в вас виникає запитання, на яке важко дати відповідь — задаєте його іграшці, так неначе вона справді може відповісти. А правильне формулювання питання, як відомо, містить половину відповіді.\nТакож використовується при зневадженні. Якщо певна частина програми не працює, програміст пробує пояснити каченяті, що робить кожен рядок програми, і в процесі цього знаходить невідповідність синтаксису й прагматики.", "content": "thumb Метод каченяти () — це метод розв'язання задачі через делегування її уявному помічнику. Метод описаний в книзі «Прагматичний програміст». Суть методу полягає в тому, що ви ставите (чи уявляєте) на робочому столі іграшкове каченятко, і коли в вас виникає запитання, на яке важко дати відповідь — задаєте його іграшці, так неначе вона справді може відповісти. А правильне формулювання питання, як відомо, містить половину відповіді. Також використовується при зневадженні. Якщо певна частина програми не працює, програміст пробує пояснити каченяті, що робить кожен рядок програми, і в процесі цього знаходить невідповідність синтаксису й прагматики. Див. також Метод Сократа Парне програмування Перегляд коду Література Категорія:Незавершені статті про програмування Категорія:Аналіз програм Категорія:Програмування Категорія:Зневадження Категорія:Птахи в культурі Категорія:Програмна інженерія"}
{"category": "Програмування", "title": "Мистецтво програмування", "abstract": "Мистецтво програмування (англ. The Art of Computer Programming (TAOCP)) — фундаментальна монографія відомого американського фахівця в галузі комп'ютерних наук та математика Дональда Кнута, присвячена розгляду та аналізу найважливіших алгоритмів, що застосовуються в інформатиці. 1999 року книгу було визнано однією з дванадцяти найкращих фізико-математичних монографій століття.\nНаписання книги було розпочате автором 1962 року. Спочатку планувалося випустити її одним томом, але обсяг матеріалу виявився настільки великим, що кількість томів було збільшено до семи. Перші три томи було видано досить швидко: перший том — 1968 р., другий том — 2 1969 року, та третій — 1973 року, після чого було зроблено перерву до лютого 2005 року, в якому автор опублікував першу частину четвертого тому. Було прийнято рішення випускати інші частини четвертого тому приблизно по дві на рік окремими випусками, після чого офіційно видати весь четвертий том. Протягом 2005—2009 років було видано випуски 0, 1, 2, 3 і 4, а 2011 року було видано том 4А, до якого увійшла інформація цих випусків. Також 2005 року було видано випуск 1 «MMIX — RISC-комп'ютер для нового тисячоліття», інформація з якого увійде до нового (четвертого) видання першого тому. У 2015 році був виданий випуск 6 Satisfiability, що містив середню третину майбутнього тому 4B. 2019 року було видано випуск 5 Mathematical Preliminaries Redux; Introduction to Backtracking; Dancing Links, що містив першу третину майбутнього тому 4B. У 2022 році був виданий том 4B.\nЧас, необхідний на повне завершення книги, сам автор оцінює в 20 років безперервної щоденної роботи. Оскільки Кнут завжди вважав «Мистецтво програмування» основним проектом свого життя, 1990 року він вийшов на пенсію, з наміром повністю сконцентруватися на написанні відсутніх частин і приведення до ладу існуючих.", "content": "Мистецтво програмування ( (TAOCP)) — фундаментальна монографія відомого американського фахівця в галузі комп'ютерних наук та математика Дональда Кнута, присвячена розгляду та аналізу найважливіших алгоритмів, що застосовуються в інформатиці. 1999 року книгу було визнано однією з дванадцяти найкращих фізико-математичних монографій століття. Написання книги було розпочате автором 1962 року. Спочатку планувалося випустити її одним томом, але обсяг матеріалу виявився настільки великим, що кількість томів було збільшено до семи. Перші три томи було видано досить швидко: перший том — 1968 р., другий том — 2 1969 року, та третій — 1973 року, після чого було зроблено перерву до лютого 2005 року, в якому автор опублікував першу частину четвертого тому. Було прийнято рішення випускати інші частини четвертого тому приблизно по дві на рік окремими випусками, після чого офіційно видати весь четвертий том. Протягом 2005—2009 років було видано випуски 0, 1, 2, 3 і 4, а 2011 року було видано том 4А, до якого увійшла інформація цих випусків. Також 2005 року було видано випуск 1 «MMIX — RISC-комп'ютер для нового тисячоліття», інформація з якого увійде до нового (четвертого) видання першого тому. У 2015 році був виданий випуск 6 Satisfiability, що містив середню третину майбутнього тому 4B. 2019 року було видано випуск 5 Mathematical Preliminaries Redux; Introduction to Backtracking; Dancing Links, що містив першу третину майбутнього тому 4B. У 2022 році був виданий том 4B. Час, необхідний на повне завершення книги, сам автор оцінює в 20 років безперервної щоденної роботи. Оскільки Кнут завжди вважав «Мистецтво програмування» основним проектом свого життя, 1990 року він вийшов на пенсію, з наміром повністю сконцентруватися на написанні відсутніх частин і приведення до ладу існуючих. Історія Як визнаний експерт зі створення компіляторів, Кнут почав писати книгу для їх проектування 1962 року. Незабаром він усвідомив, що охоплення матеріалу має бути набагато ширшим. У червні 1965 року він завершив написання першої версії того, що він спочатку хотів видати однією книжкою з дванадцяти розділів. Обсяг рукописного тексту склав 3000 сторінок. За розрахунками Кнута, цей обсяг мав вміститися на 600 сторінках друкованого тексту, але, як повідомив йому його видавець, реальний обсяг склав би 2000 сторінок. У зв'язку з цим структуру книги було переглянуто на користь кількох томів, по 1-2 розділи кожен. Відтоді, у зв'язку з постійним зростанням матеріалу, було вирішено, що четвертий том також буде розбито на окремі книги: 4A, 4B, 4C, а можливо, і 4D. Але і цей поділ мабуть не буде остаточним, оскільки розділи 7,1 і 7.2.1 вже в сумі займають понад 650 сторінок. 1976 року Кнут підготував друге видання другого тому, що зажадало повторного набору. Але типографське оформлення, яке застосовувалося в першому виданні, на той час вже було недоступним. Щоб уникнути подібних прикростей у майбутньому, 1977 року Кнут почав розробляти власну типографську систему комп'ютерного набору. За його розрахунками, робота мала тривати не більше шести місяців, але знадобилося близько десяти років, перш ніж її було завершено. Система отримала назву TeX, і наразі застосовується для верстки всіх томів «Мистецтва програмування». Крім того, згодом, TeX став фактичним стандартом для написання статей та монографій з природничих наук. Як і інші книги Кнута, «Мистецтво програмування» відзначено його «фірмовим знаком»: за кожну помилку, знайдену в тексті, автор виплачує один шістнадцятковий долар, тобто $2,56 (0x100 центів, в системі числення за основою 16). Іншою відмітною особливістю книги є велика кількість вправ для самостійного виконання, різного ступеня складності, починаючи від простих задачок «для розігріву» і закінчуючи проблемами, вирішення яких взагалі невідомо. Складність кожної вправи оцінено за числовою шкалою від 0 до 50. Так, у ранніх виданнях оцінкою 50 було позначено Велику теорему Ферма, але в третьому виданні ця оцінка «девальвувала» до 45, оскільки на той час теорему вже було доведено. Зміст Початковий план написання книги припускав таку розбивку матеріалу. Том 1. Основні алгоритми. Розділ 1. Основні поняття. Розділ 2. Інформаційні структури. Том 2. Напівчисельні алгоритми. Розділ 3. Випадкові числа. Розділ 4. Арифметика. Том 3. Сортування і пошук. Розділ 5. Сортування. Розділ 6. Пошук. Том 4. Комбінаторні алгоритми. Розділ 7. Комбінаторний пошук. Розділ 8. Рекурсія. Том 5. Синтаксичні алгоритми. Розділ 9. Лексикографічний пошук. Розділ 10. Синтаксичний пошук. Том 6. Теорія мов. Том 7. Компілятори. Фактично ця схема була реалізована аж до третього тому включно. Наразі видано том 4А, який містить перші розділи 7 глави. Нові розділи планується спочатку видавати окремими випусками (приблизно по 128 сторінок), орієнтовно по два випуски на рік (перед виходом тому 4А подібним чином були видані випуски 0, 1, 2, 3 і 4). Машинно-орієнтована мова прикладів Приклади програм, наведені в книзі, використовують «MIX-асемблер», призначений для роботи на гіпотетичному MIX-комп'ютері. У третьому виданні морально застарілий MIX був замінений на MMIX, що має повноцінну RISC-архітектуру. Існує програмне забезпечення, що забезпечує емуляцію (M)MIX-машини на стандартних IBM-сумісних комп'ютерах. GNU Compiler Collection має можливість компіляції C/C++ коду на цільову архітектуру MMIX. Багатьох читачів відштовхує факт використання мови низького рівня, але Кнут вважає свій вибір виправданим, оскільки прив'язка до архітектури необхідна для того, щоб можна було точно судити про такі характеристики алгоритму, як швидкість, використання пам'яті та ін. Однак, внаслідок такого вибору, цільова аудиторія сильно звужується. Крім того, обмежується галузь її застосування як «книги рецептів» для програмістів-практиків, багато з яких не знають асемблера, а якщо і знають, то не відчувають бажання перекладати низькорівневі алгоритми з книги на мови високого рівня. Численні практичні керівництва, в яких той же матеріал викладається більш популярно, видають саме з цієї причини. Критика Основною рисою монографії Кнута, що вигідно відрізняє її від інших книг, присвячених програмуванню, є надзвичайно високо піднята планка якості матеріалу й академічності викладу, а також глибина аналізу розглянутих питань. Завдяки цьому вона стала справжнім бестселером і настільною книгою кожного професійного програміста. Журнал American Scientist включив «Мистецтво програмування» до списку 12 найкращих фізико-математичних монографій XX-го століття разом з роботами Дірака з квантової механіки, Ейнштейна з теорії відносності, Рассела і Уайтхеда з основ математики та деякими іншимиhttp://www-cs-faculty.stanford.edu/~knuth/taocp.html The Art of Computer Programming. Обкладинка третього видання першого тому книги містить цитату Білла Гейтса: «Якщо ви вважаєте себе справді добрим програмістом …, прочитайте „Мистецтво програмування“ Кнута … Якщо ви зможете зрозуміти всю цю працю, то вам, безумовно, слід надіслати мені резюме». Втім, фольклор приписує ці слова Стіву Джобсу. Видання Поточне видання: Volume 1: Fundamental Algorithms. Third Edition (Reading, Massachusetts: Addison-Wesley, 1997), xx+650pp. ISBN 0-201-89683-4 Volume 1, Fascicle 1: MMIX — A RISC Computer for the New Millennium. (Addison-Wesley, February 14, 2005) ISBN 0-201-85392-2 (will be in the fourth edition of volume 1) Volume 2: Seminumerical Algorithms. Third Edition (Reading, Massachusetts: Addison-Wesley, 1997), xiv+762pp. ISBN 0-201-89684-2 Volume 3: Sorting and Searching. Second Edition (Reading, Massachusetts: Addison-Wesley, 1998), xiv+780pp.+foldout. ISBN 0-201-89685-0 Volume 4A: Combinatorial Algorithms, Part 1 (Upper Saddle River, New Jersey: Addison-Wesley, 2011), xvi+883pp. ISBN 0-201-03804-8 Volume 4B: Combinatorial Algorithms, Part 2 (Upper Saddle River, New Jersey: Addison-Wesley, 2023), xviii+714pp. ISBN 0-201-03806-4 Див. також Вступ до алгоритмів Виноски Категорія:Програмування Категорія:Алгоритми Категорія:Дональд Кнут Категорія:Книги 1968 Категорія:Книги США Категорія:Англомовні книги Категорія:Нехудожні книги 1973 року"}
{"category": "Програмування", "title": "Мікрокод", "abstract": "Мікропрограма (також мікрокод англ. microcode) — програма на спеціалізованій, апаратно-залежній мові програмування, що реалізує керування процесором в системах з мікропрограмним керуванням.\nРозробники процесорів надають програмістам набір програмно доступних операцій, кожній з яких відповідає окрема інструкція мови асемблера. З точки зору програміста ці інструкції є атомарними — у програміста відсутні можливості відслідкувати деталі виконання кожної з таких інструкцій. З точки ж зору роботи процесора — у випадку мікропрограмної архітектури — кожна з таких інструкцій виконує декілька більш примітивних операцій — мікрооперацій, — таких як завантаження і обробка команди та операндів, запис результату, встановлення признаку результату (коду завершення) тощо.\nУ Енциклопедії кібернетики схема, що реалізує мікропрограмне керування, називається мікропрограмним автоматом.", "content": "Мікропрограма (також мікрокод ) — програма на спеціалізованій, апаратно-залежній мові програмування, що реалізує керування процесором в системах з мікропрограмним керуванням. Розробники процесорів надають програмістам набір програмно доступних операцій, кожній з яких відповідає окрема інструкція мови асемблера. З точки зору програміста ці інструкції є атомарними — у програміста відсутні можливості відслідкувати деталі виконання кожної з таких інструкцій. З точки ж зору роботи процесора — у випадку мікропрограмної архітектури — кожна з таких інструкцій виконує декілька більш примітивних операцій — мікрооперацій, — таких як завантаження і обробка команди та операндів, запис результату, встановлення признаку результату (коду завершення) тощо. У Енциклопедії кібернетики схема, що реалізує мікропрограмне керування, називається мікропрограмним автоматом. Реалізації Декілька мікрооперацій, що можуть бути виконані паралельно і одночасно, вміщують в окрему мікрокоманду, поля якої і визначають такі мікрооперації. Окрема мікрокоманда звичайно (але не обов'язково) виконується в продовж одного такта процесора. Різні інструкції потребують виконання різних мікрооперацій та різних мікрокоманд, так само операції вимагають різної кількості мікрокоманд і тому виконуються за різне число тактів. Наявність в процесорі можливостей паралельного і одночасного виконання мікрооперацій призводить до того, що окрема мікрокоманда включає кілька полів і тому виявляється досить «широкою» (32 — 72 біти і більше). В окремих процесорах з відносно «вузькими» мікрокомандами також застосовується поділ мікрокоманд на типи, при якому, в залежності від типу мікрокоманди, забезпечується її різна інтерпретація. При цьому мікрокоманди виявляються функціонально-орієнтованими на керування арифметико-логічним пристроєм, керування пам'яттю тощо. Як наслідок, такі мікрокоманди також можуть змінювати і довжину такта процесора. У більшості процесорів з мікрокодом він розміщується не в оперативній, а у спеціальній пам'яті мікрокоду з високою швидкодією (). У деяких процесорах мікрокод можна оновити програмно, інколи навіть з додаванням функціональності, що використовується операційною системою. Наприклад, в системі VM компанії IBM та її радянському клоні СВМ мікрокод реалізовував спеціальні системні інструкції (такі, як перемикання віртуальних машин). За відсутності мікропрограмної підтримки такі операції мали б бути реалізовані програмно і, відповідно, їх виконання потребувало би набагато більше часу. В більш загальному випадку можливість дозавантаження або зміни мікрокоду дозволяє виправляти знайдені помилки і додавати реалізацію нових інструкцій. Мікрокод також дозволяє налаштувати мікроархітектуру комп'ютера на емуляцію іншої (як правило, більш складної) архітектури. Інше використання термінології Окремі виробники комп'ютерної техніки (апаратного забезпечення), особливо IBM, використовують термін «мікрокод» як синонім термінові «прошивка» (вбудована програма; )http://www14.software.ibm.com/webapp/set2/firmware/gjsn IBM «Microcode downloads» (showing use of the term «microcode»). Навіть проста прошивка, наприклад та, що використовуються в жорсткому диску персонального комп'ютера, іноді описується як мікрокодhttp://download.boulder.ibm.com/ibmdl/pub/software/server/firmware/73lzx.html «Microcode Update for SCSI Hard Disk». Див. також Вбудована програма Мікроконтролер Мікропроцесор Паралелізм рівня пам'яті Паралелізм завдань Примітки Література Категорія:Програмування Категорія:Апаратне забезпечення"}
{"category": "Програмування", "title": "Мова моделювання", "abstract": "Мова моделювання — це будь-яка штучна мова, котра може використовуватися для вираження інформації (даних) або знань чи систем у структурі, і яка визначається послідовним набором правил. Правила застосовуються задля інтерпретації значення компонентів у структурі. В області інформатики та суміжних галузях керування даними або процесами, мови моделювання дозволяють розробникам програмного забезпечення, системним аналітикам чи системним архітекторам, визначати вимоги до організації або системи програмного забезпечення, а також до її структур та внутрішніх процесів, з вищим рівнем абстракції.", "content": "Мова моделювання — це будь-яка штучна мова, котра може використовуватися для вираження інформації (даних) або знань чи систем у структурі, і яка визначається послідовним набором правил. Правила застосовуються задля інтерпретації значення компонентів у структурі. В області інформатики та суміжних галузях керування даними або процесами, мови моделювання дозволяють розробникам програмного забезпечення, системним аналітикам чи системним архітекторам, визначати вимоги до організації або системи програмного забезпечення, а також до її структур та внутрішніх процесів, з вищим рівнем абстракції. Огляд Мовна модель може бути графічною чи текстовою. Мови графічного моделювання використовують діаграмну техніку з іменованими символами, які представляють концепції та лінії, що зв'язують символи та надають співвідношення і різні інші графічні позначення, для подання обмежень. Мови текстового моделювання, можуть використовувати стандартизовані ключові слова, супроводжувані параметрами або термінами та фразами природною мовою, щоб утворити вирази, які визначаються комп'ютером. Прикладом мови графічного моделювання та відповідної мови текстового моделювання, є EXPRESS. Не всі мови моделювання є виконуваними, і для тих, хто їх використовує, це не обов'язково означає, що програмісти більше не потрібні. Навпаки, виконувані мови моделювання, призначено для посилення продуктивності кваліфікованих програмістів, аби вони могли розв'язувати складніші питання, як-от паралельні обчислення та розподілені системи. Види мов моделювання Графічні типи Приклади мов графічного моделювання у галузі інформатики, керування проєктами та системної інженерії: Поведінкове Дерево — це формальна, графічна мова моделювання, що використовується переважно у системах та програмній інженерії. Зазвичай застосовується, щоб однозначно представляти сотні або навіть, тисячі вимог до природних мов, які зазвичай вживаються для вираження потреб зацікавлених сторін, щодо всеохопної інтегрованої системи програмного забезпечення. Позначення моделювання бізнес-процесів (BPMN та XML форма BPML) — це приклад мови моделювання процесу. Послідовно-керований технологічний ланцюжок (EPC) — це блок-схема для моделювання бізнес-процесів. EPC можна використовувати для налаштування системи планування ресурсів підприємства і поліпшення бізнес-процесів. Теорія C-K — складається з мови моделювання для процесів проєктування. DRAKON — це мова алгоритмічного моделювання загального призначення для визначення програмно-інтенсивних систем, схематичного представлення алгоритму або поетапного процесу, та сімейство мов програмування. EXPRESS та EXPRESS-G (ISO 10303-11) — це міжнародна стандартна мова моделювання даних загального призначення. Мова розширеного корпоративного моделювання (EEML) — зазвичай використовується для моделювання бізнес-процесів на декількох рівнях. Блок-схема — являє собою схематичне зображення алгоритму або поетапного процесу. Основи моделювання фундаментальних концепцій (FMC) для програмно-інтенсивних систем. IDEF — це сімейство мов моделювання, яке містить IDEF0 для функціонального моделювання, IDEF1X для інформаційного моделювання, IDEF3 для моделювання бізнес-процесів, IDEF4 для об'єктно-орієнтованого програмування та IDEF5 для моделювання онтологій. Jackson Structured Programming (JSP) — це спосіб структурного програмування на основі відповідності структури потоку даних і структури програми. LePUS3 — це об'єктно-орієнтований візуальний дизайн опису мови та формальна мова специфікації, яка підходить, перш за все, для моделювання великих об'єктно-орієнтованих (Java, C ++, C #) програм і шаблонів проєктування. Object-Role Modeling (ORM) у галузі розробки програмного забезпечення — це метод концептуального моделювання і може бути використаний як інструмент аналізу інформації та правил. Мережі Петрі — використовують варіації лише на одному методі діаграм і топології, а саме на двочастковому графі. Простота його базового інтерфейсу користувача, легко забезпечувала широку підтримку інструментів протягом багатьох років, особливо стосовно перевірки моделі, графічного моделювання та досліду програмного забезпечення. Southbeach Notation — це мова візуального моделювання, що використовується для опису ситуацій з точки зору агентів, які вважаються корисними чи шкідливими з боку модельєра. Позначення показують, як агенти співдіють один з одним і чи ця взаємодія покращує або погіршує становище. Мова специфікації та опису (SDL) — це мова специфікації, спрямована на однозначну специфікацію та опис поведінки реактивних і розподілених систем. SysML — це мова моделювання специфічна для домену системотехніки, яка визначається як профіль UML (налаштування). Уніфікована мова моделювання (UML) — це мова моделювання загального призначення, яка є галузевим стандартом для визначення програмно-інтенсивних систем. UML 2.0, поточна версія, підтримує тринадцять різних діаграмних способів і має всеохопну підтримку інструментів. Сервісно-орієнтована модельна структура (SOMF) — це цілісна мова для проєктування моделей архітектури корпоративного рівня та рівня додатків у галузі архітектури підприємств, віртуалізації, сервіс-орієнтованої архітектури (SOA), хмарних обчислень тощо. Мова опису архітектури (ADL) — це мова, яка використовується для опису та представлення устрою архітектури системи. AADL (AADL) — це мова моделювання, котра підтримує ранні та повторювані аналізи архітектури системи, відносно критично важливих властивостей, за допомогою розширюваних позначень, структур інструментів та точно визначеної семантики. Приклади мов графічного моделювання в інших галузях науки. EAST-ADL — це спеціальна мова моделювання, присвячена проєктуванню автомобільних систем. Мова енергетичних систем (ESL) — мова, яка спрямована на моделювання відновлюваної енергетики та світової економіки. Текстові види Інформаційні моделі також, може бути виражено формалізованими природними мовами, як-от Gellish. Gellish має варіанти з природними мовами, скажімо формальна англійська Gellish і формальна голландська Gellish (Gellish Formeel Nederlands) тощо. Gellish Formal English — це мова представлення інформації, або мова семантичного моделювання, яка визначається в англійському словнику-таксономії Gellish (Gellish English Dictionary-Taxonomy), що має форму таксономії-онтології (аналогічно для голландців). Gellish Formal English, не лише підходить для виразу знань, вимог і словників таксономій та онтологій, а також для інформації про окремі речі. Всі ці дані виражаються однією мовою і тому можуть бути інтегровані, незалежно від того, чи зберігаються вони у центральних, розподілених або у федеративних базах даних. Інформаційні моделі у Gellish Formal English, складено з набору виразів Gellish Formal English, які використовують терміни з природною мовою та формалізовані вирази. Наприклад, географічна інформаційна модель, може складатися з низки формальних англійських виразів Gellish, як-от: - the Eiffel tower <is located in> Paris — Ейфелева вежа <розташована у> Парижі - Paris <is classified as a> city - Париж <класифікується як> місто тоді як інформаційні вимоги та знання може бути виражено, наприклад, так: - tower <shall be located in a> geographical area — вежу <розташовано у> географічному районі - city <is a kind of> geographical area - місто <є свого роду> географічним регіоном У таких виразах Gellish Formal English, застосовуються назви концептів (наприклад, «city») і вислови, що є способами зв'язків (наприклад, <is located in> і <is classified as a>), які мусять бути вибрані з Gellish English Dictionary-Taxonomy (або вашого власного словника домену). Англійський словник-таксономія Gellish, дозволяє створювати семантично багаті інформаційні моделі, оскільки він містить більше 600 стандартних типів зв'язків і має визначення більше 40000 положень. Інформаційна модель у Gellish, може виражати факти або виробляти твердження, запити та відповіді. Більш конкретні види В галузі інформатики згодом з'явилися більш конкретні типи мов моделювання. Алгебраїчна Мови алгебраїчного моделювання (AML) — це мови програмування високого рівня для опису та вирішення завдань високої складності для громіздких математичних обчислень. Однією з особливих переваг AML, як-от: AIMMS, AMPL, GAMS, LPL, MPL, OPL і OptimJ, є подібність їх синтаксису з математичним позначенням завдань оптимізації. Це дозволяє отримати дуже стисле та зрозуміле визначення проблем у галузі оптимізації, яке підтримується деякими мовними елементами, як-от набори, показники, алгебраїчні вирази, потужні розріджені змінні індексів і обробки даних, обмеження з довільними іменами. Алгебраїчне формулювання моделі не містить ніяких підказок, як його обробляти. Поведінкова Поведінкові мови призначені для опису спостережуваної поведінки складних систем, що збираються зі складових, які виконуються одночасно. Ці мови зосереджено на описі ключових визначень, наприклад: паралелізм, недетермінізм, синхронізація та зв'язок. Семантичні основи поведінкових мов — це обчислення або алгебра процесів. Предметно-специфічна Мова моделювання, заснована на дисципліні (DspM), орієнтована на підсумки, пов'язані з проміжком життєвого циклу певної розробки програмного забезпечення. Таким чином, ця мова пропонує відмінну лексику, синтаксис та позначення для кожного етапу, скажімо: виявлення, аналіз, дизайн, архітектура, стиснення тощо. Наприклад, щодо етапу аналізу проєкту, модельєр використовує специфічну нотацію аналізу для доправлення діаграми аналітичної пропозиції. Однак, на етапі проєктування, логічне позначення дизайну, використовується для опису взаємодії між об'єктами програмного забезпечення. Водночас, практичні поради з мови моделювання, притаманні для конкретної дисципліни, не перешкоджають практикам поєднувати різні позначення на одній діаграмі. Предметно-орієнтовані Моделювання доменних імен (DSM) — це методологія розробки програмного забезпечення для проєктування і створення систем — найчастіше це ІТ-системи, як-от комп'ютерне програмне забезпечення. Це передбачає систематичне використання графічної мови, специфічної для домену (DSL), щоби представляти різні грані системи. Мови DSM, мають властивість підтримувати абстракції вищого рівня, ніж мови моделювання загального призначення, тож вони потребують менше зусиль та деталей низького рівня, для позначення даної системи. Див. також Інтерфейс користувача Мова програмування Людино-машинна взаємодія Інтерфейс командного рядка Графічний інтерфейс користувача AIMMS General Algebraic Modeling System Імітаційне моделювання Візуальне програмування Джерела Xiao He (2007). «A metamodel for the notation of graphical modeling languages». In: Computer Software and Applications Conference, 2007. COMPSAC 2007 — Vol. 1. 31st Annual International, Volume 1, Issue , 24–27 July 2007, pp 219—224 Посилання PhD: Gellish: a Generic Extensible Ontological Language Service-Oriented Modeling: Service Analysis, Design, and Architecture modeling-languages.com Fundamental Modeling Concepts Категорія:Наукове моделювання Категорія:Програмування"}
{"category": "Програмування", "title": "Мова програмування", "abstract": "Мо́ва програмува́ння (англ. Programming language) — це штучна мова, створена для передачі команд машинам, зокрема комп'ютерам. Мови програмування використовуються для створення програм, які контролюють поведінку машин, та для запису алгоритмів.\nСуворіше визначення: мова програмування — це система позначень для опису алгоритмів і структур даних, певна штучна формальна система, засобами якої можна виражати алгоритми. Мову програмування визначає набір лексичних, синтаксичних і семантичних правил, що задають зовнішній вигляд програми та дії, які виконує виконавець (комп'ютер) під її управлінням.\nЗ часу створення перших програмованих машин було створено понад дві з половиною тисячі мов програмування. Щороку до них додаються нові. Деякими мовами вміє користуватись тільки невелике число їхніх розробників, інші стають відомі мільйонам людей. Професійні програмісти зазвичай застосовують у своїй роботі декілька мов програмування.", "content": "Мо́ва програмува́ння () — це штучна мова, створена для передачі команд машинам, зокрема комп'ютерам. Мови програмування використовуються для створення програм, які контролюють поведінку машин, та для запису алгоритмів. Суворіше визначення: мова програмування — це система позначень для опису алгоритмів і структур даних(Пратт, розділ І), певна штучна формальна система, засобами якої можна виражати алгоритми(Gabrielli, С. 27). Мову програмування визначає набір лексичних, синтаксичних і семантичних правил, що задають зовнішній вигляд програми та дії, які виконує виконавець (комп'ютер) під її управлінням.Скляр І. В. Алгоритмізація та програмування. Навчально-методичний посібник ISBN 966-8651-90-1 З часу створення перших програмованих машин було створено понад дві з половиною тисячі мов програмування . Щороку до них додаються нові. Деякими мовами вміє користуватись тільки невелике число їхніх розробників, інші стають відомі мільйонам людей. Професійні програмісти зазвичай застосовують у своїй роботі декілька мов програмування. Означення Мова програмування — це нотація для запису програм, які є специфікаціями якогось обчислення або алгоритму. Історія thumb|250пкс|Підручники мов програмування Перші мови програмування з'явилися задовго до появи перших комп'ютерів. Ще в XIX столітті існували «програмовані» ткацькі верстати та піаніно-програвачі, спосіб програмування яких нагадує так звані предметно-орієнтовані мови програмування. На початку XX століття починають використовувати перфокарти та механічну обробку даних. У 1930—1940 рр. виникає лямбда-числення та машина Тюринга, які застосовували математичну абстракцію для опису алгоритмів. Лямбда-числення згодом здійснило вплив на проєктування мов програмуванняBenjamin C. Pierce writes: «… the lambda calculus has seen widespread use in the specification of programming language features, in language design and implementation, and in the study of type systems.» . У 1940 роках створюються перші електричні двійкові комп'ютери. Вважається, що першу мову програмування високого рівня — Планкалькюль () розробив німець Конрад Цузе в період 1943—1945 років, але в той час вона не була реалізована і нею не зацікавилися. Реалізацією мови зайнялися і здійснили її лише в 1998—2000 рокахRojas, Raúl, et al. (2000). «Plankalkül: The First High-Level Programming Language and its Implementation». Institut für Informatik, Freie Universität Berlin, Technical Report B-3/2000. (full text) . Наприкінці 1940-х — початку 1950-х років застосовували інтерпретовані системи кодування, коли певні команди мови програмування кодували числами, які вже інтерпретувалися машинним кодом. Ці системи називалися «автоматичним програмуванням» і були простішими для програмування, ніж машинні коди, але могли мати значно меншу (до 50 разів) швидкодію, через що перевагу часто надавали машинним кодам. До таких систем належали — Short Code для BINAC (1949) і UNIVAC I (1952), для IBM 701, розроблена Джоном Бекусом у 1954 році. Першою багатоконцептуальною (імперативною та декларативною) мовою програмування високого рівня була Адресна мова програмування (реалізована 1955 року на ЕОМ «Київ»). Мова має опосередковану адресацію вищих рангів (вказівники є аналогом). В ЕОМ «Київ» апаратно була реалізована «штрих-операція», аналогом якої є розіменування вказівників. Операція багаторазового розіменування вказівників (Multiple indirection) була реалізована груповими операціями модернізації адрес задля прискорення обробки деревоподібних форматів (Абстрактні типи даних є частковим випадком, оскільки деревоподібні формати припускають наявність у вузлах «дерева» процедур обробки даних, як в ООП). Адресна мова програмування має вичерпні засоби декларативного програмування. До найпотужнішого декларативного засобу належить «мінус штрих-операція», яка є оберненою до розіменування вказівника. Використання «мінус штрих-операції» нагадує використання первинних і зовнішніх ключів в реляційних базах даних: по заданому первинному ключу визначити місце розташування (адреси) в іншій таблиці, зовнішні ключі яких збігаються з заданим первинним ключем. Першою широковживаною компільованою мовою став розроблений групою Джона Бекуса Фортран, анонсований 1954 року та випущений 1957 року для IBM 704. Основним призначенням Фортрану були швидкі наукові обчислення, оголошувалося, що швидкодія згенерованого компілятором коду майже не відрізнятиметься від написаного вручну машинного коду. Уже у квітні 1958 року близько половини програм для IBM 704 були написані на Фортрані. Випущений 1958 року Фортран II дозволяв незалежну компіляцію підпрограм, що давало змогу створювати більші програми, оскільки через низьку надійність IBM 704 не можна було скомпілювати без збоїв велику програму (понад 300—400 рядків) одразу. Розроблений у 1960—1962 роках Фортран IV був однією з найпоширеніших мов того часу і лишався стандартною версією Фортрану до появи 1978 року Фортрану 77. 1958 року в MIT розробили LISP — першу функційну мову, яка понад чверть століття домінувала у програмуванні задач штучного інтелекту. Наприкінці 1950-х років почали розробляти різні мови програмування. 1958 року декілька значних груп комп'ютерних користувачів у США, включаючи SHARE — групу науковців-користувачів IBM і USE (UNIVAC Scientific Exchange, група науковців-користувачів UNIVAC) запропонували ACM заснувати робочу групу зі створення універсальної мови програмування. Також ще 1955 року німецьке Товариство прикладної математики й механіки (GAMM) заснувало комітет зі створення універсальної мови програмування. У кінці травня 1958 року було проведено зустріч у Цюриху між ACM і GAMM, на матеріалах якої у грудні опубліковано ALGOL 58 Report. На його основі було створено 3 значні реалізації — MAD (1961), NELIAC (1963), JOVIAL (1963). З них лише JOVIAL отримав поширення, ставши на чверть століття офіційною мовою програмування у Військово-морських силах США. SHARE та IBM почали створення власної реалізації ALGOL, але припинили, врахувавши витрати на створення і просування Фортрану. Упродовж 1959 року ALGOL 58 широко обговорювався, була запропонована нотація для опису синтаксису мов програмування — форма Бекуса — Наура. 1960 року проведено чергову зустріч і опубліковано ALGOL 60 Report. ALGOL вплинув на багато мов програмування і став стандартною мовою для публікації алгоритмів, але через ряд причин не одержав широкого розповсюдження — він був заскладним, і не було реалізацій, які підтримували його повністю, відсутність стандартного введення-виведення зумовила появу різних несумісних реалізацій, деякі неоднозначності опису мови так і не були розв'язані. Окрім того, широкого вжитку уже набув Фортран, і IBM не підтримала ALGOL. 1959 року було проведено зустріч у Пентагоні для створення мови CBL (Common Business Language), засновано комітет з її створення, і 1960 року опубліковано початкову специфікацію COBOL 60, який невдовзі став першою мовою, ухваленою у Міністерстві оборони США. 1968 року COBOL було стандартизовано ANSI. У 1964 році було створено спрощену мову BASIC (Beginners All-purpose Symbolic Instruction Code) для навчання програмуванню студентів, які переважно спеціалізувалися у вільних мистецтвах, а не технічних науках. Тоді як науковці переважно використовували Фортран, а бізнес — COBOL, 1963 року в IBM вирішили створити універсальну платформу IBM/360 і мову програмування. У стислі терміни до 1965 року було розроблено мову PL/I, яка поєднувала можливості Фортрану, ALGOL і COBOL, і виявилась заскладною, хоча і була у широкому вжитку в 1970-х у наукових і бізнес-задачах, також її підмножини (PL/C, PL/CS) використовувалися для навчання програмуванню. На початку 1960-х років було створено перші мови із динамічною типізацією — APL і SNOBOL. SIMULA 67 була першою об'єктно-орієнтованою мовою програмування. 1965 року Ніклаус Вірт і Тоні Гоар запропонували комітету з розвитку мови ALGOL свою версію, яку згодом назвали ALGOL-W і застосовували для навчання в деяких університетах. Пропозиція була відхилена через незначну кількість змін на користь значно складнішого ALGOL 68. У ALGOL 68 з'явилися визначення структур даних і динамічні масиви. ALGOL 68 став першою мовою із формальною специфікацією, яка, однак, була складною для розуміння. 1971 року Вірт опублікував опис мови Pascal, яка у 1970-х стала загальновживаною для навчання студентів. 1972 року Деніс Річі розробив у Bell Labs мову C. Тоді ж у Марселі створено інтерпретатор мови Пролог — першої і найвідомішої мови логічного програмування. Алан Кей у Xerox PARC розробив першу широко вживану об'єктно-орієнтовану мову — Smalltalk. 1973 року Робін Мілнер в Единбурзькому університеті створив ML. 1975 року в Массачусетському технологічному інституті описано спрощений діалект мови Лісп — Scheme. 1976 року випущено мову для статистичного програмування S, на базі якої 1993 року створено R. 1977 року випущено Bourne shell і awk. 1975 року Міністерство оборони США утворило міжнародну групу для створення нової мови програмування для власних потреб, конкурс 1979 року виграла мова Ада. 1981 року випущено dBASE II. 1984 року з метою об'єднання різних діалектів Ліспу створено Common Lisp. Випущено MATLAB 1985 року Б'ярн Страуструп опублікував реалізацію мови C++. 1986 року опубліковано мову Objective-C і створено Erlang. Тоді ж Borland і Apple незалежно створили об'єктно-орієнтоване розширення мови Pascal — Object Pascal. 1987 року створено Perl. 1990 року опубліковано Standard ML і Haskell. 1991 року створено Visual Basic і опубліковано Python. 1992 року випущено Oracle 7 з підтримкою PL/SQL 1993 року створено Lua. 1995 року Sun Microsystems випустила Java, Netscape — JavaScript, тоді ж створено PHP і Ruby. 1996 року створено OCaml. 2001 року створено C#. 2002 року створено F#. 2003 року створено Scala. 2009 року створено Go. 2010 року створено Kotlin. 2010 року була офіційно представлена мова програмування Rust на Mozilla Summit 2010. Роботу над мовою Грейдон Гоар розпочав ще 2006 року. 2012 року створено Elm. 2012 року створено Elixir. 2014 року на конференції розробників WWDC 2014 було представлено мову Swift. 2014 року презентовано перший офіційний реліз мови програмування Crystal. Елементи Синтаксис Синтаксис мови програмування визначає те, як буде виглядати програма цією мовою, зокрема, як пишуться оператори, оголошення й інші мовні конструкціїПратт Т., Зелкович М.- C. 42. Наприклад, оголошення масиву V з десяти елементів у форматі цілих чисел у мові С буде виглядати так: int V[10]; На мові Pascal: V: array[0..9] of integer; Семантика Термін семантика стосується значення мови, на відміну від її форми (синтаксису). Наприклад, термін «семантика оператора» означає дію, яку виконує оператор під час виконання програми. Таким чином, семантика мови програмування — це сукупність семантик окремих елементів, дозволених синтаксисом мови. Статична семантика Статична семантика описує обмеження на структуру текстів мови які важко або неможливо виразити звичайними структурними формалізмами. Для компільованих мов, статична семантика, по суті, це правила які можуть бути перевіреними на етапі компіляції. Наприклад перевірка того що кожен ідентифікатор задекларований до того як використовується (в мовах які потребують таких декларацій) або що варіанти в операторі switch різніMichael Lee Scott, Programming language pragmatics, Edition 2, Morgan Kaufmann, 2006, ISBN 0-12-633951-1, p. 18–19. Багато важливих обмежень цього типу, такі як перевірка використання ідентифікатора в правильному контексті (наприклад заборона додавання чисел до функцій), або що виклики підпрограма мають правильну кількість і типи аргументів можуть бути забезпеченні визначенням їх як правил логіки яка називається системою типізації. Інші форми статичного аналізу, такі як також можуть бути частиною статичної семантики. Такі мови програмування як Java та С# мають як частину своєї статичної семантики — форму аналізу потоку даних. Динамічна семантика Коли дані описані, комп'ютер має отримати інструкції щось робити з даними. Наприклад, семантика може описувати стратегії обчислення за якими отримуються значення виразів, або спосіб яким інструкції визначають потік керування. Динамічна семантика мови (також відома як семантика виконання, ) визначає як і коли різні конструкції мови повинні задавати поведінку програми. Існує багато способів задання семантики виконання. Для опису семантики виконання мов, які часто застосовуються на практиці, використовується природна мова. Велика частина досліджень мов програмування стосується формальної семантики мов програмування. Типи даних Область зберігання даних в апаратній частині комп'ютера (пам'ять, регістри та зовнішні запам'ятовувальні пристрої) зазвичай мають доволі просту структуру в вигляді послідовності бітів, згрупованих в байти або слова. Проте в віртуальному комп'ютері, як правило, організовано складнішим чином — в різні моменти виконання програми використовуються такі форми зберігання даних, як стеки, масиви, числа, символьні рядки та інші. Один або декілька однотипних елементів даних, об'єднаних в одне ціле в віртуальному комп'ютері в певний момент виконання програми, заведено називати об'єктом даних. При виконанні програми існує багато об'єктів даних різних типів. Тип даних — це деякий клас об'єктів даних разом з набором операцій для створення і роботи з нимПратт Т., Зелкович М. 2002- С.186. В кожній мові програмування є певний набір вбудованих примітивних типів даних. Додатково в мові можуть бути передбачені засоби, що дозволяють програмісту визначати нові типи даних. Класифікація мов програмування Мови класифікують за такими критеріями: Рівень абстракції Мови програмування високого рівня оперують сутностями ближчими людині, такими як об'єкти, змінні, функції. Мови програмування нижчого рівня оперують сутностями ближчими машині: байти, адреси, інструкції. Текст програми мовою високого рівня зазвичай набагато коротший ніж текст такої самої програми мовою низького рівня, проте програма має більший розмір. Ділянка застосування Універсальні та спеціалізовані. Спеціалізовані мови теж бувають Тюрінг-повні, та все ж їх ділянка застосування обмежена, як, наприклад, у мови shell. Підтримувані парадигми програмування Об'єктно-орієнтовані, логічні, функційні, структурні… Імперативні мови ґрунтуються на ідеї змінної, значення якої змінюється присвоєнням. Вони називаються імперативними ( — наказовий), оскільки складаються із послідовностей команд, які звичайно містять присвоєння змінних <code><назва_змінної> = <[[вираз]]></code>, де вираз може посилатися на значення змінних присвоєних попередніми командами. Способи реалізації мов Мови програмування можуть бути реалізовані як компільовані та інтерпретовані. Програма компільованою мовою за допомогою компілятора (особливої ​​програми) (компілюється) в машинний код (набір інструкцій) для даного типу процесора, що записується у об'єктний модуль. З одного або кількох об'єктних файлів компонувальник формує виконуваний файл, який може бути запущений на виконання як окрема програма. Іншими словами, компілятор переводить вихідний текст програми з мови програмування високого рівня в двійкові коди інструкцій процесора. Якщо програма написана скриптовою мовою, то інтерпретатор безпосередньо виконує (інтерпретує) вихідний текст без попереднього перекладу. При цьому програма залишається мовою оригіналу і не може бути запущена без інтерпретатора. Процесор комп'ютера, у зв'язку з цим, можна назвати інтерпретатором для машинного коду. Поділ на компільовані і інтерпретовані мови є умовним. Так, для будь-якої традиційно компіляційної мови, як, наприклад, Паскаль, можна написати інтерпретатор. Крім того, більшість сучасних «чистих» інтерпретаторів не виконують конструкції мови безпосередньо, а компілюють їх в деяке високорівневе проміжне представлення (наприклад, з розіменуванням змінних і розкриттям макросів). Для будь-якої інтерпретувальної мови можна створити компілятор — наприклад, мова Лісп, початково інтерпретована, може компілюватися без обмежень. Створюваний під час виконання програми код може так само динамічно компілюватися під час виконання. Як правило, скомпільовані програми виконуються швидше і не вимагають для виконання додаткових програм, оскільки вже переведені на машинну мову. Разом з тим, при кожній зміні тексту програми потрібно її перекомпіляція, що уповільнює процес розробки. Крім того, скомпільована програма може виконуватися тільки на тому ж типі комп'ютерів і, як правило, під тією ж операційною системою, на яку був розрахований компілятор. Щоб створити виконуваний файл для машини іншого типу, потрібна нова компіляція. Інтерпретовані мови володіють деякими специфічними додатковими можливостями (див. вище), крім того, програми на них можна запускати відразу ж після зміни, що полегшує розробку. Програма скриптовою мовою може бути найчастіше запущена на різних типах машин та операційних систем без додаткових зусиль. Однак інтерпретовані програми виконуються помітно повільніше, ніж компільовані, крім того, вони не можуть виконуватися без програми-інтерпретатора. Деякі мови, наприклад, Java та C#, перебувають між компільованими і інтерпретованими. А саме, програма компілюється не в машинну мову, а в машинно-незалежний код низького рівня, байт-код. Далі байт-код виконується віртуальною машиною. Для виконання байт-коду зазвичай використовується інтерпретація, хоча окремі його частини для прискорення роботи програми можуть бути трансльовані в машинний код безпосередньо під час виконання програми за технологією компіляції «на льоту» (Just-in-time compilation, JIT). Для Java байт-код виконується віртуальною машиною Java (Java Virtual Machine, JVM), для C# — Common Language Runtime. Подібний підхід у деякому сенсі дозволяє використовувати плюси як інтерпретаторів, так і компіляторів. Слід згадати, що є мови, які мають і інтерпретатор, і компілятор (Форт (Forth)). Процедури та функції Підпрограми діляться на процедури та функції: Синтаксично процедури та функції складаються з заголовка (що містить ключове слово procedure або function, ім'ям, за яким може слідувати опис передаваних параметрів в дужках, тип повертаного значення через символ двокрапки для функцій і крапки з комою для процедур), після заголовка слідує 'тіло', після якого ставиться символ ;. program mine(output); var i : integer; procedure print(var j: integer); function next(k: integer): integer; begin next := k + 1 end; begin writeln('Всього: ', j); j := next(j) end; begin i := 1; while i <= 10 do print(i) end. Тіло процедури, як і програми, своєю чергою може містити описи процедур і функцій. Таким чином, процедури і функції можуть бути вкладені один в одного як завгодно глибоко, при цьому тіло програми — саме верхнє в ланцюжку. Причому вміст секцій опису змінних, типів, констант, зовнішнього тіла (процедури, функції, програми), розташованих перед описом процедури/функції, доступні усередині неї. Також, в більшості діалектів з процедури можна звертатися до параметрів зовнішньої процедури. Услід за заголовком процедур/функцій замість тіла може поміщатися ключове слово forward, це робиться в тому випадку, якщо опис процедури/функції розташовується в програмі після її виклику, і пов'язано з підтримуваною в Паскалі можливістю компіляції програми за один прохід. Процедури відрізняються від функцій тим, що функції повертають якесь значення, а процедури — ні. Об'єктно-орієнтоване програмування Об'єктно-орієнтоване програмування (ООП) — це технологія створення складного програмного забезпечення, яке засноване на представленні програми у вигляді сукупності об'єктів, кожен з яких є екземпляром певного класу, а класи утворюють ієрархію зі спадкоємством властивостей. Основна перевага ООП — це значне спрощення процесів створення та модифікації програмних систем. Набагато легше маніпулювати 100 об'єктами, кожен з яких сам відповідає за свою поведінку і обробку даних пов'язаних з ним, ніж тисячами функцій розкиданих по різних модулях. Основні недоліки в ООП — це деяке зниження швидкодії через складнішу організацію програмної системи, а також, як правило, помітне збільшення об'єму бінарного коду (особливо при використанні стандартних бібліотек класів в невеликих програмах) через те, що більшість сучасних компіляторів і компонувальників не здатні виявити і видалити весь код, що доводиться на невживані класи, віртуальні методи і інші елементи ООП. Семантика мов програмування Існує кілька підходів до визначення семантики мов програмування. Найбільш широко поширені наступні три різновиди семантик: операційна, дериваційна (аксіоматична) і денотаційна (математична). При описі семантики в рамках операційного підходу зазвичай виконання конструкцій мови програмування інтерпретується за допомогою деякої уявної (абстрактної) ЕОМ. Дериваційна семантика описує наслідки виконання конструкцій мови за допомогою мови логіки і завдання перед- і постумов. Денотаційна семантика оперує поняттями, типовими для математики — множини, відповідності, а також судження, твердження та ін. Мови програмування низького рівня Перші комп'ютери доводилось програмувати двійковими машинними кодами. Проте програмувати таким чином — доволі трудомістке і важке завданняПам'ять ЕОМ і представлення інформації. Для спрощення цього завдання почали з'являтися мови програмування низького рівня, які дозволяли задавати машинні команди в зрозумілішому для людини вигляді. Для перетворення їх у двійковий код були створені спеціальні програми — асемблери. thumb|right|250px|Приклад машинного коду і представлення його на асемблері Прикладом мови низького рівня є мова асемблера. Мови низького рівня орієнтовані на конкретний тип процесора і враховують його особливості, тому для перенесення програми на асемблері на іншу апаратну платформу її потрібно майже цілком переписати. Певні відмінності є і в синтаксисі програм під різні компілятори. Щоправда, центральні процесори для комп'ютерів фірм AMD та Intel практично сумісні й відрізняються лише деякими специфічними командами. А ось спеціалізовані процесори для інших пристроїв, наприклад, відеокарт, телефонів містять суттєві відмінності. Переваги За допомогою мов низького рівня створюють ефективні й компактні програми, оскільки розробник отримує доступ до всіх можливостей процесора. Вади Програміст, що працює з мовами низького рівня, має бути високої кваліфікації, добре розуміти будову мікропроцесорної системи, для якої створює програму. Результівна програма не може бути перенесена на комп'ютер або пристрій з іншим типом процесора; часто труднощі виникають і при перенесенні програми для іншої операційної системи Значний час розробки великих і складних програм. Мови низького рівня, як правило, використовують для написання невеликих системних програм, драйверів пристроїв, модулів стиків з нестандартним обладнанням, програмування спеціалізованих мікропроцесорів, коли найважливішими вимогами є компактність, швидкодія і можливість прямого доступу до апаратних ресурсів. Мови програмування високого рівня Транслятори поділяються на: компілятори — перетворюють текст програми в машинний код, який можна зберегти і після цього використовувати уже без компілятора (прикладом є виконувальні файли з розширенням *.exe). інтерпретатори — перетворюють частину програми в машинний код, виконують і після цього переходять до наступної частини. При цьому щоразу при виконанні програми використовується інтерпретатор. Можна сказати є зрозумілішими людині, ніж комп'ютеру. Особливості конкретних комп'ютерних архітектур в них не враховуються, тому створені програми легко переносяться з комп'ютера на комп'ютер. Здебільшого достатньо просто перекомпілювати програму під певну комп'ютерну архітектурну та операційну систему. Розробляти програми на таких мовах значно простіше і помилок допускається менше. Значно скорочується час розробки програми, що особливо важливо при роботі над великими програмними проєктами. Наразі у середовищі розробників вважається, що мови програмування, які мають прямий доступ до пам'яті та регістрів або мають асемблерні вставки, потрібно вважати мовами програмування з низьким рівнем абстракції. Тому більшість мов, які вважалися мовами високого рівня до 2000-го року зараз вже такими не вважаються. Адресна мова програмування Фортран Кобол Алгол Pascal PascalABC Java C C++ Objective C Smalltalk C# Delphi Недоліком мов високого рівня є більший розмір програм у порівнянні з програмами мовою низького рівня. Сам текст програм мовою високого рівня менший, проте, якщо взяти у байтах, то код початково писаний на асемблері буде компактніший. Тому в основному мови високого рівня використовуються для розробок програмного забезпечення комп'ютерів, і пристроїв, які мають великий обсяг пам'яті. А різні підвиди асемблеру застосовуються для програмування інших пристроїв, де критичним є розмір програми. Покоління мов програмування Інколи в літературі та в інтернеті згадують про п'ять поколінь мов програмуванняВідеопрезентація на тему «Історія мов програмування», щоправда, даний поділ є спірним і суперечним. В професійній літературі з програмування доволі рідко згадують про покоління мов програмування, а більше зосереджуються на функціональній класифікації мов програмування. Крім того, саме віднесення певних мов до різних поколінь різниться у різних авторів. Поділ на покоління мов програмування почав поширюватись з появою високорівневих мов програмування і до того не застосовувався. Високорівневі мови програмування почали вважатися третім поколінням, асемблерні мови — другим, а машинний код — першим поколінням. Сучасні спроби класифікація мов на четверте і п'яте покоління проводяться різними авторами по різному по різних ознаках і різниця між мовами третього, четвертого та п'ятого покоління часто доволі нечітка. Крім того, багато компаній розробники мов програмування та середовищ програмування для них використовують маркетинговий хід проголошуючи певну мову (мову та інтегроване середовище розробки для неї) п'ятим поколінням. Див. також Комп'ютерна мова Програмування Мова моделювання Список мов програмування Система типізації Стандарт оформлення коду Теорія мов програмування Примітки Література Pratt T.W., Zelkovitz M.V. Programming languages, design and implementation (4th ed.). Prentice Hall, 2000 (Пратт Т., Зелкович М., Языки программирования: разработка и реализация.- Спб.: Питер, 2002.-688 с.) Robert W. Sebesta: Concepts of Programming Languages, 9th ed., Addison Wesley 2009. Посилання The Computer Language Benchmarks порівняння мов за швидкодією і використаними ресурсами Tiobe Index рейтинг мов програмування Форум програмістів україномовний форум програмістів Категорія:Статті, що повинні бути в усіх Вікіпедіях Категорія:Програмування"}
{"category": "Програмування", "title": "Модель станів і переходів", "abstract": "Модель станів і переходів — абстрактний автомат, використовується для дослідження обчислень. Модель складається із множини станів та переходів між станами.\nМоделі станів та переходів мають декілька відмінностей від скінченних автоматів:\n\nМоделі станів і переходів мають не обов'язково скінченну або зліченну кількість станів\nМоделі станів і переходів мають не обов'язково скінченну або зліченну множину переходів\nМоделі станів і переходів із скінченною кількістю станів та переходів можна представити у вигляді орієнтованих графів.\nІснує щонайменше два типи моделей станів і переходів: марковані та немарковані.", "content": "Модель станів і переходів — абстрактний автомат, використовується для дослідження обчислень. Модель складається із множини станів та переходів між станами. Моделі станів та переходів мають декілька відмінностей від скінченних автоматів: Моделі станів і переходів мають не обов'язково скінченну або зліченну кількість станів Моделі станів і переходів мають не обов'язково скінченну або зліченну множину переходів Моделі станів і переходів із скінченною кількістю станів та переходів можна представити у вигляді орієнтованих графів. Існує щонайменше два типи моделей станів і переходів: марковані та немарковані. Категорія:Програмування Категорія:Моделі обчислень"}
{"category": "Програмування", "title": "Налагодження програм", "abstract": "Нала́годження програ́ми\n\n, в мережі рідше знева́дження\n(англ. debugging) — методичний процес пошуку та зменшення числа помилок або дефектів у комп'ютерній програмі або електронному обладнанні з метою отримання очікуваної поведінки. Зневадження, як правило, ускладнюється, коли різні підсистеми міцно пов'язані між собою, оскільки зміни в одній частині можуть викликати помилки в іншій.\n\n", "content": "Нала́годження програ́ми Короткий тлумачний словник з інформатики та інформаційних систем для економістів / Л. С. Козловська, Н. М. Поліщук, К.: КНЕУ, 2004, С. 21: налагоджування (рос. налаживание, англ. debugging) — процес виявлення та усунення помилок у комп'ютерних програмах або обладнанні; Англо-український тлумачний словник з обчислювальної техніки, інтернету і програмування. К., 2006, С. 146: debugging — 1. налагодження # пошук і виправлення помилок у розроблюваній програмі. Коллін С. М. Г. Англо-український словник комп'ютерних термінів / Перекл. В. Воробйов. — Х., 2002. — С. 19: adjust (регулювати, настроювати); adjustment (регулювання настроювання); С. 126. debug (налагоджувати, усувати неполадки) дієсл. тестування програми для виявлення і виправлення всіх неполадок і помилок… debugger (налагоджувач, програма налагодження) ім. програмне забезпечення, що дозволяє програмістові знаходити несправності та помилки в програмі… Короткий англо-український тлумачний словник з комп'ютерної техніки / Укл. Р. Сіренко та ін. — Львів: ЛНУ, 2005. — С. 22: debugging — налагодження, пошук та виправлення помилок у програмі для комп'ютера. Саврук М. П. Українсько-англійський науково-технічний словник: понад 120 000 слів та словосполучень / НАН України, Фізико-механічний ін-т ім. Г. В. Карпенка. — К. : Наукова думка, 2008. — (Словники України). — С. 460—461: налагоджування, налагодження — (регулювання) adjustment; мат. setting-up; автотр. (двигуна, карбюратора) tune-up, tunung-up; комп. debugging, checkout; ~ верстата setting-up of a machine-tool; ~ двигуна engine tune-up; ~ ЕОМ (computer) debugging; ~ програми (programme) checkout / debugging/; автономне ~ off-line debugging; дистанційне ~ remote debugging; експлуатаційне ~ field adjustment; комплексне ~ complex debugging; покрокове ~ single-step debugging; попереднє ~ комп. prestage. Налагоджувач — комп. (програма) debugger; діалоговий ~ console /interactive/ debugger; моделювальний ~ simulation debugger; символьний ~ symbolic debugger. Тлумачний словник сучасної української мови: Фахова лексика: Бл. 20000 сл. / Заг. ред. В. Калашника. — Х, 2009. — С. 222—223: налагоджувач. У системах програмування — програма, призначена для аналізу функціонування та для налагоджування іншої програми. Тлумачний словник з інформатики / Заг. ред. акад. Г. Г. Півняка. — Д.: Нац. гірн. ун-т, 2010. — С. 68: debugger (налагоджувач) (див. дебаггер); Debugging (налагодження). Процес знаходження і виправлення помилок у програмі. С. 310: дебаггер (debugger) (див. баг) син. — налагоджувач, програма налагодження, налагоджувальна програма… С. 441: налагодження (debugging) (див. дебаггер) Процес виконання програми з метою виявлення помилок., в мережі рідше знева́дженняАнглійсько-український словник: Математика та кібернетика / Є. Мейнарович, М. Кратко — К.: Перун, 2010. — 560 с.: debugging = [ˌdi:'bʌgɪŋ] знева́джування/знева́дження, усува́ння/усу́нення вад; налаго́джування/налаго́дження; вилуча́ння/ви́лучення вад.У Вікіпедії цей менш поширений термін вживається за домовленістю дописувачів. () — методичний процес пошуку та зменшення числа помилок або дефектів у комп'ютерній програмі або електронному обладнанні з метою отримання очікуваної поведінки. Зневадження, як правило, ускладнюється, коли різні підсистеми міцно пов'язані між собою, оскільки зміни в одній частині можуть викликати помилки в іншій. Термінологія thumb|left|Сторінка з щоденника Грейс Гоппер Існують різні варіанти тлумачення походження терміна . Серед програмістів популярна легенда, що терміни «bug» та «debugging» першою вжила Ґрейс Гоппер у 1940-х рокахGrace Hopper з FOLDOC. Коли вона працювала на комп'ютері Mark II в Гарвардському університеті, її співробітники виявили, що міль застрягла в реле і тим самим призвела до збою в роботі комп'ютера. Грейс підклеїла в щоденник міль і написала, що це перший випадок в історії, коли жучка ( — жучок, комаха) виявили насправді (actual case). Сам запис свідчить про те, що слово баг у значенні помилки в програмі було вже відоме їй. Термін «bug» в сенсі технічної помилки вживався, принаймні ще в 1878 Томасом Едісоном, і «debugging», судячи з усього, використовувався як термін в аеронавтиці перед появою комп'ютерів. В Оксфордському словнику слово «debugging» з'явилося ще за два роки, до випадку з комахою. Слова bug і debugging у вузькому значенні помилки в програмі та процесу її виправлення утвердилися впродовж 50-х років, і на початку 60-х його вживання в літературі не потребувало додаткового пояснення. Більшість перекладних і тлумачних словників ще з радянських часів як відповідник до «debugging» вказують «налагоджування». Термін «зневадження» був запропонований О. Кочергою та Є. Мейнаровичем на початку 2000-х, імовірно, щоб уникнути неоднозначності з поняттям загального налагоджування програми. Вади Пошук і виправлення помилок, які програмісти називають багами, — трудомісткий процес. Програмістський напівжарт визначає цикл життя програми, як 1:3:1 (написання:налагодження:використання). Вади трапляються переважно через неуважність або втому програміста, але інколи через непродуманий до кінця алгоритм. Кількість багів зростає зі зростанням розміру програми, а з її ускладненням виникають нові помилки, пов'язані зі взаємодією та взаємовпливом різних модулів. Частина багів виправляється уже на етапі написання програми. Інша частина — після незалежного тестування. Зазвичай тестування, яке проводить користувач, який не знає механізму роботи програми, дозволяє виловити нові помилки, які програмісти не помічають, бо мають схильність робити тільки «правильні дії». Ще одна частина багів проявляється уже в роботі програми і потребує пізнього латання, чому служать патчі і сервісні пакунки. Засоби Пошук помилки в програмі, як правило, — тривале і клопітке завдання. Найважливішим чинником успішності та швидкості цього процесу є, мабуть, досвід програміста, але труднощі зі зневадженням програмного забезпечення також залежать значною мірою від мови програмування. Чимало середовищ розробки програмного забезпечення мають серед своїх інструментів спеціальну програму зневаджувач. Зневаджувач є програмним інструментом, який дозволяє програмісту контролювати виконання програми, зупиняти його, знову запускати, встановлювати точки зупинки, змінювати значення змінних у пам'яті й навіть, у деяких випадках, надає можливість повернутися в минуле. Термін зневаджувач може також стосуватися програміста. Мови програмування високого рівня, наприклад, Java, спрощують зневадження, оскільки мають спеціальні програмні засоби, як, наприклад, обробка виняткових ситуацій, що дозволяють швидше локалізувати помилку. У мов програмування нижчого рівня, таких як C або Асемблер, помилка в програмі часто може створити проблеми, що проявляються не зразу, такі, як пошкодження цілісності пам'яті, і їх набагато важче виявити, оскільки зовнішньо проблема може проявитися набагато пізніше і в несподіваній формі. В таких випадках, надзвичайно корисними є спеціальні програми на кшталт зневаджувача пам'яті. У деяких ситуаціях можуть бути дуже корисними програмні засоби загального призначення, що прив'язані до конкретної мови. Прикладом можуть бути інструменти статичного аналізу коду. Ці інструменти виконують пошук дуже конкретних відомих (поширених та рідкісних) проблем у тексті програми. Вони дозволяють знаходити помилки, які рідко фіксуються компілятором або транслятором, оскільки вони не синтаксичні, а семантичні. Наприклад, інструкція С if (x = foo()) bar(); підозріла. Можливо, програміст помилково використав присвоювання замість порівняння. Однак, вона є цілком легальною в С, і компілятор її пропустить. Деякі виробники таких інструментів стверджують, що їхні програми можуть виявити понад 300 різних потенційних проблем. Такі засоби можуть бути надзвичайно корисними при перевірці дуже великих обсягів сирцевого коду, коли дуже неефективно переглядати весь код чи відстежувати всі шляхи його виконання. Типовим прикладом виявленої проблеми може бути звернення до змінної до її ініціалізації. Іншим прикладом може бути суворіша перевірка типів, якщо мова такої не має. Таким чином, ці засоби є кращими для виявлення потенційних вад, на противагу фактичним вадам. Як наслідок, ці засоби мають високий рівень помилкового спрацьовування. Давня утиліта Unix lint є одним з найстаріших прикладів засобів такого типу. Для налагодження електронних пристроїв (наприклад, комп'ютерного обладнання), а також програмного забезпечення низького рівня (BIOS, драйвери пристроїв тощо) і вбудованих програм, застосовують такі інструменти, як осцилограф, аналізатор логіки, ICE, POST-контролери, які часто використовується і в комбінації. Вони можуть виконувати багато типових дій звичайних зневаджувачів для програмного забезпечення мікропроцесорних систем. Процес зневадження Відтворення помилки Часто перший крок зневадження полягає в тому, щоб спробувати відтворити проблему, тобто точно визначити ситуацію, коли програма працює неправильно. Випадок, коли програма працює неправильно завжди є відносно простим, але часто проблеми проявляються тільки при експлуатації, уже після того, як програма пройшла тестування, яке не може перевірити всі можливі ситуації. Відтворення проблеми може бути особливо нетривіальним завданням, наприклад, у випадку паралельних процесів або незвичайних помилок. Крім того, специфічне вживання програми користувачем, або незвичайне оточення може значно ускладнити відтворення проблеми. Після того, як помилку відтворено, потрібно виділити ту частину програми, де виникає збій, щоб працювати тільки з нею. Часто достатньо обмежитися тільки кількома рядами коду. Таке спрощення можна зробити вручну, за допомогою підходу «розділяй і володарюй». Програміст пробує вилучити деякі частини програми і перевіряє чи проблема все ще існує. При роботі з програмами, що використовують графічному інтерфейсі користувача, програміст спрощуватиме вікно програми, прибираючи контрольні елементи й перевіряючи, чи помилка все ще залишається. Для автоматизації цього процесу може використовуватися зневадження дельтоюZeller, p. 123.. Трасування Після того, як випробування випадку спрощено достатньо, програміст може розпочати пошук та виправлення помилки. Це можна робити або вручну, або з використанням зневаджувача. Поширеним є вставляння в програму додаткових інструкції, що регулярно роздруковували б інформацію про хід виконання програми. Такий метод називається трасуванням. У простих випадках трасування — лише декілька інструкцій виводу, що показує значення змінних в певних точках виконання програми. Наприклад, #ifdef DEBUG printf (\"Перед викликом foo x= %d\\n\", x); #endif x = foo(); #ifdef DEBUG printf (\"Після виклику foo x= %d\\n\", x); #endif Можна використати зневаджувач, який дає доступ до стану програми (значення змінних, стек викликів) і відстежити походження помилки. Якщо мова програмування використовує компілятор, то зазвичай у бінарному коді програми вже втрачено відповідність між інструкціями процесору та рядками тексту програми. Тому для зневаджувача програму потрібно відкомпілювати в спеціальному режимі, де така відповідність збережена. При цьому розмір бінарного файлу програми зростає, а її виконання сповільнюється. Після того як помилку знайдено й виправлено, відповідний файл потрібно відкомпілювати в звичайному режимі. Зазвичай, при розробці програмного забезпечення в інтегрованому середовищі режим зневадження використовується за умовчанням, а перед поставкою програмного забезпечення замовнику його відключають. Post mortem Іноді помилку можна знайти, аналізуючи дамп процесу. Таке зневадження називають посмертним (post mortem). Деякі операційні системи створюють дамп (відбиток пам'яті процесу) при аварійному завершенні програми, програміст може утворити його вручну, за потреби, наприклад командою dump операційної системи Unix. Для зіставлення пам'яті зі змінними програми бажано мати таблицю символів. В роботі допомагають спеціальні програми — аналізатори дампу. Дебаґери на зразок gdb теж можуть зчитати і проаналізувати дамп. Інші методи Шукати помилку можна, спостерігаючи за процесом з іншого комп'ютера. Для запуску віддаленого зневадження зневаджувач підключається до віддаленої системи через мережу. Після того, як зв'язок встановлено, зневаджувач може контролювати виконання програми на віддаленій системі та отримувати інформацію про її стан. Антизневадження Антизневадження є «застосування в комп'ютерному коді одного або декількох методів, що перешкоджають спробам зворотної розробки та зневадження цільового процесу». Види підходів: На основі API: перевірка на наявність зневаджувачів, використовуючи інформацію про систему На основі обробки виняткових ситуацій: перевіряється, чи йде перехоплення виняткових ситуацій Блокування процесів і потоків: перевіряється, чи були маніпуляції з блокуванням процесу або потоків Зміна коду: перевіряється чи були зміни в коді внесені зневаджувачем для обробки програмних точок зупину На основі обладнання та регістрів: перевіряються апаратні точки зупину і регістри процесора Час і латентність: перевіряється час виконання інструкцій Зневадження може бути перешкодою при використанні одного або кількох з вищезазначених методів. Є достатньо багато методів антизневадження для захисту програмного забезпечення від більшості загроз.((DOI | 10.1109/MSP.2007.71)) Примітки Література Andreas Zeller: Why Programs Fail: A Guide to Systematic Debugging, Morgan Kaufmann, 2005. ISBN 1-55860-866-4 Додаткові матеріали David J. Agans: Debugging: The Nine Indispensable Rules for Finding Even the Most Elusive Software and Hardware Problems, AMACOM, 2002. ISBN 0-8144-7168-4 Bill Blunden: Software Exorcism: A Handbook for Debugging and Optimizing Legacy Code, APress, 2003. ISBN 1-59059-234-4 Ann R. Ford, Toby J. Teorey: Practical Debugging in C++, Prentice Hall, 2002. ISBN 0-13-065394-2 Thorsten Grötker, Ulrich Holtmann, Holger Keding, Markus Wloka, The Developer's Guide to Debugging, Springer, 2008. ISBN 1-40205-539-0 Robert C. Metzger: Debugging by Thinking: A Multidisciplinary Approach, Digital Press, 2003. ISBN 1-55558-307-5 Glenford J Myers: *The Art of Software Testing, John Wiley & Sons inc, 2004. ISBN 0-471-04328-1 John Robbins: Debugging Applications, Microsoft Press, 2000. ISBN 0-7356-0886-5 Matthew A. Telles, Yuan Hsieh: The Science of Debugging, The Coriolis Group, 2001. ISBN 1-57610-917-8 Dmitry Vostokov: Memory Dump Analysis Anthology, Volume 1, OpenTask, 2008. ISBN 978-0-9558328-0-2 Посилання Algorithmic and Automatic Debugging — велика збірка посилань на засоби та методи зневадження Crash dump analysis patterns — ґрунтовна стаття по аналізу та знаходження вад в аварійних дампах Debugging Tools for Windows GDB: The GNU Project Debugger DDD/DataDisplayDebugger Див. також Метод каченяти Категорія:Програмування Категорія:Статті з прикладами коду мовою C"}
{"category": "Програмування", "title": "Наслідування (програмування)", "abstract": "Успадкування (англ. inheritance, „наслідування“ це помилкова назва, калькована з рос. наследование) — один з принципів об'єктно-орієнтовного програмування, який дає класу можливість використовувати програмний код іншого (базового) класу, доповнюючи його своїми власними деталями реалізації. Іншими словами, під час успадкування відбувається отримання нового (похідного) класу, який містить програмний код базового класу з зазначенням власних особливостей використання. Успадкування належить до типу is-a відношень між класами. При успадкуванні створюється спеціалізована версія вже наявного класу.\nВ Unified Modeling Language успадкування класів відображується на діаграми класів.", "content": "міні| Позначення наслідування на UML-діаграмі класів. Успадкування (, „наслідування“ це помилкова назва, калькована з рос. наследование) — один з принципів об'єктно-орієнтовного програмування, який дає класу можливість використовувати програмний код іншого (базового) класу, доповнюючи його своїми власними деталями реалізації. Іншими словами, під час успадкування відбувається отримання нового (похідного) класу, який містить програмний код базового класу з зазначенням власних особливостей використання. Успадкування належить до типу is-a відношень між класами. При успадкуванні створюється спеціалізована версія вже наявного класу. В Unified Modeling Language успадкування класів відображується на діаграми класів. Переваги використання успадкування Правильне використання механізму успадкування дає наступні взаємозв'язані переваги: ефективна побудова складних ієрархій класів з можливістю їх модифікації. Роботу класів в ієрархії можна змінювати шляхом додавання нових успадкованих класів в потрібному місці ієрархії; повторне використання раніше написаного коду з подальшою його модифікацією під поставлену задачу. Своєю чергою, новостворений код також може використовуватися на ієрархіях нижчих класів; зручність в супроводі (доповнені) програмного коду шляхом введення нових класів з новими можливостями; зменшення кількості логічних помилок при розробці складних програмних систем. Повторно використовуваний код частіше тестується, а, отже, менша ймовірність наявності в ньому помилок; легкість в узгодженні різних частин програмного коду шляхом використання інтерфейсів. Якщо два класи успадковані від загального нащадка, поведінка цих класів буде однакова у всіх випадках. Це твердження виходить з вимоги, що схожі об'єкти повинні мати схожу поведінку. Саме використання інтерфейсів зумовлює схожість поведінки об'єктів; створення бібліотек коду, які можна використовувати й доповнювати власними розробками; можливість реалізовувати відомі шаблони проєктування для побудови гнучкого коду, який не змінює попередніх розробок; використання переваг поліморфізму неможливо без успадкування. Завдяки поліморфізму забезпечується принцип: один інтерфейс — декілька реалізацій; забезпечення дослідницького програмування (швидкого макетування). Таке програмування використовується у випадках, коли цілі та потреби до програмної системи на початку нечіткі. Спочатку створюється макет структури, потім цей макет поетапно вдосконалюється шляхом успадкування попереднього. Процес триває до отримання потрібного результату; ліпше розуміння структури програмної системи програмістом завдяки природному представленню механізму успадкування. Якщо при побудові складних ієрархій намагатись використовувати інші принципи, то це може значно ускладнити розуміння усієї задачі та призведе до збільшення кількості помилок. Недоліки використання наслідування При використанні наслідування в програмах були помічені наступні недоліки: неможливо змінити успадковану реалізацію під час виконання; низька швидкість виконання. Швидкість виконання програмного коду загального призначення нижча, ніж у випадку використання спеціалізованого коду, який написаний конкретно для цієї задачі. Однак, цей недолік можна виправити завдяки оптимізації коду; великий розмір програм через використання бібліотек загального призначення. Якщо для деякої задачі розробляти вузькоспеціалізований програмний код, то цей код буде займати менше пам'яти ніж код загального призначення; збільшення складності програми у випадку неправильного або невмілого використання успадкування. Програміст зобов'язаний вміти коректно використовувати успадкування при побудові ієрархій класів. В іншому випадку це призведе до великого ускладненню програмного коду, і, як результат, збільшенню кількості помилок; складність засвоєння початковими програмістами основ побудови програм, які використовують успадкування. Однак, цей недолік умовний, бо залежить від досвіду програміста. Термінологія В об'єктно-орієнтованому програмуванні, починаючи з Simula 67, абстрактні типи данних називаются класами. Базовий клас () — це клас, який перебуває на вершині ієрархії успадкування класів і в основі дерева підкласів, тобто не є підкласом і не має успадкувань від інших суперкласів або інтерфейсів. Базовим класом може бути абстрактний клас і інтерфейс. Будь-який не базовий клас є підкласом. Суперклас (), батьківський клас (), предок або надклас — клас, від якого виконується успадкування в підкласах, тобто клас, від якого спадкують інші класи. Суперкласом може бути підклас, базовий клас, абстрактний клас і інтерфейс. Підклас (), похідний клас (), дочірній клас (), клас-нащадок або клас-реалізатор — клас, який спадкує від суперкласу або інтерфейсу, тобто клас визначений через успадкування від іншого класу або деяких таких класів. Підкласом може бути суперклас. Інтерфейс () — це структура, що визначає чистий інтерфейс класу, що складається з абстрактних методів. Інтерфейси беруть участь в ієрархії успадкування класів і інтерфейсів. Базовий інтерфейс () — це аналог базового класу в ієрархії успадкування інтерфейсів, тобто це інтерфейс, який перебуває на вершині ієрархії успадкування. Суперінтерфейс () або інтерфейс-предок — це аналог суперкласу в ієрархії успадкування, тобто від цього інтерфейсу виконується успадкування в підкласах і підінтерфейсах. Інтерфейс-нащадок або похідний інтерфейс () — це аналог підкласу в ієрархії успадкування інтерфейсів, тобто це інтерфейс, який спадкує від одного або декількох суперінтерфейсів. Ієрархія успадкування або ієрархія класів — дерево, елементами якого є класи та інтерфейси. Застосування Успадкування є механізмом повторного використання коду () і сприяє незалежному розширенню програмного забезпечення через відкриті класи () та інтерфейси (). Встановлення відношення успадкування між класами породжує . Типи успадкування «Просте» успадкування «Просте» успадкування, або одинарне успадкування, описує спорідненість між двома класами: один з яких спадкує від іншого. З одного класу може виводитися багато класів, але навіть в цьому випадку подібний вид взаємозвязку залишається «простим» успадкуванням. Абстрактні класи і створення об'єктів Для деяких мов програмування справедлива наступна концепція. Існують «абстрактні» класи (оголошуються такими довільно або через приписані до них абстрактні методи); їх можна описувати наявними поля та методи. Створення ж об'єктів (екземплярів) означає конкретизацію, застосовну тільки до неабстрактних класів (в тому числі, до неабстрактних нащадків абстрактних), — представниками яких, в результаті, будуть створені об'єкти. Множинне успадкування При множинному успадкуванні класа може мати більш, ніж одного предка. В цьому випадку клас успадковує методи всіх предків. Переваги такого підходу в більшій гнучкості. Множинне успадкування реалізовано в C++. З інших мов, що надають цю можливість, можна відмітити Python і Eiffel. Множинне успадкування підтримується в мові UML. Множинне успадкування — потенційне джерело помилок, які можуть виникати через наявність однакових імен методів у предків. В мовах, які позиціонуются як спадкоємці C++ (Java, C# та інші), було прийнято рішення відмовитись від множинного успадкування на користь інтерфейсів. Практично завжди можна обійтися без використання даного механізму. Однак, якщо така необхідність усе ж виникла, то для розв'язання конфліктів використання успадкованих методів з однаковими іменами можливо, наприклад, застосувати операцію розширення видимості — «::» — для виклику конкретного метода конкретного предка. Спроба вирішення проблеми наявності однакових імен методів в предках була здійснена у мові Eiffel, в якій при описі нового класу необхідно явно вказати імпортовані члени кожного з успадкованих класів і їхні імена у дочірньому класі. Більшість сучасних об'єктно-орієнтованих мов програмуння (C#, Java, Delphi та інші) підтримують можливість одночасно успадковувати від класа-предка і реалізовувати методи декількох інтерфейсів одним і тим самим класом. Цей механізм дозволяє багато в чому замінити множинне успадкування — методи інтерфейсів необхідно перевизначати явно, що виключає помилки при успадкуванні функціональності однакових методів різних класів-предків. Єдиний базовий клас В ряді мов програмування, усі класи, — явно або неявно, — успадковуються від деякого базового класу. Smalltalk був одним з перших мов, в яких використовувалась ця концепція. До таких мов також відносяться: Objective-C (NSObject), Perl (UNIVERSAL), Eiffel (ANY), Java (java.lang.Object), C# (System.Object), Delphi (TObject), Scala (Any). Успадкування в мовах програмування C++ Успадкування в C++:class A {}; // Базовий клас class B : public A {}; // Public-успадкування class C : protected A {}; // Protected-успадкування class Z : private A {}; // Private-успадкуванняВ C++ існує три типи успадкування: public, protected, private. Специфікатори доступу членів базового класу змінюються в потомках наступним чином: Якщо клас оголошено як базовий для іншого класу зі специфікатором доступу: public: public-члени базового класу — доступні як public-члени похідного класу; protected-члени базового класу — доступні як protected-члени похідного класу; protected: public- і protected-члени базового класу — доступні як protected-члени похідного класу; private: public- і protected-члени базового класу — доступні як private-члени похідного класу. Одним з основних переваг public-успадкування є те, що вказівник на класи-нащадки може бути неявно перетворений у вказівник на базовий клас, тобто для прикладу вище можна написати:A* a = new B();Ця цікава можливість відкриває можливість динамічної ідентифікації типу (RTTI). Delphi (Object Pascal) Для використання механізму наслідування в Delphi необхідно в оголошені класу в дужках class вказати клас предок: Предок:TAncestor = class private protected public //Віртуальна процедура procedure VirtualProcedure; virtual; abstract; procedure StaticProcedure; end;Наслідник:TDescendant = class(TAncestor) private protected public //Перекриття віртуальної процедуры procedure VirtualProcedure; override; procedure StaticProcedure; end;Абсолютно всі класи в Delphi є нащадками класа TObject. Якщо клас-предок не вказан, то мається на увазі, що новий клас є прямим нащадком класа TObject. Множинне наслідування в Delphi з самого початку не підтримується, однак для тих, кому без цього не обійтись, усе ж є такі можливості, наприклад, за рахунок використання класів-помічників(англ. Class Helpers). Python Python підтримує як одиночне, так і множинне успадкування. При доступі до атрибуту, перегляд похідних класів прохидить в порядку розширення метода (англ. method resolution order, MRO).class Ancestor1(object): # Предок-1 def m1(self): pass class Ancestor2(object): # Предок-2 def m1(self): pass class Descendant(Ancestor1, Ancestor2): # Наслідник def m2(self): pass d = Descendant() # Ініціалізація print d.__class__.__mro__ # Порядок розширення метода:(<class '__main__.Descendant'>, <class '__main__.Ancestor1'>, <class '__main__.Ancestor2'>, <type 'object'>)З версії Python 2.2 в мові існують «класичні» класи і «нові» класи. Останні є нащадками object. «Класичні» класи будуть підтримувати включно до версії 2.6, але видалені з мови в Python 3.0. Множинне успадкування застосовують у Python для введення в основний клас класів-домішок (англ. mix-in). PHP Для використання механізма наслідування в PHP необхідно в оголошенні класу після імені оголошеного класу-наслідника вказати слово extends і ім'я класу-предка:class Descendant extends Ancestor { }У випадку перекриття класом-нащадком методів предка доступ до методів предка можна отримати з використанням ключового слова parent:class A { function example() { echo \"Викликаний метод A::example().\\n\"; } } class B extends A { function example() { echo \"Викликаний метод B::example().\\n\"; parent::example(); } }Можна запобігти перекриття класом-нащадком методів предка; для цього необхідно вказати ключове слово final:class A { final function example() { echo \"Викликаний метод A::example().\\n\"; } } class B extends A { function example() { //викличе помилку parent::example(); //і ніколи не виконається } }Щоб при успадкуванні звернутись до конструктора батьківського класу, необхідно дочірньому класу в конструкторі вказати parent::__construct(); Objective-C @interface A : NSObject - (void) example; @end @implementation - (void) example { NSLog(@\"Class A\"); } @end @interface B : A - (void) example; @end @implementation - (void) example { NSLog(@\"Class B\"); } @endВ інтерфейсі оголошують методи, які буде видно ззовні класу (public). Внутрішні методи можна реалізовувати без інтерфейсу. Для оголошення додаткових властивостей користуються interface-extension у файлі реалізації. Усі методи в Objective-C — віртуальні. Java Приклад успадкування від одного класу і двох інтерфейсів:public class A { } public interface I1 { } public interface I2 { } public class B extends A implements I1, I2 { }Директива final в оголошені класа робить успадкування від нього неможливим. C# Приклад успадкування від одного класу і двох інтерфейсів:public class A { } public interface I1 { } public interface I2 { } public class B : A, I1, I2 { }Успадкування від типізованих класів можна здійснювати, вказавши фіксований тип або шляхом переносу змінної типу в успадкований клас:public class A<T> { } public class B : A<int> { } public class B2<T> : A<T> { }Допускається також успадкування вкладених класів від класів, які їх містять:class A // default class A is internal, not public class B can not be public (клас A за замовчуванням є внутрішнім, не публічний клас B не може бути публічним) { class B : A { } }Директива sealed в оголошені класа робить успадкування від нього неможливим. Ruby class Parent def public_method \"Public method\" end private def private_method \"Private method\" end end class Child < Parent def public_method \"Redefined public method\" end def call_private_method \"Ancestor's private method: \" + private_method end endКлас Parent є предком для класу Child, в якого перевизначений метод public_method.child = Child.new child.public_method #=> \"Redefined public method\" child.call_private_method #=> \"Ancestor's private method: Private method\"Приватні методи предка можна викликати з нащадків. JavaScript class Parent { constructor(data) { this.data = data; } publicMethod() { return 'Public Method'; } } class Child extends Parent { getData() { return `Data: ${this.data}`; } publicMethod() { return 'Redefined public method'; } } const test = new Child('test'); test.getData(); // => 'Data: test' test.publicMethod(); // => 'Redefined public method' test.data; // => 'test'Клас Parent є предком для класу Child, в якого перевизначений метод publicMethod. В JavaScript використовується прототипне успадкування. Конструктори і деструктори В С++ конструктори при успадкуванні викликаються почергово від першого предка до останнього нащадка, а деструктори навпаки — від останнього нащадка до першого предка.class First { public: First() { cout << \">>First constructor\" << endl; } ~First() { cout << \">>First destructor\" << endl; } }; class Second: public First { public: Second() { cout << \">Second constructor\" << endl; } ~Second() { cout << \">Second destructor\" << endl; } }; class Third: public Second { public: Third() { cout << \"Third constructor\" << endl; } ~Third() { cout << \"Third destructor\" << endl; } }; // виконання коду Third *th = new Third(); delete th; // результат виведення /* >>First constructor >Second constructor Third constructor Third destructor >Second destructor >>First destructor */ Див. також Поліморфізм (програмування) Інкапсуляція (програмування) Клас (програмування) Методи (програмування) Поля (програмування) Інтерфейс (програмування) Ієрархія UML Принцип підстановки Лісков Мови програмування Примітки Категорія:Об'єктно-орієнтоване програмування Категорія:Ruby Категорія:C++ Категорія:Java Категорія:JavaScript Категорія:Objective-C Категорія:Python Категорія:Комп'ютерні науки Категорія:Конструктори Категорія:Програмування Категорія:Клас (програмування) Категорія:Системи типізації"}
{"category": "Програмування", "title": "Нульовий вказівник", "abstract": "Нульовий (порожній) вказівник (рідше — покажчик) — вказівник, який нікуди не вказує. Використовується для того, щоб показати, що дана змінна-вказівник ні на що не посилається. У різних мовах програмування представлений різними константами, наприклад:\n\nУ машинних кодах: 0\nУ мовах Pascal, Clipper, Modula 2, Ruby, Lua та Go: nil\nУ C-подібних мовах: NULL\nУ мовах Java та C#: null\nУ мові Icon: &null\nУ мові Python: None\nУ мові Visual Basic: Nothing\nТоні Гоар, який винайшов нульовий вказівник у 1965 році, вважає це помилкою, яка імовірно коштувала мільярди доларів, оскільки спроба розіменування нульового вказівника зазвичай приводить до збою й припинення роботи програми.", "content": "Нульовий (порожній) вказівник (рідше — покажчик) — вказівник, який нікуди не вказує. Використовується для того, щоб показати, що дана змінна-вказівник ні на що не посилається. У різних мовах програмування представлений різними константами, наприклад: У машинних кодах: 0 У мовах Pascal, Clipper, Modula 2, Ruby, Lua та Go: nil У C-подібних мовах: NULL У мовах Java та C#: null У мові Icon: &null У мові Python: None У мові Visual Basic: Nothing Тоні Гоар, який винайшов нульовий вказівник у 1965 році, вважає це помилкою, яка імовірно коштувала мільярди доларів, оскільки спроба розіменування нульового вказівника зазвичай приводить до збою й припинення роботи програми. Особливості використання в різних мовах C та C++ Макрос NULL визначено у файлі <stddef.h>. ANSI C гарантує, що значення NULL еквівалентне 0, тому записи int *a, *b; a = NULL; b = 0; еквівалентні — вказівники a та b отримають однакове значення. На відміну від C в Паскалі, який є дуже суворим щодо типів, Nil в жодному випадку не еквівалентний числу 0. Java Мова програмування Java використовує null для позначення порожнього посилання. Також мова визначає так званий тип даних null. При спробі використання null замість реального об'єкта віртуальна машина створює виняткову подію типу java.lang.NullPointerException. Зокрема, ця подія виникає при: виклику динамічного метода об'єкта null. доступі або зміні поля об'єкта null. обчисленні довжини об'єкта null наче він є масивом. доступі або зміні комірок об'єкта null наче він є масивом. створенні виняткової ситуації з об'єктом null замість об'єкта типу Throwable. Додатки також можуть створювати виняткові ситуації типу NullPointerException за інших невірних використаннях об'єктів типу null. З огляду на численні проблеми, спричинені неправильною обробкою об'єктів null та досвіду використання деяких інших мов програмування в бібліотеці стандартних класів Java SE 8 версії був доданий контейнер Optional<T>. Об'єкти даного класу можуть містити значення типу null. Якщо контейнер містить непорожнє значення, тоді метод isPresent() поверне true а метод get() поверне це значення. Також цей контейнер пропонує низку додаткових методів, поведінка яких залежить від наявності непорожнього значення. Наприклад, метод orElse() повертає значення за замовченням при відсутності даних в контейнері, ifPresent() виконує блок коду за умови наявності даних в контейнері. Наприклад, якщо комп'ютер не має звукової карти і метод getSoundcard() повертає null, то при виконанні наступного коду: String version = computer.getSoundcard().getUSB().getVersion(); виникне виняткова ситуація типу NullPointerException при спробі викликати метод getUSB(). Проте, засобами контейнеру Optional<T> цей код може бути перетворений на безпечніший (після відповідного рефакторингу залучених типів даних): String version = computer.flatMap(Computer::getSoundcard) .flatMap(Soundcard::getUSB) .map(USB::getVersion) .orElse(\"UNKNOWN\"); унаслідок виконання якого змінна version матиме значення «UNKNOWN» за відсутності звукової карти. Примітки Див. також Вказівник Невизначена поведінка Посилання CWE-476: NULL Pointer Dereference Quora: What actually happens when dereferencing a NULL pointer? Категорія:Програмування Категорія:Ніщо Категорія:Типи даних Категорія:Статті з прикладами коду мовою C Категорія:Статті з прикладами коду мовою Java"}
{"category": "Програмування", "title": "Об'єкт першого класу", "abstract": "Об'єкт першого класу (також англ. First-class citizen, громадянин першого класу) — сутність, яка може бути побудована в рантаймі (під час виконання програми), передаватись як параметр, повертатись з підпрограми, або присвоюватись змінній. Цей термін придумав Крістофер Стречі в контексті «функції як громадяни першого сорту» в середині 1960-х років.", "content": "Об'єкт першого класу (також , громадянин першого класу) — сутність, яка може бути побудована в рантаймі (під час виконання програми), передаватись як параметр, повертатись з підпрограми, або присвоюватись змінній. Цей термін придумав Крістофер Стречі в контексті «функції як громадяни першого сорту» в середині 1960-х років. Визначення Об'єкти є об'єктами першого класу коли: можуть бути збережені в змінних і структурах даних можуть бути передані як параметр у підпрограму можуть бути повернуті в результаті роботи підпрограми можуть бути побудовані під час виконання мають внутрішню ідентичність (незалежно від імені) Приклади Слово об'єкт вживається тут не в сенсі ООП. Так, наприклад, скалярні об'єкти такі як цілі та числа з плаваючою крапкою майже в усіх мовах є об'єктами першого класу. В С та С++ функція не є об'єктом першого класу, тому що не може бути створена під час виконання програми. Об'єкти другого та третього класу Рафаель Фінкель пропонує визначення об'єктів другого та третього класу. Але його визначення об'єкта першого класу суперечить визначенням інших авторів: він не вимагає можливості створення під час виконання програми Дія Перший Другий Третій Передати значення як параметр Повернути значення з процедури Присвоїти значення змінній Посилання Категорія:Програмування"}
{"category": "Програмування", "title": "Обмін (інформатика)", "abstract": "О́бмін (англ. swap), в інформатиці — операція для обміну значень аргументів.\nНаприклад, якщо маємо дві змінні A та B, і стан пам'яті: A=1, B=2, то після виконання операції swap(A,B) стан пам'яті змінюється на такий: A=2, B=1.", "content": "О́бмін (), в інформатиці — операція для обміну значень аргументів. Наприклад, якщо маємо дві змінні A та B, і стан пам'яті: A=1, B=2, то після виконання операції swap(A,B) стан пам'яті змінюється на такий: A=2, B=1. Реалізації Очевидна реалізація використовує тимчасову змінну: TMP = A A = B B = TMP Існують реалізації без використання додаткової змінної, наприклад Алгоритм обміну XOR, або за допомогою арифметики: A = A + B B = A - B A = A - B В архітектурі x86 замість трьох інструкцій ассемблера MOV можна використовувати одну XCHG. Існує також додаткова інструкція CMPXCHG, яка атомарно виконує дві дії (порівняти і обміняти) і використовується для реалізації мютексів. Застосування В алгоритмах сортування, наприклад сортування обміном. В алгоритмах генерації всіх чи випадкових перестановок Див. також Вказівник Зноски Література Категорія:Програмування Категорія:Статті з прикладами коду мовою C++"}
{"category": "Програмування", "title": "Обфускація (програмне забезпечення)", "abstract": "Обфуска́ція (від лат. obfuscare — затіняти, затемнювати; англ. obfuscate — робити неочевидним, заплутаним, збивати з пантелику) або заплу́тування чи знечи́тнення коду — приведення початкового коду або виконуваного програмного коду до вигляду, який зберігає його функціональність, але ускладнює аналіз, розуміння алгоритму роботи і модифікації при декомпіляції.\n«Заплутування» коду може здійснюватися на рівні алгоритму, початкового коду та/або асемблерного коду. Для створення заплутаного асемблерного коду можуть використовуватися спеціалізовані компілятори, які використовують неочевидні або недокументовані можливості середовища виконання програми. Існують також спеціальні програми, що здійснюють обфускацію, які називаються обфуска́торами (англ. Obfuscator).", "content": "Обфуска́ція (від — затіняти, затемнювати; — робити неочевидним, заплутаним, збивати з пантелику) або заплу́тування чи знечи́тнення коду — приведення початкового коду або виконуваного програмного коду до вигляду, який зберігає його функціональність, але ускладнює аналіз, розуміння алгоритму роботи і модифікації при декомпіляції. «Заплутування» коду може здійснюватися на рівні алгоритму, початкового коду та/або асемблерного коду. Для створення заплутаного асемблерного коду можуть використовуватися спеціалізовані компілятори, які використовують неочевидні або недокументовані можливості середовища виконання програми. Існують також спеціальні програми, що здійснюють обфускацію, які називаються обфуска́торами (). Цілі обфускації Ускладнення декомпіляції/зневадження та вивчення програм з метою виявлення функціональності. Ускладнення декомпіляції пропрієтарних програм з метою запобігання зворотної розробки або обходу DRM і систем перевірки ліцензій. Порушення авторських прав програмістів і приховування авторства. Парадокс у тому, що використовується це переважно в пропрієтарних програмах. Оптимізація програми з метою зменшення розміру працюючого коду і (якщо використовується мова, яка не компілюється) прискорення роботи. Демонстрація неочевидних можливостей мови і кваліфікації програміста (якщо проводиться вручну, а не інструментальними засобами). Технології На рівні початкового коду На JavaScript, VBScript і подібних скрипт-мовах користувачу доступний початковий код програми. В цьому випадку форматуванням тексту й заміною імен можна зробити текст менш прочитним. Початковий код: int COUNT = 100; float TAX_RATE = 0.2; for (int i=0; i<COUNT; i++) { tax[i] = orig_price[i] * TAX_RATE; price[i] = orig_price[i] + tax[i]; } Код після обфускації: for(int a=0;a<100;a++){b[a]=c[a]*0.2;d[a]=c[a]+b[a];} На рівні машинного коду Зазвичай, обфускація на рівні машинного коду зменшує швидкість виконання і відповідно збільшує час виконання програми. Тому вона застосовується в критичних до безпеки, але не критичних до швидкості місцях програми, таких як перевірка реєстраційного коду. Найпростіший спосіб обфускації машинного коду — вставка в нього недіючих конструкцій (таких як or ax, ax ). На рівні проміжкового коду На відміну від звичайних мов, таких як C++ і Pascal, які компілюють в машинний код, мова Java, NetP і мови платформи .NET компілюють початковий код в проміжний код (байт-код), який містить досить інформації для адекватного відновлення початкового коду. З цієї причини, для цих мов застосовується обфускація проміжного коду. Призначення Ускладнення дослідження коду Як було сказано вище, декомпіляція програм Java і .NET досить проста. У цьому випадку обфускатор надає неоціненну допомогу тим, хто хоче приховати свій код від сторонніх очей. Найчастіше після обфускації декомпільований код повторно не компілюється. Обфускація HTML допомагає спамерам: на поштовому клієнті, що здатний відображати HTML, текст читається, але антиспам-фільтр, який має справу з джерельним HTML-файлом, пропускає небажане повідомлення, які не розпізнає в ньому забороненого рядка. Найпростіший приклад обфускованого HTML: <b>Євро</b><b>па</b> При перегляді користувач побачить слово «Європа», в той час як у початковому коді воно розчленоване і сприймається як два роздільних слова. Оптимізація В інтерпретованих мовах обфускований код займає менше місця, ніж початковий, і часто виконується швидше, ніж початковий. Сучасні обфускатори також замінюють константи числами, оптимізують код ініціалізації масивів, і виконують іншу оптимізацію, яку на рівні початкового тексту провести проблематично або неможливо. Проблема зменшення розміру важлива, наприклад, при програмуванні для стільникових телефонів на J2ME, де розмір програми серйозно обмежений. Обфускація JavaScript зменшує розмір HTML-файлів і, відповідно, прискорює завантаження. Недоліки Втрата гнучкості коду Код після обфускації може стати більш залежним від платформи або компілятора. Складності зневадження Обфускатор не дає сторонній особі з'ясувати, що робить код, але й не дає розробнику зневаджувати його. При зневадженні доводиться відключати обфускатор. Недостатня безпека Хоча обфускація допомагає зробити розподілену систему безпечнішою, не варто обмежуватися тільки нею. Обфускація — це безпека через приховування. Жоден з існуючих обфускаторів не гарантує складності декомпіляції і не забезпечує безпеки на рівні сучасних криптографічних схем. Цілком імовірно, що ефективний захист неможливий (принаймні в деякому конкретному класі вирішуваних завдань). Помилки в обфускаторах Сучасний обфускатор — складний програмний комплекс. Найчастіше в обфускатори, незважаючи на ретельне проектування і тестування, пролазять помилки. Так що є ненульова ймовірність, що код, який пройшовший через обфускатор взагалі не буде працювати. І чим складніше програма, що розробляється — тим більше ця ймовірність. Виклик класу за іменем Більшість мов з проміжним кодом можуть створювати або викликати об'єкти по іменах їх класів. Сучасні обфускатори дозволяють зберегти зазначені класи від перейменування, однак подібні обмеження скорочують гнучкість програм. Див. також Початковий код Компіляція CryptoNote Monero Код-спагеті Посилання Чєрнов А. В. Аналіз програм, які заплутують. Обфускація і її подолання. The International Obfuscated C Code Contest. Protecting Java Code Via Code Obfuscation, ACM Crossroads, Spring 1998 issue Protect Your Java Code — Through Obfuscators And Beyond , April 2009 Dotfuscator in Visual Studio on MSDN resource page — Visual Studio 2008 documentation for built-in .NET obfuscation Obfuscation tools for .NET, on MSDN — Obfuscation resources for .NET, on the Microsoft Developer Center. Can we obfuscate programs? Yury Lifshits. Lecture Notes on Program Obfuscation (Spring'2005) Analysis of the 12 days program Analysis of the obfuscated maze generating program Obfuscated Perl program with explanation Making C compiler generate obfuscated code Analysis of javascript code obfuscation Pseudo cycles insertion example Категорія:Початковий код Категорія:Програмування"}
{"category": "Програмування", "title": "Обхід дерева", "abstract": "Обхід бінарного дерева або пошук по дереву є одним з видів обходу графу, який передбачає відвідування (перевірку або модифікацію) кожної вершини дерева рівно один раз. Такі обходи класифікуються за порядком відвідування вершин. Хоч далі наведені алгоритми для двійкового дерева, але їх можна узагальнити для інших дерев.", "content": "Обхід бінарного дерева або пошук по дереву є одним з видів обходу графу, який передбачає відвідування (перевірку або модифікацію) кожної вершини дерева рівно один раз. Такі обходи класифікуються за порядком відвідування вершин. Хоч далі наведені алгоритми для двійкового дерева, але їх можна узагальнити для інших дерев. Види обходів дерев На відміну від пов'язаних списків, одновимірних масивів та інших лінійних структур даних, для яких існує канонічний обхід за допомогою лінійного порядку, дерева можна обходити у різні способи. Їх можна обходити вглиб або вшир. Існує три найпоширеніші способи їх проходження вглиб: прямий (pre-order), зворотній (post-order) та серединний (in-order). Окрім цих основних обходів, можливі різні складніші або гібридні схеми, такі як глибокі пошукові запити, подібні до ітеративного поглиблення глибинного пошуку. Останній, як і пошук вшир, також може бути використаний для обходу нескінченних дерев, див. нижче. Структури даних для обходу дерева Обхід дерева передбачає ітераційний перегляд усіх вузлів. Оскільки з довільного вузла можна потрапити до більше ніж одного можливого наступного вузла (оскільки, це не лінійна структура даних), то, припускаючи послідовне обчислення (не паралельне), деякі вузли повинні бути відкладені, тобто, збережені якимось чином для подальшого відвідування. Це часто робиться з використанням таких структур як стек (LIFO) або черга (FIFO). Оскільки дерево є структурою даних, яка визначена рекурсивно, то обхід може бути визначений за допомогою рекурсії або, що є більш витонченим, корекурсії, у природній і зрозумілий спосіб; при використанні рекурсії відкладені вузли неявно зберігаються у стеці викликів. Пошук вглиб легко реалізується через стек, в тому числі рекурсивно (через стек викликів), тоді як пошук вшир легко реалізується через чергу, в тому числі корекурсію. Пошук вглиб у двійковому дереві Такий пошук називаються пошуком вглиб (, DFS), оскільки по дереву пошуку просуваються максимально глибоко для кожного нащадка, перед тим, як перейти до наступного брата. Для двійкового дерева вони визначаються як операції доступу на кожному вузлі, починаючи з поточного вузла, алгоритм якого такий: Загальний рекурсивний підхід для обходу двійкового дерева такий: {| |- |colspan=\"2\"| Спустіться на один рівень до рекурсивного аргументу . Якщо існує (тобто, не є порожнім), то виконуються наступні три операції у певному порядку: |- |style=\"width:2em;\"| (L) || Рекурсивно обійти для ліве піддерево. |- | (R) || Рекурсивно обійти для праве піддерево. |- | (N) || Обробити поточний вузол . |- |colspan=\"2\"| Повернутися, піднявшись на один рівень і прибути до батьківського вузла . |} У прикладах здебільшого (L) виконується перед (R). Але можливе виконання (R) перед (L), див. (RNL). міні|281x281пкс|Обхід дерева вглиб: прямий (червоний): зворотній (зелений): серединний (жовтий): Існують три види таких обходів, кожний з яких визначається рекурсивно: прямий порядок (NLR) () наступної послідовності: відвідати корінь відвідати ліве піддерево відвідати праве піддерево Тобто, в такому порядку обходу кожна вершина відвідується до того, як будуть відвідані її діти. зворотний порядок (LRN) () наступної послідовності: відвідати ліве піддерево відвідати праве піддерево відвідати корінь Тобто, в такому порядку кожна вершина відвідується лише після того, як будуть відвідані її діти. серединний (центрований) порядок (LNR) () наступної послідовності: відвідати ліве піддерево відвідати корінь відвідати праве піддерево В такому порядку кожна вершина відвідується між відвіданням лівої та правої дитини. Такий порядок особливо часто застосовується в бінарних деревах пошуку, тому що дає можливість обходу вершин у порядку збільшення їхніх порядкових номерів. Приклад Бінарне дерево Для цього бінарного дерева, Прямий порядок: 2, 7, 2, 6, 5, 11, 5, 9, 4 Зворотний порядок: 2, 5, 11, 6, 7, 4, 9, 5, 2 серединний (центрований) порядок: 2, 7, 5, 6, 11, 2, 5, 4, 9 Див. також Дерево (структура даних) Модель вкладених множин Список алгоритмів Пошук в глибину Пошук у ширину Примітки Література Категорія:Програмування Категорія:Алгоритми на графах Категорія:Дерева (структури даних)"}
{"category": "Програмування", "title": "Обчислення за короткою схемою", "abstract": "Обчислення за короткою схемою, мінімальне обчислювання або обчислювання Маккарті (за Джоном Маккарті) — це семантика деяких булевих операторів у деяких мовах програмування, в яких другий аргумент виконується або обчислюється лише в тому випадку, якщо значення першого аргументу недостатньо для визначення загального значення виразу. Інакше кажучи, для функції AND значення false першого аргументу достатньо, щоб отримати загальне значення false; і для функції OR значення true першого аргументу достатньо, щоб отримати загальне значення true.\nУ мовах програмування з лінивими обчислюваннями (Lisp, Perl, Haskell) звичайні булеві оператори обчислюються за короткою схемою. В інших (Ada, Java, Delphi) доступні як оператори мінімального обчислювання, так і стандартні булеві оператори. Для деяких булевих операцій, таких як виключне «або» (XOR), неможливо здійснити мінімальне обчислювання, оскільки для визначення результату завжди потрібні обидва операнди.", "content": "Обчислення за короткою схемою, мінімальне обчислювання або обчислювання Маккарті (за Джоном Маккарті) — це семантика деяких булевих операторів у деяких мовах програмування, в яких другий аргумент виконується або обчислюється лише в тому випадку, якщо значення першого аргументу недостатньо для визначення загального значення виразу. Інакше кажучи, для функції AND значення false першого аргументу достатньо, щоб отримати загальне значення false; і для функції OR значення true першого аргументу достатньо, щоб отримати загальне значення true. У мовах програмування з лінивими обчислюваннями (Lisp, Perl, Haskell) звичайні булеві оператори обчислюються за короткою схемою. В інших (Ada, Java, Delphi) доступні як оператори мінімального обчислювання, так і стандартні булеві оператори. Для деяких булевих операцій, таких як виключне «або» (XOR), неможливо здійснити мінімальне обчислювання, оскільки для визначення результату завжди потрібні обидва операнди. Визначення У будь-якій мові програмування, що реалізує мінімальне обчислювання, вираз x and y еквівалентний умовному виразу if x then y else x, а вираз x or y еквівалентний if x then x else y. В обох випадках x обчислюється лише один раз. Наведене вище узагальнене визначення також стосується мов, які мають більше, ніж два значення істинності True і False, де оператори короткої схеми повертають останнє обчислене значення підвиразу. У таблиці нижче це називається «останнім значенням». Для строго визначеної мови вираз спрощується: if x then y else false і if x then true else y відповідно до логічних виразів AND і OR. Перевага Хоча має більший пріоритет, ніж у багатьох мовах, це не є універсальною властивістю оцінки короткого замикання. Прикладом того, як два оператори мають однаковий пріоритет і мають ліву асоціацію один з одним, є синтаксис списку команд оболонки POSIX. Наступний приклад встановлює пріоритет для AND перед OR використовуючи continue: function short-circuit-eval (operators, values) let result := True for each (op, val) in (operators, values): if op = \"AND\" && result = False continue else if op = \"OR\" && result = True return result else result := val return result Формалізація Логіка «короткої схеми» (з побічними ефектами або без них) була формалізована на основі логіки Гоара. Результатом є те, що оператори, що не діють за принципом мінімального обчислення, можуть бути визначені з логіки «короткої схеми», щоб мати однакову послідовність обчислення. Підтримка загальних та скриптових мов програмування +Булеві оператори в різних мовах програмуванняМоваОператори строгого обчислюванняОператори мінімального обчислюванняВихідний тип данихAdaand, orand then, or elseБулевийALGOL 68and, &, ∧ ; or, ∨ andf,orf (обидва визначені користувачем)БулевийAPL∧, ∨, ⍲ (nand), ⍱ (nor), etc.:AndIf, :OrIfБулевийABAP та APL не мають окремого булевого типу.awkвідсутні&&, ||БулевийBashвідсутні&&, ||БулевийC, Objective-Cвідсутні&&, ||, ?int (&&,||), залежить від операнда (?)C++При перевантаженні оператори && та || є строгими та можуть повернути будь-який тип.відсутні&&, ||, ?Булевий (&&,||), залежить від операнда (?)C#&, |&&, ||, ?, ??Булевий (&&,||), залежить від операнда(?, ??)DЦе стосується лише виразів static if та static assert, обчислених під час виконання. Вирази в статичних ініціалізаторах або маніфестних константах використовують повне обчислення.&, |&&, ||, ?Булевий (&&,||), залежить від операнда (?)Eiffeland, orand then, or elseБулевийErlangand, orandalso, orelseБулевийFortranОператори Fortran не мають окремих операторів мінімального чи повного обчислювання: специфікація мови дозволяє компілятору вибрати метод оптимізації..and., .or..and., .or.БулевийGo, Haskell, OCamlвідсутні&&, ||БулевийJava, MATLAB, R, Swift&, |&&, ||БулевийJavaScript, Julia&, |&&, ||Останнє значенняKotlinand, or&&, ||БулевийLisp, Lua, Schemeвідсутніand, orОстаннє значенняOberonвідсутні&, ORБулевийOCamlвідсутні&&, ||БулевийPascaland, orISO / IEC 10206: 1990 Extended Pascal дозволяє, але не вимагає мінімального обчислення.Delphi та Free Pascal за замовчуванням обчислюють за короткою схемою. Це може бути змінено параметрами компілятора, але не використовується широко.and_then, or_elseISO / IEC 10206: 1990 Extended Pascal підтримує and_then та or_else.БулевийPerl, Ruby&, |&&, and, ||, orLast valuePHP&, |&&, and, ||, orБулевийPOSIX shell (command list)відсутні&&, ||Останнє значенняPythonвідсутніand, orОстаннє значенняRust&, |&&, ||БулевийSmalltalk&, |and:, or:Smalltalk використовує семантику «короткої схеми» до тих пір, поки аргументом and: є блок (наприклад, false and: [Transcript show: 'Wont see me'])БулевийStandard ML andalso, orelseБулевийVisual Basic .NETAnd, OrAndAlso, OrElseБулевийVisual Basic, Visual Basic for Applications (VBA)And, OrSelect CaseМови BASIC, які підтримували оператори CASE, робили це за допомогою системи умовної оцінки, а не як таблиці переходів, обмежених фіксованими мітками.Числовий Загальне використання Уникнення небажаних побічних ефектів другого аргументу Звичайний приклад використання мови на основі С:int denom = 0; if (denom != 0 && num / denom) { ... // гарантується, що обчислення num/denom ніколи не призведе до помилки, пов'язаної з діленням на нуль }Розглянемо наступний приклад:int a = 0; if (a != 0 && myfunc(b)) { do_something(); }У цьому прикладі мінімальне обчислення гарантує, що myfunc(b) ніколи не викликається. Це тому, що a != 0 має значення false . Ця функція дозволяє дві корисні конструкції програмування. Якщо перший підвираз перевіряє, чи потрібне строге обчислення, і перевірка має значення false, можна усунути строге обчислення у другому аргументі. Це дозволяє конструкцію, де перший вираз гарантує умову, без якої другий вираз може спричинити помилку під час виконання . Обидва вони проілюстровані в наведеному нижче фрагменті C, де мінімальна оцінка запобігає як розіменовуванню нульового покажчика, так і надмірному вибору пам'яті:bool is_first_char_valid_alpha_unsafe(const char *p) { return isalpha(p[0]); // Помилка сегментації цілком можлива при p == NULL } bool is_first_char_valid_alpha(const char *p) { return p != NULL && isalpha(p[0]); // 1) не потрібно виконувати isalpha() при p == NULL, 2) немає жодного ризику виникнення помилки сегментації } Ідіоматична умовна конструкція Оскільки мінімальна оцінка є частиною семантичного визначення оператора, а не (необов'язковою) оптимізацією, то існує багато моделей кодування, що почали використовувати її як ідіоматичну умовну конструкцію. Приклади включають: Ідіоми Perl: some_condition or die; # Перервати виконання якщо значення some_condition - false some_condition and die; # Перервати виконання якщо значення some_condition - true Ідіоми POSIX shell: modprobe -q some_module && echo \"some_module installed\" || echo \"some_module not installed\" Ця ідіома передбачає, що echo не може зазнати невдачі. Можливі проблеми Неперевірена друга умова призводить до невиконання побічного ефекту Незважаючи на ці переваги, мінімальне обчислення може спричинити проблеми для програмістів, які не усвідомлюють (або забувають), що відбувається. Наприклад, у кодіif (expressionA && myfunc(b)) { do_something(); }Якщо myfunc(b) повинен виконати якусь необхідну операцію незалежно від того, чи do_something() взагалі виконується, наприклад, розподіл системних ресурсів, а expressionA дорівнює false, то myfunc(b) не буде виконуватися, що може спричинити проблеми. Деякі мови програмування, такі як Java, мають два оператори — один, який використовує мінімальне обчислення, а другий — ні, щоб уникнути цієї проблеми. Проблеми з невиконаними операторами побічних ефектів можна легко вирішити за допомогою належного стилю програмування, тобто, не використовуючи побічні ефекти в булевих операторах, оскільки використання значень з побічними ефектами в оцінках, як правило, робить код непрозорим і схильним до помилок. Зниження ефективності через обмежувальні оптимізації Обчислення за короткою схемою може призвести до помилок у прогнозуванні розгалужень на сучасних центральних процесорах (ЦП) і різко знизити продуктивність. Деякі компілятори можуть виявляти такі випадки та швидше випускати код, але семантика мови програмування може стримувати таку оптимізацію. Прикладом компілятора, який не може знайти оптимізації для такого випадку, є Hotspot VM Java 2012 року. Примітки Категорія:Програмування Категорія:Математична логіка Категорія:Оптимізації компілятора Категорія:Статті з прикладами коду мовою Perl Категорія:Статті з прикладами коду мовою C Категорія:Сторінки з неперевіреними перекладами"}
{"category": "Програмування", "title": "Патч", "abstract": "Патч або латка (англ. Patch) — інформація, призначена для автоматизованого внесення певних змін в комп'ютерні файли.\nВиправлення може застосовуватися до файлів вже встановленої програми, або до її початкових кодів. Сюди входить виправлення помилок, зміна зовнішнього вигляду, поліпшення ергономічності або продуктивності програм, а також будь-які інші зміни, які розробник побажав зробити.\nРозмір патчів може варіюватися від декількох кілобайт до сотень мегабайт. Зокрема, дуже великими патчі можуть бути при зміні або заміні бінарних даних, таких як файли з графікою і звуком (часто зустрічаються в комп'ютерних іграх). Тим не менш, великий розмір може бути викликаний і численністю внесених змін. При цьому слова «патч», «латка» зазвичай використовуються для позначення невеликих виправлень окремих програм. Великі патчі, що значно змінюють або оновлюють систему або набір програм називають пакетом оновлень (Service Pack).\nПатч для внесення змін в початковий код зазвичай має формат текстового файлу.\nВ ОС UNIX та Linux патч може бути отриманий командою diff, застосований командою patch.", "content": "Патч або латка () — інформація, призначена для автоматизованого внесення певних змін в комп'ютерні файли. Виправлення може застосовуватися до файлів вже встановленої програми, або до її початкових кодів. Сюди входить виправлення помилок, зміна зовнішнього вигляду, поліпшення ергономічності або продуктивності програм, а також будь-які інші зміни, які розробник побажав зробити. Розмір патчів може варіюватися від декількох кілобайт до сотень мегабайт. Зокрема, дуже великими патчі можуть бути при зміні або заміні бінарних даних, таких як файли з графікою і звуком (часто зустрічаються в комп'ютерних іграх). Тим не менш, великий розмір може бути викликаний і численністю внесених змін. При цьому слова «патч», «латка» зазвичай використовуються для позначення невеликих виправлень окремих програм. Великі патчі, що значно змінюють або оновлюють систему або набір програм називають пакетом оновлень (Service Pack). Патч для внесення змін в початковий код зазвичай має формат текстового файлу. В ОС UNIX та Linux патч може бути отриманий командою diffdiff(1) - Linux man page, застосований командою patchpatch(1) - Linux man page. Приклад Первинний файл: int main() { printf(\"Hello\"); } Вміст файла патчу: 2c2,3 < printf(\"Hello\"); --- > printf(\"Hello\\n\"); > return 0; Файл після накладання патчу: int main() { printf(\"Hello\\n\"); return 0; } Патч в культурі «Як пропатчити KDE2 під FreeBSD?» — Інтернет-мем, питання, яке досить часто ставлять ПрезидентамЮщенко ответил, как пропатчить KDE2 под FreeBSD«Как пропатчить KDE под FreeBSD?» Ставим опыт!. Примітки Категорія:Програмне забезпечення Категорія:Програмування Категорія:Файли Категорія:Супровід програмного забезпечення Категорія:Статті з прикладами коду мовою C"}
{"category": "Програмування", "title": "Перехоплення (інформатика)", "abstract": "Перехоплення (англ. hooking) — технологія для зміни або посилення поведінки операційної системи, або застосунку, чи інших програмних складових, шляхом перехоплення викликів функцій або повідомлень або подій, які передаються між програмними компонентами. Код, який обробляє такі перехоплені виклики функцій, подій або повідомлень називається «гук» (англ. hook).\nПерехоплення використовується для різних задач, в тому числі і зневадження і розширення функціональності. Прикладами є перехоплення повідомлень подій клавіатури або миші, перш ніж вони досягнуть застосунку, або перехоплення, які операційна система викликає для того, щоб контролювати поведінку або змінювати функцію програми або іншого компонента. Перехоплення також широко використовується в бенчмаркінгу програм, наприклад, для вимірювання швидкості генерації кадрів в 3D-іграх, де ввід та вивід відбувається через перехоплення.\nПерехоплення також може бути використане шкідливим кодом. Наприклад, руткіти, складові програмного забезпечення, використовують перехоплення для фальсифікації викликів API, використання яких вказало б на існування руткіта, і це дозволяє йому (руткіту) залишитись невидимим. Воллхакінг (англ. Wallhack) є ще одним прикладом шкідливої поведінки програм, які спираються на техніку перехоплень викликів функцій у комп'ютерній грі, відображає додаткову інформацію гравцеві, що дозволяє отримати перевагу над іншими гравцями.", "content": "Перехоплення () — технологія для зміни або посилення поведінки операційної системи, або застосунку, чи інших програмних складових, шляхом перехоплення викликів функцій або повідомлень або подій, які передаються між програмними компонентами. Код, який обробляє такі перехоплені виклики функцій, подій або повідомлень називається «гук» (). Перехоплення використовується для різних задач, в тому числі і зневадження і розширення функціональності. Прикладами є перехоплення повідомлень подій клавіатури або миші, перш ніж вони досягнуть застосунку, або перехоплення, які операційна система викликає для того, щоб контролювати поведінку або змінювати функцію програми або іншого компонента. Перехоплення також широко використовується в бенчмаркінгу програм, наприклад, для вимірювання швидкості генерації кадрів в 3D-іграх, де ввід та вивід відбувається через перехоплення. Перехоплення також може бути використане шкідливим кодом. Наприклад, руткіти, складові програмного забезпечення, використовують перехоплення для фальсифікації викликів API, використання яких вказало б на існування руткіта, і це дозволяє йому (руткіту) залишитись невидимим. Воллхакінг () є ще одним прикладом шкідливої поведінки програм, які спираються на техніку перехоплень викликів функцій у комп'ютерній грі, відображає додаткову інформацію гравцеві, що дозволяє отримати перевагу над іншими гравцями. Призначення технології перехоплення Дуже часто в системному програмуванні виникає задача зміни стандартної поведінки системних функцій. Наприклад, досить цікавим застосуванням даної технології є перевизначення віконної процедури у GUI програм Windows (). Це потрібно, якщо програміст хоче організувати власну обробку будь-якого віконного повідомлення і тільки тоді передати стандартній віконній процедурі. Після субкласингу цикл обробки повідомлень буде виглядати так: ДО субкласингу: Повідомлення Windows -> Вікно (віконна процедура) ПІСЛЯ: Повідомлення Windows -> Наша віконна процедура -> Вікно (віконна процедура) Наприклад, в уроках «Iczelion»'а описаний приклад того, як субкласинг може використовуватися для організації контролю вводу в елементи управління. Технології перехоплення потрібні не тільки в цьому випадку, але і, наприклад, для попередньої обробки результатів системних функцій пошуку файлів «FindFirst» і «FindNext», «EnumProcess», яка перераховує процеси в Windows і т. д. Причому в цих цілях такі технології застосовують як антивірусні засобинаприклад: неможливо отримати доступ до процесу Kaspersky Internet Security штатними засобами Windows API, так як відповідні функції перехоплені антивірусом., так і різного роду віруси, руткіти та інші види шкідливого програмного забезпечення. Дуже часто перехоплення буває важливим для організації та налагодження програм і є однією з основних технологій, застосовуваних в зневаджувачах. В даному випадку ця технологія дозволяє одній програмі контролювати виконання іншої. Для цих цілей передбачений системний виклик «ptrace», який дозволяє підключатися до процесів, відслідковувати значення регістрів у контексті процесу, який зневаджується і в тому числі контролювати інші системні виклики. Він є основою для реалізації такої можливості зневаджувачив як точки зупину. Даний системний виклик добре документований і присутній у всіх головних «*Nix» системах: Linux, FreeBSD, SolarisСторінка з man Linux Ubuntu: man сторінка про виклик ptrace і російськомовна версія: Русский переклад на OpenNET . Найчастіше використовується спільно з системним викликом «fork», який і викликає «ptrace», вказуючи в параметрах виклику, що запускається дочірній процес. Microsoft Windows також надає для схожих цілей т. зв. DebugAPIОфіційний опис: The Debugging Application Programming Interface , а також приклади використання: Win32 API. Урок 28. Win32 Debug API I . Види перехоплення системних функцій Основними методами перехоплення є: Підміна адреси справжньої функції (модифікація таблиць, модифікація /IDT таблиць) Безпосередня зміна функції (сплайсинг, перехоплення в режимі ядра з модифікацією тіла функції) Безпосередня підміна всього компонента програми/системи (наприклад бібліотеки з цільовою функцією) Методи можна також розділити за критерієм режиму виконання: Користувацькі (кільця захисту) методи: модифікація IAT таблиць, сплайсинг. Їх особливість в тому, що неможливо щось змінити в поведінці ядра операційної системи та його розширень. Режиму ядра: модифікація SSDT/IDT таблиць, перехоплення в режимі ядра з модифікацією тіла функції. Дозволяє модифікувати структури даних і код будь-якої частини операційної системи та програм. Сплайсинг Сплайсинг (від англ. Splice — «зрощувати або склеювати кінці чого-небудь») — метод перехоплення API функцій шляхом зміни коду цільової функції. Зазвичай змінюються перші 5 байт функції. Замість них вставляється перехід на функцію, яку визначає програміст. Щоб забезпечити коректність виконання операції, програма, яка перехоплює функцію, зобов'язана дати можливість виконатися коду, який був змінений в результаті сплайсингу. Для цього програма зберігає змінену ділянку пам'яті у себе, а після відпрацювання функції перехоплення відновлює змінену ділянку функції і дає повністю виконатися справжній функції. Особливості технології Для того щоб програма могла використовувати дану технологію, вона повинна мати вбудований дизасемблерний рушій і спеціальний , який дозволить знаходити потрібну функцію і коректно її змінювати. Ця технологія вкрай платформно-залежна, а тому потребує ретельного контролю та перевірки системи на відповідність версій, а також перевірки самої функції на відповідність цільової. Системні функції можуть змінюватися при виході патчів і оновлень Windows (особливо Service Pack для Windows), а також в результаті модифікацій з боку інших програм. Помилки при роботі з даною технологією можуть призводити до BSOD. Водночас ця технологія дозволяє здійснювати глобальне перехоплення API функцій, впливаючи таким чином на всі процеси в системі. Починаючи з Windows XP SP2 для підтримки «гарячого патчу» Microsoft змінила стандартний пролог функцій з трьох байт до п'яти (додала mov edi, edi в стандартний пролог push ebp; mov ebp, esp), що дозволяє не проводити аналіз довжин. Довжини в п'ять байт вистачає для заміни прологу на «опкоди» дальнього переходу, а відомий пролог дозволяє коректно передати управління функції, яку підміняють. Сфери застосування сплайсинга і методи виявлення Він застосовується: В ПО, якому необхідно здійснювати функції моніторингу системи; Механізмом гуків в Windows; Різного роду шкідливими програмами. Це основна технологія приховування для руткітів користувацького рівня. Основний метод виявлення факту сплайсингу — це порівняння машинного коду функції, який перевіряється на сплайсинг, і коду системної функції, отриманого в напевно чистій системі. Також в виявленні сплайсинга функції може допомогти контроль адрес переходу. Порівняння з іншими технологіями Зміна IAT таблиць процесу Методи доступу і модифікації IAT таблиці досить докладно описані у Хоглунд Г., Батлер Дж. — Руткити: впровадження в ядро Windows. Гл 4 Давнє мистецтво захоплення . Дана технологія не дозволяє змінити поведінку самої системної функції, а лише дає можливість «обдурити» вибрану програму, змусивши її використовувати вашу функцію. IAT таблиця — таблиця адрес функцій, імпортованих процесом. Технологія носить лише локальний характер, хоча може бути застосована відразу до групи програм. Може бути досить швидко виявлена ​​через необхідність завантаження DLLМетоди впровадження DLL в чужий процес описані досить докладно у Дж. Ріхтера Крістофера Назара Windows via C / C ++. Програмування на мові Visual C ++. Деякі методи впровадження вперше документував сам Дж. Ріхтер в адресний простір цільового процесу. Сплайсинг же, не вимагає DLL і впровадження в чужий процес, володіє можливістю глобального захвату функції. В ньому є ще одна перевага: не всі системні функції імпортуються процесом через IAT. Наприклад, функція може бути завантажена викликом «Getprocaddress». Використання ж безпосередньої модифікації коду функції знімає подібне обмеження. Перехоплення в режимі ядра. Дозволяє перехоплювати будь-які функції, в тому числі і експортовані ядром. Найбільш важкий для виявлення в разі успіху, тому що дозволяє фальсифікувати будь-які дані, що надаються операційною системою. Вимагає написання спеціального компоненту для взаємодії з ядром — драйвера. Може привести до BSOD при неправильному програмуванні в режимі ядра. Може бути виявлений на фазі завантаження драйвера в ядро або при перевірці активних драйверів, а також при перевірці ядра на зміниНаприклад, один з перших руткит-детектеров KLISTNER . Більш важкий у програмуванні метод, ніж сплайсинг, але більш гнучкий, тому що дозволяє перехопити функції самого ядра, а не тільки «WinAPI» функції, які служать лише посередником між ядром і програмою, яка що-небудь запитує у операційної системи. Заміна самої бібліотеки з функцією. Вельми радикальне вирішення проблеми, має ряд істотних недоліків: Вимагає заміни файлу на диску, що може бути заборонено та припинено самою системою. Наприклад, заміну системних файлів Windows не дозволить виконати , хоча його можна і виключити. Така дія може бути також виявлена при статичному аналізі системи ревізорами. Потрібна повна емуляція всіх можливостей замінної DLL чи іншого компонента, що дуже занадто навіть у разі відкритості і ускладнюється необхідністю дизасемблювання в разі закритості цільової програми. Все це показує, що це вельми нераціональний спосіб вирішення проблеми зміни поведінки програми в разі можливості застосування перших двох підходів або сплайсинга. Перехоплення в режимі ядра Він заснований на модифікації структур даних ядра і функцій. Головними мішенями впливу є таблиці: IDT — Таблиця диспетчеризації переривань. Досить важливим для перехоплення є переривання, що обробляє звернення до таблиці служб SSDT (0x2E) Г. Хоглунд Дж. Батлер Руткіти впровадження в ядро Windows. Глава 4 Давнє мистецтво захоплення . SSDT (System Service Dispatch Table) — Таблиця диспетчеризації системних сервісів. Звертаючись до неї, система за номером забороненого сервісу може отримати адресу відповідного сервісу ядра і викликати його. А таблиця SSPT містить загальний розмір параметрів, що передаються системному сервісу. PsActiveprocess — Структура ядра, що зберігає список процесів в системі. — Таблиця драйвера, яка зберігає покажчики на функції обробки IRP-пакетів. EPROCESS — Структура ядра, що зберігає велику кількість інформації про процес, включаючи, наприклад, PID (ідентифікатор процесу). Такого роду руткіти називаються DKOM-руткітами, тобто руткітами, заснованими на безпосередній модифікації об'єктів ядра. В руткітах для систем Windows Server 2003 і XP ця технологія була модернізована, так як в цих ОС з'явився захист від запису деяких областей пам'яті ядра. Windows Vista і 7 отримали додатковий захист ядра PatchGuard, однак всі ці технології були подолані руткітописателями 072/072 / 5.asp вбивство годинного Кріс Касперски, АКА МИЩЪХ Спецвипуск: Хакер, номер # 072, стр. 072-072-5 . Водночас перехоплення системних функцій в режимі ядра — основа проактивних систем захисту та гіпервізорів. Інші форми перехоплення Можна виділити й інші форми перехоплення: Перехоплення мережевих з'єднань та пакетів Наприклад, цим займаються сніфери. Однією з безкоштовних реалізацій захоплення мережевих пакетів є мережевий драйвер рівня NDIS WinPCAP . Перехоплення паролів. Наприклад, за допомогою шпигунства за клавіатурним введенням за допомогою кейлоггера. Перехоплення звернень браузера до сайтів за допомогою HTTP Proxy або розширень браузера. Дозволяє проаналізувати та/або підмінити дані, якими обмінюються браузер і сервер. Тут описана лише частина застосувань даної технології. Приклади програм, що використовують перехоплення Гіпервізор Xen Утиліти «Filemon», «Regmon», ; Руткіт Rustock.C . Див. також Отладчик Асемблер Руткіт Комп'ютерний вірус Примітки Література Посилання Цикл статей з перехоплення функцій від Ms Rem Стеження за викликами Native API Туторіали Iczelion'а про Win32 API Сплайсинг WinAPI з використанням Сі і MASM Категорія:Інформаційна безпека Категорія:Програмування"}
{"category": "Програмування", "title": "Персистентність", "abstract": "Персистентність в програмуванні означає здатність стану існувати довше, ніж процес, що створив його. Без цієї можливості, стан може існувати лише в оперативній пам'яті і втрачається, коли оперативна пам'ять вимикається, наприклад, при вимкненні комп'ютера.\nЦе досягається шляхом зберігання стану як даних на пристрої тривалого зберігання, такому як жорсткий диск чи флеш-пам'ять.\nНаприклад, графічні редактори чи текстові процесори досягають персистентності стану шляхом зберігання своїх документів у файл.", "content": "Персистентність в програмуванні означає здатність стану існувати довше, ніж процес, що створив його. Без цієї можливості, стан може існувати лише в оперативній пам'яті і втрачається, коли оперативна пам'ять вимикається, наприклад, при вимкненні комп'ютера. Це досягається шляхом зберігання стану як даних на пристрої тривалого зберігання, такому як жорсткий диск чи флеш-пам'ять. Наприклад, графічні редактори чи текстові процесори досягають персистентності стану шляхом зберігання своїх документів у файл. Ортогональна чи прозора персистентність Персистентність називається «ортогональною» чи «прозорою», якщо вона реалізована як внутрішня властивість середовища виконання програми. Середовище для ортогональної персистентності не потребує жодних спеціальних дій програм, що виконуються в ньому, для збереження чи відновлення свого стану. Неортогональна персистентність потребує запису й читання даних на пристрої зберігання шляхом використання спеціальних інструкцій у програмі, для опису чого використовується допоміжне дієслово зберігати: При завершенні програма зберігає дані. Перевага середовища ортогональної персистентності — простіші й менш схильні до помилок програми. Способи реалізації персистентності Образи системи Використання образів системи — найпростіший спосіб реалізації персистентності. Сплячий режим ноутбука — приклад ортогональної персистентності з використанням образу системи, оскільки він не потребує ніяких дій програм, запущених на машині. Прикладом неортогональної персистентності з використанням образу системи є виконання редактором простого тексту специфічних інструкцій для збереження всього документу в файл. Недоліки: Зміни стану, зроблені в системі після останнього збереження образу втрачаються в випадку збою чи вимкнення системи. Збереження образу після кожної невеликої зміни може стати занадто часоємнісним для більшості систем, тому образи не використовуються як метод простої персистентності для критичних систем. Журнали Використання журналів — другий за простотою спосіб реалізації персистентності. Журналювання — процес збереження подій у лог перед застосуванням до системи. Такі логи називаються журналами. На старті журнал читається, і кожна дія повторно застосовується до системи, що дозволяє уникнути втрати даних у випадку збою чи вимкнення. Наприклад, уся історія скасування/повторення команд користувача у графічному редакторі при записі в файл утворює журнал, придатний для відновлення стану редагованого малюнка в будь-який момент часу. Журнали використовуються журнальними файловими системами і СУБД, де вони також називаються логами транзакцій чи логами повторних дій. Недоліки: Журнали часто поєднуються з іншими методиками персистентності, щоб уся (потенційно велика) історія всіх подій системи не потребувала повторного застосування при запуску системи. Превалентність системи Превалентність системи (System prevalence) — методика, що поєднує системні образи й журнали транзакцій, розглянуті вище, щоб обійти їхні обмеження. Недоліки: Превалентна система повинна мати достатньо оперативної пам'яті для розміщення всього стану системи. «Брудний» запис «Брудний» запис полягає у записі на зовнішньому пристрої лише тих частин стану системи, що були змінені («забруднились») після свого останнього запису. Наприклад, складні програми редагування документів використовуватимуть «брудний» запис для збереження лише тих частин документа, що змінились після останнього збереження. Недоліки: Ця техніка потребує перехоплення змін стану в межах програми. Це досягається непрозорим способом, що потребує спеціальних викликів API збереження, або прозорим способом з автоматичною трансформацією програми. В результаті, код стає повільнішим, ніж нативний код, і його важче налагоджувати. Рівні персистентності Будь-який рівень програмного забезпечення (software layer), що допомагає програмі зберегти стан, узагальнено називається рівнем персистентності. Більшість рівнів персистентності не досягають персистентності безпосередньо, а використовують основну СКБД. СКБД СКБД використовують поєднання «брудного» запису й журналу транзакцій, розглянутих вище. Вони забезпечують не лише персистентність, а й інші послуги, такі як запити, ревізії й контроль доступу. Персистентні операційні системи Персистентні ОС — операційні системи, що зберігають свій стан навіть після збою чи неочікуваного вимкнення. Комп'ютер лишається в тому ж стані, навіть якщо його вимкнути, подібно до телевізора чи якогось простого пристрою. До операційних систем, що забезпечують таку можливість, належать: CapROS, переробка EROS Coyotos, нащадок EROS EROS, нащадок KeyKOS KeyKOS Multics з однорівневим сховищем single-level store Phantom Див. також CRUD Java Persistence API Категорія:Програмування Категорія:Моделі обчислень"}
